---
title: "Synchronize和Volatile底层实现原理"
description: "看《并发编程的艺术》时的笔记"
date: 2019-02-06 22:00:00
draft: false
categories: ["Java"]
tags: ["Java"]
---

最近在看`并发编程的艺术`这本书，希望加深对并发这块的理解。毕竟并发相关还是十分重要的。本文主要是关于`第二章Java并发机制的底层实现原理`的相关笔记。主要包括`volatile`,`synchronized`,`原子操作`等实现原理的分析。

<!--more-->



## 1. 上下文切换

**多线程**

即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。

**什么是上下文切换**

CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。

所以任务从保存到再加载的过程就是一次上下文切换。

**上下文切换也会影响多线程的执行速度**

因为线程有创建和上下文切换的开销，所以有时候并发不一定比串行快。

**减少上下文切换的办法**

减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。

- 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一
  些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
- CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
- 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这
  样会造成大量线程都处于等待状态。
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

## 2. volatile关键字

**如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。**

有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，其中就包括了`Lock前缀`.Lock前缀的指令在多核处理器下会引发了两件事情。

**1）将当前处理器缓存行的数据写回到系统内存。**

Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。

如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区
域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁
定”，`缓存一致性`机制会阻止同时修改由两个以上处理器缓存的内存区域数据。

**2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。**

处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。

## 3. synchronized原理与应用

**Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。**

Java中的每一个对象都可以作为锁。具体表现
为以下3种形式。

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的Class对象。
- 对于同步方法块，锁是Synchonized括号里配置的对象。
  当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

### 3.1 底层实现

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。

`代码块同步`是使用`monitorenter`和`monitorexit`指令实现的.

而`方法同步`是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

## 3.2 Java对象头

synchronized用的锁是存在Java对象头里的。

java的对象头由以下三部分组成：

> 1，Mark Word
>
> 2，指向类的指针
>
> 3，数组长度（只有数组对象才有）



![](https://github.com/lixd/blog/raw/master/images/java/art_of_concurrent_coding/java-object-header.png )

![](https://github.com/lixd/blog/raw/master/images/java/art_of_concurrent_coding/java-mark-work-state-change.png)

### 3.3 锁的升级与对比

Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状
态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。

**偏向锁**

HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

偏向锁解除

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程.

![](https://github.com/lixd/blog/raw/master/images/java/art_of_concurrent_coding/java-eccentric-lock.png)

**轻量级锁**

（1）轻量级锁加锁
线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
（2）轻量级锁解锁
轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

![](https://github.com/lixd/blog/raw/master/images/java/art_of_concurrent_coding/java-light-lock.png)

**优缺点比较**

![](https://github.com/lixd/blog/raw/master/images/java/art_of_concurrent_coding/java-lock-compare.png)

## 4. 原子操作的实现原理

原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。

### 4.1 处理器如何实现原子操作

处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

**第一个机制是通过总线锁保证原子性。**

所谓总线锁就是使用处理器提供的一个`LOCK＃信号`，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

**第二个机制是通过缓存锁定来保证原子性。**

总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为`缓存一致性`机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效.

### 4.2 Java如何实现原子操作

**使用循环CAS实现原子操作**

JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。

**CAS实现原子操作的三大问题**

1.ABA问题

但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。

ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。

2.循环时间长开销大

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

3.只能保证一个共享变量的原子操作

操作多个共享变量时无法使用CAS操作，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。

**使用锁机制实现原子操作**

锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。

## 参考

本文内容来自Java并发编程的艺术

