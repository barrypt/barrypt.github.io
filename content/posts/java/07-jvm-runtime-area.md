---
title: "Java运行时数据区"
description: "Java运行时数据区，包括线程私有的程序计数器，虚拟机栈，本地方法栈和线程共享的堆，方法区等简单介绍"
date: 2019-02-24 22:00:00
draft: false
categories: ["Java"]
tags: ["Java"]
---

本文主要讲的是Java运行时数据区，包括线程私有的`程序计数器`，`虚拟机栈`，`本地方法栈`和线程共享的`堆`，`方法区`等。

<!--more-->



![Java运行时数据区](https://github.com/barrypt/blog/raw/master/images/java/jvm/runtime-data-areas.png)

**线程私有的**：`程序计数器` 、`虚拟机栈`、`本地方法栈`

**线程共享的**： `堆`、`方法区 `

### 1.1 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

**程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

### 1.2 虚拟机栈

**Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。**

**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** 

Java虚拟机栈是由一个个`栈帧`组成，而每个栈帧中都拥有：`局部变量表`、`操作数栈`、`动态链接`、`方法出口`。

每个方法在执行时都会创建一个栈帧,每一个方法从调用到执行完成的过程就是一个栈帧在虚拟机中的入栈到出栈的过程。

#### 局部变量表

存放了编译时期可知的各种基本类型（Boolean，byte，char,short,int.float.long,double）、对象引用（reference类型）和returnAddress（指向了一条字节码指令的地址）。`局部变量表的创建是在方法被执行的时候,随着栈帧的创建而创建`.而且,`局部变量表的大小在编译时期就可以确定下来了`,在创建的时候只需要分配实现规定好的大小即可.此外,在`方法运行过程中局部变量表的大小是不会发生改变的`。

#### 操作数栈

后进先出LIFO，最大深度由编译期确定。栈帧刚建立时，操作数栈为空，执行方法操作时，操作数栈用于存放JVM从局部变量表复制的常量或者变量，提供提取，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。
操作数栈可以存放一个jvm中定义的任意数据类型的值。在任意时刻，操作数栈都一个固定的栈深度，基本类型除了long、double占用两个深度，其它占用一个深度.

#### 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。

#### 方法返回地址

当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。

方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

### 1.3 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

### 1.4 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**Java虚拟机规范中说的是：所有的对象实例以及数组都要在堆上分配内存。但是随着`JIT(just in time)编译器`的发展与`逃逸分析`技术的成熟，`栈上分配`，`标量替换`优化技术将会导致一些微妙的变化，所有对象都分配在堆上也变得不是那么绝对了。

Java 堆是垃圾收集器管理的主要区域，因此也被称作`GC堆（Garbage Collected Heap）`**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：`新生代`和`老年代`：再细致一点有：`Eden空间`、`From Survivor空间`、`To Survivor空间`等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

### 1.5 方法区

**方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的`类信息`、`常量`、`静态变量`、`即时编译器编译后的代码`等数据。**

**虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。**

HotSpot 虚拟机中方法区也常被称为 **“永久代”**，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。

**相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**

### 1.6 常量池

#### 全局字符串池

全局字符串池里的内容是在类加载完成，经过验证，**准备阶段之后**在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

#### 静态常量池

也叫`class文件常量池（class constant pool）`,Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是`常量池`,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在`类加载后`进入方法区的`运行时常量池`。

 `字面量`就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。

 `符号引用`是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

#### 运行时常量池

`运行时常量池`是`方法区`的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是`常量池`,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在`类加载后`进入方法区的`运行时常量池`。

既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

**JDK1.8后放在一个独立空间里面，叫做“元空间”** 

jvm在执行某个类的时候，必须经过`加载`、`连接`、`初始化`，而连接又包括`验证`、`准备`、`解析`三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，`运行时常量池也是每个类都有一个`。在上面我也说了，`class常量池中存的是字面量和符号引用`，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过`解析（resolve）`之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

#### 小结

- 1.全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。
- 2.class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。
- 3.运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

### 1.7 直接内存

直接内存并不是虚拟机运行时数据区的一部分，但是也频繁被用到，也可能导致OOM,虚拟机内存+直接内存超过物理内存时。

在JDK1.4出现的NIO类中引入了一个基于Channel和Buffer的IO方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，能在一些场合中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

### 参考

《深入理解Java虚拟机》

`https://blog.csdn.net/qq_26222859/article/details/73135660`