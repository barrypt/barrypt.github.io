<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Go语言之 sync.pool 源码分析 -</title><meta name=Description content="sync.pool 库源码分析及其使用场景介绍"><meta property="og:title" content="Go语言之 sync.pool 源码分析"><meta property="og:description" content="sync.pool 库源码分析及其使用场景介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/go/sync-pool/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-15T22:00:00+00:00"><meta property="article:modified_time" content="2021-10-15T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Go语言之 sync.pool 源码分析"><meta name=twitter:description content="sync.pool 库源码分析及其使用场景介绍"><meta name=application-name content="指月小筑"><meta name=apple-mobile-web-app-title content="指月小筑"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/go/sync-pool/><link rel=prev href=https://blog.yudlk.com/posts/kafka/12-hw-leader-epoch/><link rel=next href=https://blog.yudlk.com/posts/go/context/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Go语言之 sync.pool 源码分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/go\/sync-pool\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Golang","wordcount":8030,"url":"https:\/\/blog.yudlk.com\/posts\/go\/sync-pool\/","datePublished":"2021-10-15T22:00:00+00:00","dateModified":"2021-10-15T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"sync.pool 库源码分析及其使用场景介绍"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=指月小筑>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=指月小筑>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Go语言之 sync.pool 源码分析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/lixd title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/golang/><i class="far fa-folder fa-fw" aria-hidden=true></i>Golang</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-10-15>2021-10-15</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;8030 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;17 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-概述>1. 概述</a><ul><li><a href=#大致理念>大致理念</a></li><li><a href=#基本使用>基本使用</a></li><li><a href=#使用案例>使用案例</a></li><li><a href=#正确姿势>正确姿势</a></li></ul></li><li><a href=#2-源码分析>2. 源码分析</a><ul><li><a href=#pool-结构体>Pool 结构体</a></li><li><a href=#大致流程>大致流程</a></li><li><a href=#get>Get</a></li><li><a href=#put>Put</a></li><li><a href=#gc>GC</a></li></ul></li><li><a href=#3-小结>3. 小结</a></li><li><a href=#4-参考>4. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要介绍了Go语言(golang)中的<code>sync.pool</code>包。给出了 sync.pool 的基本用法，以及各大框架中的使用案例。并从源码层面对其底层结构和具体实现原理进行分析。</p><blockquote><p>以下分析基于 Go 1.17.1</p></blockquote><h2 id=1-概述>1. 概述</h2><h3 id=大致理念>大致理念</h3><p><code>sync.Pool</code> 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p><blockquote><p>因为频繁的内存分配和回收会对性能产生影响，通过复用临时对象就可以避免改问题。</p></blockquote><p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p><blockquote><p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。
在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p></blockquote><p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p><p>所以，sync.pool 的作用一句话描述就是，<strong>复用临时对象，以避免频繁的内存分配和回收，从而减少 GC 压力</strong>。</p><h3 id=基本使用>基本使用</h3><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p><p>以下为基本使用 demo：</p><blockquote><p>完整代码见 <a href=https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go target=_blank rel="noopener noreffer">Github</a></p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Gopher</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span>   <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Remark</span> <span class=p>[</span><span class=mi>1024</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Gopher</span><span class=p>)</span> <span class=nf>Reset</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>Name</span> <span class=p>=</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>.</span><span class=nx>Remark</span> <span class=p>=</span> <span class=p>[</span><span class=mi>1024</span><span class=p>]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>gopherPool</span> <span class=p>=</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Pool</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>New</span><span class=p>:</span> <span class=kd>func</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Gopher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span> <span class=o>:=</span> <span class=nx>gopherPool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Gopher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;首次从 pool 里获取：&#34;</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>Name</span> <span class=p>=</span> <span class=s>&#34;first&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;设置 p.Name = %s\n&#34;</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>gopherPool</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nx>g</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Pool 里已有一个对象：&amp;{first}，调用 Get: &#34;</span><span class=p>,</span> <span class=nx>gopherPool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Gopher</span><span class=p>).</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Pool 没有对象了，调用 Get: &#34;</span><span class=p>,</span> <span class=nx>gopherPool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Gopher</span><span class=p>).</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>首次从 pool 里获取： 
</span></span><span class=line><span class=cl>设置 p.Name <span class=o>=</span> first
</span></span><span class=line><span class=cl>Pool 里已有一个对象：<span class=p>&amp;</span><span class=o>{</span>first<span class=o>}</span>，调用 Get:  first
</span></span><span class=line><span class=cl>Pool 没有对象了，调用 Get:  
</span></span></code></pre></div><p>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p><p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，<strong>最好的做法是在 Put 前，将对象清空</strong>。</p><p><strong>Benchmark</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>defaultGopher</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>Gopher</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;17x&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkUnmarshal</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>g</span> <span class=o>*</span><span class=nx>Gopher</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>g</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Gopher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>defaultGopher</span><span class=p>,</span> <span class=nx>g</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkUnmarshalWithPool</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>g</span> <span class=o>*</span><span class=nx>Gopher</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>g</span> <span class=p>=</span> <span class=nx>gopherPool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Gopher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>defaultGopher</span><span class=p>,</span> <span class=nx>g</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>g</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span> <span class=c1>// 重置后在放进去
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>gopherPool</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nx>g</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>BenchmarkUnmarshal-6                <span class=m>9518</span>            <span class=m>124806</span> ns/op            <span class=m>1280</span> B/op          <span class=m>6</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkUnmarshalWithPool-6       <span class=m>10000</span>            <span class=m>124350</span> ns/op             <span class=m>128</span> B/op          <span class=m>5</span> allocs/op
</span></span></code></pre></div><p>功能比较简单，其中 json 反序列化占用了大量时间，因此两种方式最终的执行时间几乎没什么变化。但是内存占用差了一个数量级，使用了 <code>sync.Pool</code> 后，内存占用仅为未使用的 128/1280=1/10，对 GC 的影响就很大了。</p><h3 id=使用案例>使用案例</h3><h4 id=fmt-包>fmt 包</h4><p>这部分主要看 <code>fmt.Printf</code> 如何使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Printf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>Fprintf</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span><span class=p>,</span> <span class=nx>format</span><span class=p>,</span> <span class=nx>a</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>继续看 <code>Fprintf</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=o>:=</span> <span class=nf>newPrinter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nf>doPrintf</span><span class=p>(</span><span class=nx>format</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nf>free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ppFree</span> <span class=p>=</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Pool</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>New</span><span class=p>:</span> <span class=kd>func</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>new</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span> <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>newPrinter</span><span class=p>()</span> <span class=o>*</span><span class=nx>pp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=o>:=</span> <span class=nx>ppFree</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>pp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>panicking</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>erroring</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>wrapErrs</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>init</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>pp</span><span class=p>)</span> <span class=nf>free</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>buf</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>64</span><span class=o>&lt;&lt;</span><span class=mi>10</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>buf</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>buf</span><span class=p>[:</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>arg</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>value</span> <span class=p>=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Value</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>wrappedErr</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>ppFree</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>归还到 Pool 前还进行了<strong>字段清零</strong>，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p><h4 id=gin-框架>gin 框架</h4><p>gin 框架会给每个请求分配一个 Context 用以进行追踪，这就是典型的 sync.pool 使用场景：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>New</span><span class=p>()</span> <span class=o>*</span><span class=nx>Engine</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>engine</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Engine</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>engine</span><span class=p>.</span><span class=nx>pool</span><span class=p>.</span><span class=nx>New</span> <span class=p>=</span> <span class=kd>func</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>engine</span><span class=p>.</span><span class=nf>allocateContext</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>engine</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>engine</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>allocateContext</span><span class=p>()</span> <span class=o>*</span><span class=nx>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Context</span><span class=p>{</span><span class=nx>engine</span><span class=p>:</span> <span class=nx>engine</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>engine</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>writermem</span><span class=p>.</span><span class=nf>reset</span><span class=p>(</span><span class=nx>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>Request</span> <span class=p>=</span> <span class=nx>req</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>reset</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>engine</span><span class=p>.</span><span class=nf>handleHTTPRequest</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>engine</span><span class=p>.</span><span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>从 pool 中获取 Context 对象，用完后又还回去，注意 还回去之前这里也调用了 reset() 方法进行<strong>字段清空</strong>。</p><h3 id=正确姿势>正确姿势</h3><p>根据以上几个案例，可以看出正确使用姿势就是：</p><ul><li>1）设置 New 方法</li><li>2）使用时直接 Get</li><li>3）使用完成后先进行<strong>字段清空</strong>,然后在 Put 回去。</li></ul><blockquote><p>一定要进行 Reset，不然会出现意想不到的问题。分享一个<a href=https://github.com/lixd/daily-notes/blob/master/Golang/FAQ/mongodb%E9%87%87%E5%9D%91.md target=_blank rel="noopener noreffer">类似的坑</a></p></blockquote><h2 id=2-源码分析>2. 源码分析</h2><blockquote><p>一下分析基于 Go 1.17.1</p></blockquote><h3 id=pool-结构体>Pool 结构体</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Pool</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>noCopy</span> <span class=nx>noCopy</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>local</span>     <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// local fixed-size per-P pool, actual type is [P]poolLocal
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>localSize</span> <span class=kt>uintptr</span>        <span class=c1>// size of the local array
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>victim</span>     <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// local from previous cycle
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>victimSize</span> <span class=kt>uintptr</span>        <span class=c1>// size of victims array
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>New</span> <span class=kd>func</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>字段详解：</p><ul><li><p><code>noCopy</code>对象，实现了<code>sync.Locker</code>接口，使得内嵌了 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。</p><ul><li>具体见 <a href=https://github.com/golang/go/issues/8005 target=_blank rel="noopener noreffer">Go issues 8005</a></li><li>说明 Pool 对象也是不允许复制的。</li></ul></li><li><p><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针。<code>localSize</code> 则表示 local 数组的大小。</p><ul><li>访问时，根据 P 的 id 去访问对应下标的 <code>local[pid]</code></li><li>通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</li><li>有点类似于降低锁粒度，分段锁的思想。</li></ul></li><li><p><code>victim</code> 和 <code>victimSize</code> 则会在在一轮 GC 到来时，分别“接管” local 和 localSize。</p><ul><li>victim cache 是一种提高缓存性能的硬件技术;</li><li><code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑;</li><li><code>sync.Pool</code> 引入的意图在于降低 GC 压力的同时提高命中率。</li></ul></li><li><p><code>New</code>就是我们指定的新建对象的方法。</p></li></ul><blockquote><p><a href=https://en.wikipedia.org/wiki/Victim_cache target=_blank rel="noopener noreffer">Victim Cache</a> 是一种提高缓存性能的硬件技术，主要用于提升缓存命令率。</p><p>所谓受害者缓存（Victim Cache），是一个与直接匹配或低相联缓存并用的、容量很小的全相联缓存。当一个数据块被逐出缓存时，并不直接丢弃，而是暂先进入受害者缓存。如果受害者缓存已满，就替换掉其中一项。当进行缓存标签匹配时，在与索引指向标签匹配的同时，并行查看受害者缓存，如果在受害者缓存发现匹配，就将其此数据块与缓存中的不匹配数据块做交换，同时返回给处理器。</p></blockquote><h4 id=local>local</h4><p>local 具体结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>poolLocal</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>poolLocalInternal</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将 poolLocal 补齐至128字节(即两个cache line)的倍数，防止 false sharing,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>pad</span> <span class=p>[</span><span class=mi>128</span> <span class=o>-</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>poolLocalInternal</span><span class=p>{})</span><span class=o>%</span><span class=mi>128</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>poolLocalInternal</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>private</span> <span class=kd>interface</span><span class=p>{}</span> <span class=c1>// Can be used only by the respective P.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>shared</span>  <span class=nx>poolChain</span>   <span class=c1>// Local P can pushHead/popHead; any P can popTail.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>poolLocalInternal</code>对象 中包含一个 <code>private</code> 和 <code>shared</code>。其中 private 只有当前 p 能用，shared 则是其他 p 都可以用。</p><h4 id=cpu-cache--false-sharing>cpu cache & false sharing</h4><p><strong>cpu cache</strong></p><p>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。
程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。</p><p>这样，访问后续 63 字节数据时就可以直接从 cache line 中读取，性能有很大提升。</p><p><strong><a href=https://en.wikipedia.org/wiki/False_sharing target=_blank rel="noopener noreffer">false sharing</a></strong></p><blockquote><p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会令整个 cache line 失效，无意中影响彼此的性能，这就是伪共享。</p></blockquote><p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p><h4 id=poolchain>poolChain</h4><p><code>poolChain</code> 是一个双端队列的实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>poolChain</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>head</span> <span class=o>*</span><span class=nx>poolChainElt</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>tail</span> <span class=o>*</span><span class=nx>poolChainElt</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>poolChainElt</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>poolDequeue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>next</span><span class=p>,</span> <span class=nx>prev</span> <span class=o>*</span><span class=nx>poolChainElt</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>poolDequeue</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>headTail</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>vals</span> <span class=p>[]</span><span class=nx>eface</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。
<code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p><p>我们用一幅图来完整地描述 Pool 结构体：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png data-srcset="https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png, https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png 1.5x, https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png 2x" data-sizes=auto alt=https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png title=pool-structure></p><blockquote><p>图源：<a href=https://zhuanlan.zhihu.com/p/133638023 target=_blank rel="noopener noreffer">码农桃花源</a></p></blockquote><h3 id=大致流程>大致流程</h3><p>分析完 Pool 结构体之后，先提前说明一下大致的流程，后续分析时便于理解。</p><p><strong>存储</strong></p><p>为每个 P 开辟了一个 Local 用于数据，降低竞争。</p><p>Local 中包含 private 和 shared。</p><ul><li>private ：只有当前 P 能使用</li><li>shared：所有 P 共享，当 private 没有时优先去当前 P 的 local.shared 中取，如果还没有就去其他 P 中 local.shared 中窃取一个来用。</li></ul><p><strong>Get</strong></p><p>优先从当前P 的 local.private 中取，没有则从当前 P 的 local.shared 中取，还没有则去其他 P 中 local.shared 中窃取一个。</p><p><strong>Put</strong></p><p>优先存放到当前 P 的 local.private，local.private 已经有值了就往 shared 中放。</p><h3 id=get>Get</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Pool</span><span class=p>)</span> <span class=nf>Get</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>l</span><span class=p>,</span> <span class=nx>pid</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>pin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>x</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>private</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>private</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>x</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>shared</span><span class=p>.</span><span class=nf>popHead</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>x</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>getSlow</span><span class=p>(</span><span class=nx>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>runtime_procUnpin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>p</span><span class=p>.</span><span class=nx>New</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>x</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>流程如下：</p><ol><li>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</li><li>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</li><li>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</li><li>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</li><li>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除禁止抢占。</li><li>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</li></ol><h4 id=pin>pin</h4><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Pool</span><span class=p>)</span> <span class=nf>pin</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>poolLocal</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=c1>// pin 具体逻辑由 runtime_procPin 实现
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>pid</span> <span class=o>:=</span>  <span class=nf>runtime_procPin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=c1>// 原子操作取出 p.localSize 和 p.local
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>s</span> <span class=o>:=</span> <span class=nf>runtime_LoadAcquintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>localSize</span><span class=p>)</span> <span class=c1>// load-acquire
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>l</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>local</span>                              <span class=c1>// load-consume
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// 因为是把 pid 做下标从 pool.local 中取得 p 对应的 local 的，
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// 所以如果 pid 小于 pool.local size 的时候才有可能取到对应的 local
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>if</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>pid</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>indexLocal</span><span class=p>(</span><span class=nx>l</span><span class=p>,</span> <span class=nx>pid</span><span class=p>),</span> <span class=nx>pid</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=c1>// 正常情况下会一直满足该条件，
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// 只有刚开始  pool.local 还没创建或者动态调整了 P 的数量这两种情况
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// 会进入到下面的逻辑 去创建 pool.local
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nf>pinSlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=pinslow>pinSlow</h4><p>pinSlow 主要是完成 pool.local 的创建。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Pool</span><span class=p>)</span> <span class=nf>pinSlow</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>poolLocal</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这里先取消绑定，然后加锁，最后有绑定上
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>runtime_procUnpin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>allPoolsMu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>allPoolsMu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>pid</span> <span class=o>:=</span> <span class=nf>runtime_procPin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// doubleCheck 因为在执行上述命令过程中 pinSlow 可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>s</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>localSize</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>local</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>pid</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>indexLocal</span><span class=p>(</span><span class=nx>l</span><span class=p>,</span> <span class=nx>pid</span><span class=p>),</span> <span class=nx>pid</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>local</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>allPools</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>allPools</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 根据当前 P 的数量创建 pool.local并更新pool.localSize
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>size</span> <span class=o>:=</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>GOMAXPROCS</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>local</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>poolLocal</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>atomic</span><span class=p>.</span><span class=nf>StorePointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>local</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>local</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=c1>// store-release
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>runtime_StoreReluintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>localSize</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>size</span><span class=p>))</span>     <span class=c1>// store-release
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 最后根据 pid 返回当前 P 对应的 local
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>local</span><span class=p>[</span><span class=nx>pid</span><span class=p>],</span> <span class=nx>pid</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=pophead>popHead</h4><p>然后回到 Get 方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>private</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>private</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>x</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>shared</span><span class=p>.</span><span class=nf>popHead</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>x</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>getSlow</span><span class=p>(</span><span class=nx>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>优先从 local.private 中取，如果没有就调用<code>poolChain.popHead()</code>去 local.shared 中取一个。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>poolChain</span><span class=p>)</span> <span class=nf>popHead</span><span class=p>()</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>d</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>head</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>d</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>val</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>popHead</span><span class=p>();</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>val</span><span class=p>,</span> <span class=nx>ok</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>d</span> <span class=p>=</span> <span class=nf>loadPoolChainElt</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>prev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>popHead</code> 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 <code>poolDequeue.popHead</code> 方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>poolDequeue</span><span class=p>)</span> <span class=nf>popHead</span><span class=p>()</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>slot</span> <span class=o>*</span><span class=nx>eface</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ptrs</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>headTail</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>head</span><span class=p>,</span> <span class=nx>tail</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>ptrs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 收尾相连则说明队列是空的
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>tail</span> <span class=o>==</span> <span class=nx>head</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// head 位置是队头的前一个位置，所以此处要先退一位。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>head</span><span class=o>--</span>
</span></span><span class=line><span class=cl>		<span class=nx>ptrs2</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>pack</span><span class=p>(</span><span class=nx>head</span><span class=p>,</span> <span class=nx>tail</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 通过 CAS 操作更新头部的位置 这样当前头部第一个元素就算是被移除了
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>headTail</span><span class=p>,</span> <span class=nx>ptrs</span><span class=p>,</span> <span class=nx>ptrs2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>slot</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>head</span><span class=o>&amp;</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 类型转换与 nil 判断
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>val</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kd>interface</span><span class=p>{})(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>slot</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>val</span> <span class=o>==</span> <span class=nf>dequeueNil</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>val</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 然后把这个 slot 置空，因为现在这个 slot 已经是队列的 head 了，置空便于前一个 head 被回收。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>*</span><span class=nx>slot</span> <span class=p>=</span> <span class=nx>eface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>val</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p><p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p><p>首先调用 unpack 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 nil，false。</p><p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 pack 打包 head 和 tail 指针。使用 CAS 更新 headTail 的值，并且把 vals 相应索引处的元素赋值给 slot。</p><blockquote><p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 进行与运算，实际就是取 head 低 n 位的值作为下标。</p></blockquote><p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>dequeueNil</span> <span class=o>*</span><span class=kd>struct</span><span class=p>{}</span>
</span></span></code></pre></div><p>最后，返回 val 之前，将 slot “归零”，移除和上一个 head 的关联，便于回收上一个 Head。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>*</span><span class=nx>slot</span> <span class=p>=</span> <span class=nx>eface</span><span class=p>{}</span>
</span></span></code></pre></div><p>结束后回到 <code>poolChain.popHead()</code>，如果调用 <code>poolDequeue.popHead()</code> 拿到了缓存的对象，就直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p><h4 id=getslow>getSlow</h4><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Pool</span><span class=p>)</span> <span class=nf>getSlow</span><span class=p>(</span><span class=nx>pid</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nx>size</span> <span class=o>:=</span> <span class=nf>runtime_LoadAcquintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>localSize</span><span class=p>)</span> <span class=c1>// load-acquire
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>locals</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>local</span>                            <span class=c1>// load-consume
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 尝试从其他 p 中窃取一个对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>int</span><span class=p>(</span><span class=nx>size</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// (pid+i+1)%int(size) 保证每次都可以从 当前pid+1 这个位置开始尝试窃取。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>l</span> <span class=o>:=</span> <span class=nf>indexLocal</span><span class=p>(</span><span class=nx>locals</span><span class=p>,</span> <span class=p>(</span><span class=nx>pid</span><span class=o>+</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=nb>int</span><span class=p>(</span><span class=nx>size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果能取到就直接返回
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>shared</span><span class=p>.</span><span class=nf>popTail</span><span class=p>();</span> <span class=nx>x</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 尝试从其他 P 的 poolLocal 窃取失败后，再尝试从victim cache中取对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 这样可以使 victim 中的对象更容易被回收。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>size</span> <span class=p>=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadUintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>victimSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>pid</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>size</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>locals</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>victim</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span> <span class=o>:=</span> <span class=nf>indexLocal</span><span class=p>(</span><span class=nx>locals</span><span class=p>,</span> <span class=nx>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>x</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>private</span><span class=p>;</span> <span class=nx>x</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>.</span><span class=nx>private</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>int</span><span class=p>(</span><span class=nx>size</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span> <span class=o>:=</span> <span class=nf>indexLocal</span><span class=p>(</span><span class=nx>locals</span><span class=p>,</span> <span class=p>(</span><span class=nx>pid</span><span class=o>+</span><span class=nx>i</span><span class=p>)</span><span class=o>%</span><span class=nb>int</span><span class=p>(</span><span class=nx>size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>shared</span><span class=p>.</span><span class=nf>popTail</span><span class=p>();</span> <span class=nx>x</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 清空 victim cache。下次就不用再从这里找了
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>atomic</span><span class=p>.</span><span class=nf>StoreUintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>p</span><span class=p>.</span><span class=nx>victimSize</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p><p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p><p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p><h4 id=poptail>popTail</h4><p>最后，还剩一个 popTail 函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>poolChain</span><span class=p>)</span> <span class=nf>popTail</span><span class=p>()</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// tail 指针为空直接返回 这里的 tail 是一个双端队列
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>d</span> <span class=o>:=</span> <span class=nf>loadPoolChainElt</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>tail</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>d</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// It&#39;s important that we load the next pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// *before* popping the tail. In general, d may be
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// transiently empty, but if next is non-nil before
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// the pop and the pop fails, then d is permanently
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// empty, which is the only condition under which it&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// safe to drop d from the chain.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>d2</span> <span class=o>:=</span> <span class=nf>loadPoolChainElt</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>val</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>popTail</span><span class=p>();</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>val</span><span class=p>,</span> <span class=nx>ok</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>d2</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// This is the only dequeue. It&#39;s empty right
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// now, but could be pushed to in the future.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 同样的通过 CAS 来更新 tail 的值为 d2
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapPointer</span><span class=p>((</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>tail</span><span class=p>)),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>d</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>d2</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>storePoolChainElt</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d2</span><span class=p>.</span><span class=nx>prev</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 最后将d2赋值给d便于进行下一轮循环。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>d</span> <span class=p>=</span> <span class=nx>d2</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p><p>最后，将 c.tail 更新为 d2，可以防止下次 popTail 的时候查看一个空的 dequeue；而将 d2.prev 设置为 nil，可以防止下次 popHead 时查看一个空的 dequeue。</p><p>我们再看一下核心的 <code>poolDequeue.popTail</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>poolDequeue</span><span class=p>)</span> <span class=nf>popTail</span><span class=p>()</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>slot</span> <span class=o>*</span><span class=nx>eface</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ptrs</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>headTail</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>head</span><span class=p>,</span> <span class=nx>tail</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>ptrs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 同样的 head=tail 说明队列为空
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>tail</span> <span class=o>==</span> <span class=nx>head</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 同样是 CAS 更新 headTail 以移除 tail 元素
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>ptrs2</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>pack</span><span class=p>(</span><span class=nx>head</span><span class=p>,</span> <span class=nx>tail</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>headTail</span><span class=p>,</span> <span class=nx>ptrs</span><span class=p>,</span> <span class=nx>ptrs2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Success.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>slot</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>tail</span><span class=o>&amp;</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 类型转换和 nil 判断
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>val</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kd>interface</span><span class=p>{})(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>slot</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>val</span> <span class=o>==</span> <span class=nf>dequeueNil</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>val</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 最后也是将这个 slot 置空
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>slot</span><span class=p>.</span><span class=nx>val</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>atomic</span><span class=p>.</span><span class=nf>StorePointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>slot</span><span class=p>.</span><span class=nx>typ</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>val</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>整体逻辑和 popHead 差不多。</p><h4 id=小结>小结</h4><p>首先从 当前 p 对应的 local.private 上取，没有就从 local.shared 里取，还没有就去其他 p 的 local.shared 里取，都没有就 new 一个返回。</p><h3 id=put>Put</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Pool</span><span class=p>)</span> <span class=nf>Put</span><span class=p>(</span><span class=nx>x</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>l</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>pin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>l</span><span class=p>.</span><span class=nx>private</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>.</span><span class=nx>private</span> <span class=p>=</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>		<span class=nx>x</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>x</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>.</span><span class=nx>shared</span><span class=p>.</span><span class=nf>pushHead</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>runtime_procUnpin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>流程也比较简单：</p><ol><li>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</li><li>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。</li></ol><h4 id=pushhead>pushHead</h4><p>p.pin() 和之前是一样的，就不分析了，主要看一下 pushHead()</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>poolChain</span><span class=p>)</span> <span class=nf>pushHead</span><span class=p>(</span><span class=nx>val</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>d</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>head</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>d</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 第一次写入，队列为空则进行初始化 默认长度为8
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kd>const</span> <span class=nx>initSize</span> <span class=p>=</span> <span class=mi>8</span> <span class=c1>// Must be a power of 2
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>d</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>poolChainElt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>d</span><span class=p>.</span><span class=nx>vals</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>eface</span><span class=p>,</span> <span class=nx>initSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>head</span> <span class=p>=</span> <span class=nx>d</span>
</span></span><span class=line><span class=cl>		<span class=nf>storePoolChainElt</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>tail</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 存储元素 存储成功直接返回
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>d</span><span class=p>.</span><span class=nf>pushHead</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// The current dequeue is full. Allocate a new one of twice
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// the size.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 存储失败说明队列满了 进行扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>newSize</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>newSize</span> <span class=o>&gt;=</span> <span class=nx>dequeueLimit</span> <span class=p>{</span> <span class=c1>// 限制一下，不能无限扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>newSize</span> <span class=p>=</span> <span class=nx>dequeueLimit</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 扩容逻辑也比较简单，就是首尾相连，构成链表
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>d2</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>poolChainElt</span><span class=p>{</span><span class=nx>prev</span><span class=p>:</span> <span class=nx>d</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>d2</span><span class=p>.</span><span class=nx>vals</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>eface</span><span class=p>,</span> <span class=nx>newSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>head</span> <span class=p>=</span> <span class=nx>d2</span>
</span></span><span class=line><span class=cl>	<span class=nf>storePoolChainElt</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>next</span><span class=p>,</span> <span class=nx>d2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>d2</span><span class=p>.</span><span class=nf>pushHead</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>dequeueBits</span> <span class=p>=</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=nx>dequeueLimit</span> <span class=p>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>dequeueBits</span><span class=p>)</span> <span class=o>/</span> <span class=mi>4</span>
</span></span></code></pre></div><p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>poolDequeue</span><span class=p>)</span> <span class=nf>pushHead</span><span class=p>(</span><span class=nx>val</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ptrs</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>headTail</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>head</span><span class=p>,</span> <span class=nx>tail</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>ptrs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 首先判断队列是否已满： 也就是将尾部指针加上 d.vals 的长度，再取低 31 位，看它是否和 head 相等
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=nx>tail</span><span class=o>+</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>)))</span><span class=o>&amp;</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>dequeueBits</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=nx>head</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>slot</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>head</span><span class=o>&amp;</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Check if the head slot has been released by popTail.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>typ</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>slot</span><span class=p>.</span><span class=nx>typ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>typ</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Another goroutine is still cleaning up the tail, so
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// the queue is actually still full.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// slot占位，将val存入vals中
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>val</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>val</span> <span class=p>=</span> <span class=nf>dequeueNil</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kd>interface</span><span class=p>{})(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>slot</span><span class=p>))</span> <span class=p>=</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// head 增加 1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>atomic</span><span class=p>.</span><span class=nf>AddUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>headTail</span><span class=p>,</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>dequeueBits</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>首先判断队列是否已满：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nx>tail</span><span class=o>+</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>)))</span><span class=o>&amp;</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>dequeueBits</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=nx>head</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>slot</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>[</span><span class=nx>head</span><span class=o>&amp;</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>vals</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Check if the head slot has been released by popTail.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>typ</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>slot</span><span class=p>.</span><span class=nx>typ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>typ</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Another goroutine is still cleaning up the tail, so
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// the queue is actually still full.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>这里还判断了当前 slot 是否正在被 popTail 释放，popTail 相关语句如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// 最后也是将这个 slot 置空
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>slot</span><span class=p>.</span><span class=nx>val</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=nx>atomic</span><span class=p>.</span><span class=nf>StorePointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>slot</span><span class=p>.</span><span class=nx>typ</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span></code></pre></div><p>所以如果 slot.typ==nil 就说明这个 slot 正在被 popTail 释放，说明队列其实还是满的，直接返回 false，走后续的扩容逻辑。</p><p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// slot占位，将val存入vals中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kd>interface</span><span class=p>{})(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>slot</span><span class=p>))</span> <span class=p>=</span> <span class=nx>val</span>
</span></span></code></pre></div><blockquote><p>这里的实现比较巧妙，slot 是 eface 类型，即空接口，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p></blockquote><h4 id=packunpack>pack/unpack</h4><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>poolDequeue</span><span class=p>)</span> <span class=nf>pack</span><span class=p>(</span><span class=nx>head</span><span class=p>,</span> <span class=nx>tail</span> <span class=kt>uint32</span><span class=p>)</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>const</span> <span class=nx>mask</span> <span class=p>=</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>dequeueBits</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=nb>uint64</span><span class=p>(</span><span class=nx>head</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=nx>dequeueBits</span><span class=p>)</span> <span class=p>|</span>
</span></span><span class=line><span class=cl>		<span class=nb>uint64</span><span class=p>(</span><span class=nx>tail</span><span class=o>&amp;</span><span class=nx>mask</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>mask</code> 的低 31 位为全 1，其他位为 0，它和 tail 相与，就是只看 tail 的低 31 位。而 head 向左移 32 位之后，低 32 位为全 0。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>poolDequeue</span><span class=p>)</span> <span class=nf>unpack</span><span class=p>(</span><span class=nx>ptrs</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>(</span><span class=nx>head</span><span class=p>,</span> <span class=nx>tail</span> <span class=kt>uint32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>const</span> <span class=nx>mask</span> <span class=p>=</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>dequeueBits</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>head</span> <span class=p>=</span> <span class=nb>uint32</span><span class=p>((</span><span class=nx>ptrs</span> <span class=o>&gt;&gt;</span> <span class=nx>dequeueBits</span><span class=p>)</span> <span class=o>&amp;</span> <span class=nx>mask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>tail</span> <span class=p>=</span> <span class=nb>uint32</span><span class=p>(</span><span class=nx>ptrs</span> <span class=o>&amp;</span> <span class=nx>mask</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>unpack 则是相反的逻辑，取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p><h4 id=小结-1>小结</h4><p>Put 和 Get 类似，首先尝试将放到当前 p 的 local.private 上，已经有了就放到 local.shared。</p><h3 id=gc>GC</h3><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。</p><p>sync.pool 选择了在 GC 时进行清理。</p><p>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// sync/pool.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>runtime_registerPoolCleanup</span><span class=p>(</span><span class=nx>poolCleanup</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>编译器在编译时将其注册到运行时：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// src/runtime/mgc.go
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>// Hooks for other packages
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>poolcleanup</span> <span class=kd>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>// 利用编译器标志将 sync 包中的清理注册到运行时
</span></span></span><span class=line><span class=cl><span class=c1>//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>sync_runtime_registerPoolCleanup</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>poolcleanup</span> <span class=p>=</span> <span class=nx>f</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>具体的 poolCleanup() 函数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>poolCleanup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>oldPools</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>victim</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>victimSize</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>p</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>allPools</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>victim</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>local</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>victimSize</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>localSize</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>local</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>localSize</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>oldPools</span><span class=p>,</span> <span class=nx>allPools</span> <span class=p>=</span> <span class=nx>allPools</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p><ol><li>初始状态下，oldPools 和 allPools 均为 nil。</li><li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li><li>对象使用完毕，第 1 次调用 Put 放回对象。</li><li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li><li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li><li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li><li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。</li></ol><p>简单来说就是清理时，先清理 oldPools 的 local.victim,然后把 allPools 中的 local 赋值给 victim，最后再把 allPools 赋值给 oldPools，把 allPools 置空。</p><blockquote><p>GC 时只会清理 oldPools，allPools 只会先把数据转移到 victim，然后把 allPools 变成 oldPools，如果从 oldPools 中读取出来的数据进行 Put 也会直接放到 allPools 中，相当于要两次 GC 都没有被访问到并且Put回来才会被移除。</p></blockquote><h2 id=3-小结>3. 小结</h2><ul><li>1）关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</li><li>2）<code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</li><li>3）不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</li><li>4）Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</li></ul><p>一些设计思想或者相关知识点：</p><ul><li><p>lock free：无锁编程是很多编程语言里逃离不了的话题。<code>sync.Pool</code>的无锁是在<code>poolDequeue</code>和<code>poolChain</code>层面实现的。</p></li><li><p>原子操作代替锁：<code>poolDequeue</code>对一些关键变量采用了CAS操作，比如<code>poolDequeue.headTail</code>，既可完整保证并发又能降低相比锁而言的开销。</p></li><li><p>cacheline false sharing 问题</p></li><li><p>noCopy 禁止复制</p></li><li><p>分段锁，降低锁粒度</p></li><li><p>victim cache</p></li><li><p>常见优化手段：复用</p></li></ul><h2 id=4-参考>4. 参考</h2><p><code>https://golang.org/src/sync/pool.go</code></p><p><code>https://en.wikipedia.org/wiki/False_sharing</code></p><p><code>https://en.wikipedia.org/wiki/Victim_cache</code></p><p><code>https://zhuanlan.zhihu.com/p/110140126</code></p><p><code>https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72</code></p><p><code>https://zhuanlan.zhihu.com/p/133638023</code></p><p><code>https://www.jianshu.com/p/dc4b5562aad2</code></p><p><code>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-10-15</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/go/sync-pool/ data-title="Go语言之 sync.pool 源码分析" data-hashtags=Golang><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/go/sync-pool/ data-hashtag=Golang><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/go/sync-pool/ data-title="Go语言之 sync.pool 源码分析"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/go/sync-pool/ data-title="Go语言之 sync.pool 源码分析"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/go/sync-pool/ data-title="Go语言之 sync.pool 源码分析"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/golang/>Golang</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/kafka/12-hw-leader-epoch/ class=prev rel=prev title="Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制</a>
<a href=/posts/go/context/ class=next rel=next title="Go语言之 Context 实战与源码分析">Go语言之 Context 实战与源码分析<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/lixd target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>