<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Kafka(Go)教程(六)---sarama 客户端 producer 源码分析 -</title><meta name=Description content="Kafka Go sarama 客户端异步生产者源码分析"><meta property="og:title" content="Kafka(Go)教程(六)---sarama 客户端 producer 源码分析"><meta property="og:description" content="Kafka Go sarama 客户端异步生产者源码分析"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/kafka/06-sarama-producer/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-14T22:00:00+00:00"><meta property="article:modified_time" content="2021-08-14T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Kafka(Go)教程(六)---sarama 客户端 producer 源码分析"><meta name=twitter:description content="Kafka Go sarama 客户端异步生产者源码分析"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/kafka/06-sarama-producer/><link rel=prev href=https://blog.yudlk.com/posts/kafka/05-quick-start/><link rel=next href=https://blog.yudlk.com/posts/kafka/07-partition/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Kafka(Go)教程(六)---sarama 客户端 producer 源码分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/kafka\/06-sarama-producer\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Kafka","wordcount":5097,"url":"https:\/\/blog.yudlk.com\/posts\/kafka\/06-sarama-producer\/","datePublished":"2021-08-14T22:00:00+00:00","dateModified":"2021-08-14T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Kafka Go sarama 客户端异步生产者源码分析"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Kafka(Go)教程(六)---sarama 客户端 producer 源码分析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/kafka/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kafka</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-08-14>2021-08-14</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;5097 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;11 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-概述>1. 概述</a></li><li><a href=#2-发送流程源码分析>2. 发送流程源码分析</a><ul><li><a href=#newasyncproducer>NewAsyncProducer</a></li><li><a href=#dispatcher>dispatcher</a></li><li><a href=#topicdispatch>topicDispatch</a></li><li><a href=#partitiondispatch>PartitionDispatch</a></li><li><a href=#partitionproducer>PartitionProducer</a></li><li><a href=#brokerproducer>BrokerProducer</a></li></ul></li><li><a href=#3-消息打包源码分析>3. 消息打包源码分析</a><ul><li><a href=#run>run</a></li><li><a href=#wouldoverflow>wouldOverflow</a></li><li><a href=#add>add</a></li><li><a href=#定时发送>定时发送</a></li></ul></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要通过源码分析了 Kafka Go sarama 客户端生产者的实现原理，包括消息分发流程，消息打包处理，以及最终发送到 Kafka 等具体步骤，最后通过分析总结出的常见性能优化手段。</p><blockquote><p>本文基于 sarama v1.29.1</p></blockquote><h2 id=1-概述>1. 概述</h2><blockquote><p>Kafka 系列相关代码见 <a href=https://github.com/barrypt/kafka-go-example target=_blank rel="noopener noreffer">Github</a></p></blockquote><p>具体流程如下图：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/Sarama%20Producer%20%E6%B5%81%E7%A8%8B.png data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/Sarama%20Producer%20%E6%B5%81%E7%A8%8B.png, https://github.com/barrypt/blog/raw/master/images/kafka/Sarama%20Producer%20%E6%B5%81%E7%A8%8B.png 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/Sarama%20Producer%20%E6%B5%81%E7%A8%8B.png 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/Sarama%20Producer%20%E6%B5%81%E7%A8%8B.png title="Sarama Producer 流程.png"></p><p><code>Sarama</code>有两种类型的生产者，同步生产者和异步生产者。</p><blockquote><p>To produce messages, use either the AsyncProducer or the SyncProducer. The AsyncProducer accepts messages on a channel and produces them asynchronously in the background as efficiently as possible; it is preferred in most cases. The SyncProducer provides a method which will block until Kafka acknowledges the message as produced. This can be useful but comes with two caveats: it will generally be less efficient, and the actual durability guarantees depend on the configured value of <code>Producer.RequiredAcks</code>. There are configurations where a message acknowledged by the SyncProducer can still sometimes be lost.</p></blockquote><p>大致意思是异步生产者使用<code>channel</code>接收（生产成功或失败）的消息，并且也通过<code>channel</code>来发送消息，这样做通常是性能最高的。而同步生产者需要阻塞，直到收到了<code>acks</code>。但是这也带来了两个问题，一是性能变得更差了，而是可靠性是依靠参数<code>acks</code>来保证的。</p><p>异步生产者 Demo 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Producer</span><span class=p>(</span><span class=nx>topic</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>limit</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>config</span> <span class=o>:=</span> <span class=nx>sarama</span><span class=p>.</span><span class=nf>NewConfig</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 异步生产者不建议把 Errors 和 Successes 都开启，一般开启 Errors 就行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 同步生产者就必须都开启，因为会同步返回发送成功或者失败
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>config</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Return</span><span class=p>.</span><span class=nx>Errors</span> <span class=p>=</span> <span class=kc>true</span>    <span class=c1>// 设定是否需要返回错误信息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>config</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Return</span><span class=p>.</span><span class=nx>Successes</span> <span class=p>=</span> <span class=kc>true</span> <span class=c1>// 设定是否需要返回成功信息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>producer</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>sarama</span><span class=p>.</span><span class=nf>NewAsyncProducer</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=nx>conf</span><span class=p>.</span><span class=nx>HOST</span><span class=p>},</span> <span class=nx>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;NewSyncProducer err:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span>                                   <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>		<span class=nx>enqueued</span><span class=p>,</span> <span class=nx>timeout</span><span class=p>,</span> <span class=nx>successes</span><span class=p>,</span> <span class=nx>errors</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// [!important] 异步生产者发送后必须把返回值从 Errors 或者 Successes 中读出来 不然会阻塞 sarama 内部处理逻辑 导致只能发出去一条消息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=k>range</span> <span class=nx>producer</span><span class=p>.</span><span class=nf>Successes</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// log.Printf(&#34;[Producer] Success: key:%v msg:%+v \n&#34;, s.Key, s.Value)
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>successes</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>e</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>producer</span><span class=p>.</span><span class=nf>Errors</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[Producer] Errors：err:%v msg:%+v \n&#34;</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nx>Msg</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nx>Err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>errors</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 异步发送
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>limit</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>str</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Itoa</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>		<span class=nx>msg</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sarama</span><span class=p>.</span><span class=nx>ProducerMessage</span><span class=p>{</span><span class=nx>Topic</span><span class=p>:</span> <span class=nx>topic</span><span class=p>,</span> <span class=nx>Key</span><span class=p>:</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>Value</span><span class=p>:</span> <span class=nx>sarama</span><span class=p>.</span><span class=nf>StringEncoder</span><span class=p>(</span><span class=nx>str</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 异步发送只是写入内存了就返回了，并没有真正发送出去
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// sarama 库中用的是一个 channel 来接收，后台 goroutine 异步从该 channel 中取出消息并真正发送
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// select + ctx 做超时控制,防止阻塞 producer.Input() &lt;- msg 也可能会阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=o>*</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>producer</span><span class=p>.</span><span class=nf>Input</span><span class=p>()</span> <span class=o>&lt;-</span> <span class=nx>msg</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>enqueued</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>			<span class=nx>timeout</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span><span class=o>%</span><span class=mi>10000</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>i</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;已发送消息数:%d 超时数:%d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// We are done
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>producer</span><span class=p>.</span><span class=nf>AsyncClose</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;发送完毕 总发送条数:%d enqueued:%d timeout:%d successes: %d errors: %d\n&#34;</span><span class=p>,</span> <span class=nx>limit</span><span class=p>,</span> <span class=nx>enqueued</span><span class=p>,</span> <span class=nx>timeout</span><span class=p>,</span> <span class=nx>successes</span><span class=p>,</span> <span class=nx>errors</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到整个 API 使用起来还是非常简单的：</p><ul><li>1）NewAsyncProducer() ：创建 一个 producer 对象</li><li>2）producer.Input() &lt;- msg ：发送消息</li><li>3）s = &lt;-producer.Successes()，e := &lt;-producer.Errors() ：异步获取成功或失败信息</li></ul><h2 id=2-发送流程源码分析>2. 发送流程源码分析</h2><blockquote><p>为了便于阅读，省略了部分无关代码。</p></blockquote><p>另外：由于同步生产者和异步生产者逻辑是一致的，只是在异步生产者基础上封装了一层，所以本文主要分析了异步生产者。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 可以看到 同步生产者其实就是把异步生产者封装了一层
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>syncProducer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>producer</span> <span class=o>*</span><span class=nx>asyncProducer</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span>       <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=newasyncproducer>NewAsyncProducer</h3><p>首先是构建一个异步生产者对象</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewAsyncProducer</span><span class=p>(</span><span class=nx>addrs</span> <span class=p>[]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>conf</span> <span class=o>*</span><span class=nx>Config</span><span class=p>)</span> <span class=p>(</span><span class=nx>AsyncProducer</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>client</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>NewClient</span><span class=p>(</span><span class=nx>addrs</span><span class=p>,</span> <span class=nx>conf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>newAsyncProducer</span><span class=p>(</span><span class=nx>client</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>newAsyncProducer</span><span class=p>(</span><span class=nx>client</span> <span class=nx>Client</span><span class=p>)</span> <span class=p>(</span><span class=nx>AsyncProducer</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>p</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>asyncProducer</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>client</span><span class=p>:</span>     <span class=nx>client</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>conf</span><span class=p>:</span>       <span class=nx>client</span><span class=p>.</span><span class=nf>Config</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>		<span class=nx>errors</span><span class=p>:</span>     <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>ProducerError</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>input</span><span class=p>:</span>      <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>successes</span><span class=p>:</span>  <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>retries</span><span class=p>:</span>    <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>brokers</span><span class=p>:</span>    <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=o>*</span><span class=nx>Broker</span><span class=p>]</span><span class=o>*</span><span class=nx>brokerProducer</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>brokerRefs</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=o>*</span><span class=nx>brokerProducer</span><span class=p>]</span><span class=kt>int</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>txnmgr</span><span class=p>:</span>     <span class=nx>txnmgr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>withRecover</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>dispatcher</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>withRecover</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>retryHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到在 <code>newAsyncProducer</code> 最后开启了两个 goroutine，一个为 <code>dispatcher</code>，一个为 <code>retryHandler </code>。</p><blockquote><p>retryHandler 主要是处理重试逻辑，暂时先忽略。</p></blockquote><h3 id=dispatcher>dispatcher</h3><p>主要根据 <code>topic</code> 将消息分发到对应的 channel。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>asyncProducer</span><span class=p>)</span> <span class=nf>dispatcher</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>handlers</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>chan</span><span class=o>&lt;-</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>for</span> <span class=nx>msg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>p</span><span class=p>.</span><span class=nx>input</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>	  <span class=c1>// 拦截器逻辑
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>interceptor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>p</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Interceptors</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>msg</span><span class=p>.</span><span class=nf>safelyApplyInterceptor</span><span class=p>(</span><span class=nx>interceptor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>	  <span class=c1>// 找到这个Topic对应的Handler
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>handler</span> <span class=o>:=</span> <span class=nx>handlers</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>handler</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=c1>// 如果没有这个Topic对应的Handler，那么创建一个
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=nx>handler</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>newTopicProducer</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=nx>handlers</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>]</span> <span class=p>=</span> <span class=nx>handler</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>	  <span class=c1>// 然后把这条消息写进这个Handler中
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>handler</span> <span class=o>&lt;-</span> <span class=nx>msg</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>具体逻辑：从 <code>p.input</code> 中取出消息并写入到 <code>handler</code> 中，如果 <code>topic</code> 对应的 <code>handler</code> 不存在，则调用 <code>newTopicProducer()</code> 创建。</p><blockquote><p>这里的 handler 是一个 buffered channel</p></blockquote><p>然后让我们来看下<code>handler = p.newTopicProducer(msg.Topic)</code>这一行的代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>asyncProducer</span><span class=p>)</span> <span class=nf>newTopicProducer</span><span class=p>(</span><span class=nx>topic</span> <span class=kt>string</span><span class=p>)</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=o>*</span><span class=nx>ProducerMessage</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>input</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>ChannelBufferSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nx>tp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>topicProducer</span><span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>parent</span><span class=p>:</span>      <span class=nx>p</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>topic</span><span class=p>:</span>       <span class=nx>topic</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>input</span><span class=p>:</span>       <span class=nx>input</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>breaker</span><span class=p>:</span>     <span class=nx>breaker</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>handlers</span><span class=p>:</span>    <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int32</span><span class=p>]</span><span class=kd>chan</span><span class=o>&lt;-</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=nx>partitioner</span><span class=p>:</span> <span class=nx>p</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nf>Partitioner</span><span class=p>(</span><span class=nx>topic</span><span class=p>),</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>go</span> <span class=nf>withRecover</span><span class=p>(</span><span class=nx>tp</span><span class=p>.</span><span class=nx>dispatch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>input</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这里创建了一个缓冲大小为<code>ChannelBufferSize</code>的channel，用于存放发送到这个主题的消息，然后创建了一个 <code>topicProducer</code>。</p><blockquote><p>在这个时候你可以认为消息已经交付给各个 topic 对应的 topicProducer 了。</p></blockquote><p>还有一个需要注意的是<code>newTopicProducer</code> 的这种写法，内部创建一个 chan 返回到外层，然后通过在内部新开一个 goroutine 来处理该 chan 里的消息，这种写法在后面还会遇到好几次。</p><blockquote><p>相比之下在外部显示创建 chan 之后传递到该函数可能会更容易理解。</p></blockquote><h3 id=topicdispatch>topicDispatch</h3><p><code>newTopicProducer</code>的最后一行<code>go withRecover(tp.dispatch)</code>又启动了一个 goroutine 用于处理消息。也就是说，到了这一步，对于每一个Topic，都有一个协程来处理消息。</p><p>dispatch 具体如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>tp</span> <span class=o>*</span><span class=nx>topicProducer</span><span class=p>)</span> <span class=nf>dispatch</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>msg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>input</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>handler</span> <span class=o>:=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>handlers</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>handler</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>handler</span> <span class=p>=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>newPartitionProducer</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>,</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>tp</span><span class=p>.</span><span class=nx>handlers</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span><span class=p>]</span> <span class=p>=</span> <span class=nx>handler</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>handler</span> <span class=o>&lt;-</span> <span class=nx>msg</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到又是同样的套路：</p><ul><li>1）找到这条消息所在的分区对应的 channel，然后把消息丢进去</li><li>2）如果不存在则新建 chan</li></ul><h3 id=partitiondispatch>PartitionDispatch</h3><p>新建的 chan 是通过 <code>newPartitionProducer</code> 返回的，和之前的<code>newTopicProducer</code>又是同样的套路,点进去看一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>asyncProducer</span><span class=p>)</span> <span class=nf>newPartitionProducer</span><span class=p>(</span><span class=nx>topic</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>partition</span> <span class=kt>int32</span><span class=p>)</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=o>*</span><span class=nx>ProducerMessage</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>input</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>ChannelBufferSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>pp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>partitionProducer</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>parent</span><span class=p>:</span>    <span class=nx>p</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>topic</span><span class=p>:</span>     <span class=nx>topic</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>partition</span><span class=p>:</span> <span class=nx>partition</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>input</span><span class=p>:</span>     <span class=nx>input</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>breaker</span><span class=p>:</span>    <span class=nx>breaker</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>retryState</span><span class=p>:</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>partitionRetryState</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Retry</span><span class=p>.</span><span class=nx>Max</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>withRecover</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>dispatch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>input</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>果然是这样，有没有一种似曾相识的感觉。</p></blockquote><p><code>TopicProducer</code>是按照 <code>Topic</code> 进行分发，这里的 <code>PartitionProducer</code> 则是按照 <code>partition</code> 进行分发。</p><blockquote><p>到这里可以认为消息已经交付给对应 topic 下的对应 partition 了。</p></blockquote><p>每个 partition 都会有一个 goroutine 来处理分发给自己的消息。</p><h3 id=partitionproducer>PartitionProducer</h3><p>到了这一步，我们再来看看消息到了每个 partition 所在的 channel 之后，是如何处理的。</p><blockquote><p>其实在这一步中，主要是做一些错误处理之类的，然后把消息丢进brokerProducer。</p></blockquote><p>可以理解为这一步是业务逻辑层到网络IO层的转变，在这之前我们只关心消息去到了哪个分区，而在这之后，我们需要找到这个分区所在的 broker 的地址，并使用之前已经建立好的 TCP 连接，发送这条消息。</p><p>具体 <code>pp.dispatch</code> 代码如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>pp</span> <span class=o>*</span><span class=nx>partitionProducer</span><span class=p>)</span> <span class=nf>dispatch</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 找到这个主题和分区的leader所在的broker
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>pp</span><span class=p>.</span><span class=nx>leader</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Leader</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>topic</span><span class=p>,</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>partition</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>leader</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 根据 leader 信息创建一个 BrokerProducer 对象
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>pp</span><span class=p>.</span><span class=nx>brokerProducer</span> <span class=p>=</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>getBrokerProducer</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>leader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>inFlight</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>brokerProducer</span><span class=p>.</span><span class=nx>input</span> <span class=o>&lt;-</span> <span class=o>&amp;</span><span class=nx>ProducerMessage</span><span class=p>{</span><span class=nx>Topic</span><span class=p>:</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>topic</span><span class=p>,</span> <span class=nx>Partition</span><span class=p>:</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>partition</span><span class=p>,</span> <span class=nx>flags</span><span class=p>:</span> <span class=nx>syn</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 然后把消息丢进brokerProducer中
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>msg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>input</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>pp</span><span class=p>.</span><span class=nx>brokerProducer</span><span class=p>.</span><span class=nx>input</span> <span class=o>&lt;-</span> <span class=nx>msg</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>根据之前的套路我们知道，真正的逻辑肯定在<code>pp.parent.getBrokerProducer(pp.leader)</code> 这个方法里面。</p></blockquote><h3 id=brokerproducer>BrokerProducer</h3><p>到了这里，大概算是整个发送流程最后的一个步骤了。</p><p>让我们继续跟进<code>pp.parent.getBrokerProducer(pp.leader)</code>这行代码里面的内容。其实就是找到<code>asyncProducer</code>中的<code>brokerProducer</code>，如果不存在，则创建一个。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>asyncProducer</span><span class=p>)</span> <span class=nf>getBrokerProducer</span><span class=p>(</span><span class=nx>broker</span> <span class=o>*</span><span class=nx>Broker</span><span class=p>)</span> <span class=o>*</span><span class=nx>brokerProducer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>brokerLock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>p</span><span class=p>.</span><span class=nx>brokerLock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>bp</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>brokers</span><span class=p>[</span><span class=nx>broker</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>bp</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>bp</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>newBrokerProducer</span><span class=p>(</span><span class=nx>broker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>brokers</span><span class=p>[</span><span class=nx>broker</span><span class=p>]</span> <span class=p>=</span> <span class=nx>bp</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>brokerRefs</span><span class=p>[</span><span class=nx>bp</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>brokerRefs</span><span class=p>[</span><span class=nx>bp</span><span class=p>]</span><span class=o>++</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>bp</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>又调用了<code>newBrokerProducer()</code>，继续追踪下去：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>asyncProducer</span><span class=p>)</span> <span class=nf>newBrokerProducer</span><span class=p>(</span><span class=nx>broker</span> <span class=o>*</span><span class=nx>Broker</span><span class=p>)</span> <span class=o>*</span><span class=nx>brokerProducer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>input</span>     <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>bridge</span>    <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>produceSet</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>responses</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>brokerProducerResponse</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>bp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>brokerProducer</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>parent</span><span class=p>:</span>         <span class=nx>p</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>broker</span><span class=p>:</span>         <span class=nx>broker</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>input</span><span class=p>:</span>          <span class=nx>input</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>output</span><span class=p>:</span>         <span class=nx>bridge</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>responses</span><span class=p>:</span>      <span class=nx>responses</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>stopchan</span><span class=p>:</span>       <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}),</span>
</span></span><span class=line><span class=cl>		<span class=nx>buffer</span><span class=p>:</span>         <span class=nf>newProduceSet</span><span class=p>(</span><span class=nx>p</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>currentRetries</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>int32</span><span class=p>]</span><span class=kt>error</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>withRecover</span><span class=p>(</span><span class=nx>bp</span><span class=p>.</span><span class=nx>run</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// minimal bridge to make the network response `select`able
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>go</span> <span class=nf>withRecover</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>set</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>bridge</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>request</span> <span class=o>:=</span> <span class=nx>set</span><span class=p>.</span><span class=nf>buildRequest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>response</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>broker</span><span class=p>.</span><span class=nf>Produce</span><span class=p>(</span><span class=nx>request</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>responses</span> <span class=o>&lt;-</span> <span class=o>&amp;</span><span class=nx>brokerProducerResponse</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>set</span><span class=p>:</span> <span class=nx>set</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>err</span><span class=p>:</span> <span class=nx>err</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>res</span><span class=p>:</span> <span class=nx>response</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>responses</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Retry</span><span class=p>.</span><span class=nx>Max</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>bp</span><span class=p>.</span><span class=nx>abandoned</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>bp</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里又启动了两个 goroutine，一个为 run，一个是匿名函数姑且称为 bridge。</p><blockquote><p>bridge 看起来是真正的发送逻辑，那么 batch handle 逻辑应该是在 run 方法里了。</p></blockquote><p>这里先分析 bridge 函数，run 在下一章分析。</p><h4 id=buildrequest>buildRequest</h4><p>buildRequest 方法主要是构建一个标准的 Kafka Request 消息。</p><blockquote><p>根据不同版本、是否配置压缩信息做了额外处理，这里先忽略，只看核心代码：</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ps</span> <span class=o>*</span><span class=nx>produceSet</span><span class=p>)</span> <span class=nf>buildRequest</span><span class=p>()</span> <span class=o>*</span><span class=nx>ProduceRequest</span> <span class=p>{</span>	
</span></span><span class=line><span class=cl>	<span class=nx>req</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>ProduceRequest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>RequiredAcks</span><span class=p>:</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>RequiredAcks</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Timeout</span><span class=p>:</span>      <span class=nb>int32</span><span class=p>(</span><span class=nx>ps</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Timeout</span> <span class=o>/</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>topic</span><span class=p>,</span> <span class=nx>partitionSets</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>msgs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>partition</span><span class=p>,</span> <span class=nx>set</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>partitionSets</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>rb</span> <span class=o>:=</span> <span class=nx>set</span><span class=p>.</span><span class=nx>recordsToSend</span><span class=p>.</span><span class=nx>RecordBatch</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>rb</span><span class=p>.</span><span class=nx>Records</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>rb</span><span class=p>.</span><span class=nx>LastOffsetDelta</span> <span class=p>=</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>rb</span><span class=p>.</span><span class=nx>Records</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>record</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rb</span><span class=p>.</span><span class=nx>Records</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nx>record</span><span class=p>.</span><span class=nx>OffsetDelta</span> <span class=p>=</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>req</span><span class=p>.</span><span class=nf>AddBatch</span><span class=p>(</span><span class=nx>topic</span><span class=p>,</span> <span class=nx>partition</span><span class=p>,</span> <span class=nx>rb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>首先是构建一个 req 对象，然后遍历 ps.msg 中的消息，根据 topic 和 partition 分别写入到 req 中。</p><h4 id=produce>Produce</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Broker</span><span class=p>)</span> <span class=nf>Produce</span><span class=p>(</span><span class=nx>request</span> <span class=o>*</span><span class=nx>ProduceRequest</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>ProduceResponse</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>response</span> <span class=o>*</span><span class=nx>ProduceResponse</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span>      <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>request</span><span class=p>.</span><span class=nx>RequiredAcks</span> <span class=o>==</span> <span class=nx>NoResponse</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>sendAndReceive</span><span class=p>(</span><span class=nx>request</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>response</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>ProduceResponse</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>sendAndReceive</span><span class=p>(</span><span class=nx>request</span><span class=p>,</span> <span class=nx>response</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>response</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最终调用了<code>sendAndReceive()</code>方法将消息发送出去。</p><p>如果我们设置了需要 Acks，就会传一个 response 进去接收返回值；如果没设置，那么消息发出去之后，就不管了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Broker</span><span class=p>)</span> <span class=nf>sendAndReceive</span><span class=p>(</span><span class=nx>req</span> <span class=nx>protocolBody</span><span class=p>,</span> <span class=nx>res</span> <span class=nx>protocolBody</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=nx>promise</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>send</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>responseHeaderVersion</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>buf</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>promise</span><span class=p>.</span><span class=nx>packets</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>versionedDecode</span><span class=p>(</span><span class=nx>buf</span><span class=p>,</span> <span class=nx>res</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nf>version</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>err</span> <span class=p>=</span> <span class=o>&lt;-</span><span class=nx>promise</span><span class=p>.</span><span class=nx>errors</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Broker</span><span class=p>)</span> <span class=nf>send</span><span class=p>(</span><span class=nx>rb</span> <span class=nx>protocolBody</span><span class=p>,</span> <span class=nx>promiseResponse</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>responseHeaderVersion</span> <span class=kt>int16</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>responsePromise</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nx>req</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>request</span><span class=p>{</span><span class=nx>correlationID</span><span class=p>:</span> <span class=nx>b</span><span class=p>.</span><span class=nx>correlationID</span><span class=p>,</span> <span class=nx>clientID</span><span class=p>:</span> <span class=nx>b</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>ClientID</span><span class=p>,</span> <span class=nx>body</span><span class=p>:</span> <span class=nx>rb</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>encode</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>MetricRegistry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>bytes</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>write</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最终通过<code>bytes, err := b.write(buf)</code> 发送出去。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Broker</span><span class=p>)</span> <span class=nf>write</span><span class=p>(</span><span class=nx>buf</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>conn</span><span class=p>.</span><span class=nf>SetWriteDeadline</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Net</span><span class=p>.</span><span class=nx>WriteTimeout</span><span class=p>));</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 这里就是 net 包中的逻辑了。。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nx>b</span><span class=p>.</span><span class=nx>conn</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>至此，<code>Sarama</code>生产者相关的内容就介绍完毕了。</p><blockquote><p>还有一个比较重要的，消息打包批量发送的逻辑，比较多再下一章讲。</p></blockquote><h2 id=3-消息打包源码分析>3. 消息打包源码分析</h2><p>在之前 BrokerProducer 逻辑中启动了两个 goroutine，其中 bridge 从 chan 中取消息并真正发送出去。</p><p><em>那么这个 chan 里的消息是哪里来的呢?</em></p><p>其实这就是另一个 goroutine 的工作了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>asyncProducer</span><span class=p>)</span> <span class=nf>newBrokerProducer</span><span class=p>(</span><span class=nx>broker</span> <span class=o>*</span><span class=nx>Broker</span><span class=p>)</span> <span class=o>*</span><span class=nx>brokerProducer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>input</span>     <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>bridge</span>    <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>produceSet</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>responses</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>brokerProducerResponse</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>bp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>brokerProducer</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>parent</span><span class=p>:</span>         <span class=nx>p</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>broker</span><span class=p>:</span>         <span class=nx>broker</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>input</span><span class=p>:</span>          <span class=nx>input</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>output</span><span class=p>:</span>         <span class=nx>bridge</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>responses</span><span class=p>:</span>      <span class=nx>responses</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>stopchan</span><span class=p>:</span>       <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}),</span>
</span></span><span class=line><span class=cl>		<span class=nx>buffer</span><span class=p>:</span>         <span class=nf>newProduceSet</span><span class=p>(</span><span class=nx>p</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>currentRetries</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>int32</span><span class=p>]</span><span class=kt>error</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>withRecover</span><span class=p>(</span><span class=nx>bp</span><span class=p>.</span><span class=nx>run</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// minimal bridge to make the network response `select`able
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>go</span> <span class=nf>withRecover</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>set</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>bridge</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>request</span> <span class=o>:=</span> <span class=nx>set</span><span class=p>.</span><span class=nf>buildRequest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>response</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>broker</span><span class=p>.</span><span class=nf>Produce</span><span class=p>(</span><span class=nx>request</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>responses</span> <span class=o>&lt;-</span> <span class=o>&amp;</span><span class=nx>brokerProducerResponse</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>set</span><span class=p>:</span> <span class=nx>set</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>err</span><span class=p>:</span> <span class=nx>err</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>res</span><span class=p>:</span> <span class=nx>response</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>responses</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Retry</span><span class=p>.</span><span class=nx>Max</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>bp</span><span class=p>.</span><span class=nx>abandoned</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>bp</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=run>run</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>bp</span> <span class=o>*</span><span class=nx>brokerProducer</span><span class=p>)</span> <span class=nf>run</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>output</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=o>*</span><span class=nx>produceSet</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>msg</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>bp</span><span class=p>.</span><span class=nx>input</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 1. 检查 buffer 空间是否足够存放当前 msg
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>.</span><span class=nf>wouldOverflow</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>bp</span><span class=p>.</span><span class=nf>waitForSpace</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=kc>false</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>bp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>retryMessage</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=k>continue</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 2. 将 msg 存入 buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>.</span><span class=nf>add</span><span class=p>(</span><span class=nx>msg</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>bp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>returnError</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 3. 如果间隔时间到了，也会将消息发出去
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>bp</span><span class=p>.</span><span class=nx>timer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>bp</span><span class=p>.</span><span class=nx>timerFired</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 4. 将 buffer 里的数据发送到 局部变量 output chan 里
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>case</span> <span class=nx>output</span> <span class=o>&lt;-</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>bp</span><span class=p>.</span><span class=nf>rollOver</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>response</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>bp</span><span class=p>.</span><span class=nx>responses</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>bp</span><span class=p>.</span><span class=nf>handleResponse</span><span class=p>(</span><span class=nx>response</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> 
</span></span><span class=line><span class=cl>		<span class=c1>// 5.如果发送时间到了 或者消息大小或者条数达到阈值 则表示可以发送了 将  bp.output chan 赋值给局部变量 output
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>timerFired</span> <span class=o>||</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>.</span><span class=nf>readyToFlush</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>output</span> <span class=p>=</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>output</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>output</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>1）首先检测 buffer 空间</li><li>2）将 msg 写入 buffer</li><li>3）后面的 3 4 5 步都是在发送消息，或者为发送消息做准备</li></ul><h3 id=wouldoverflow>wouldOverflow</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>.</span><span class=nf>wouldOverflow</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>bp</span><span class=p>.</span><span class=nf>waitForSpace</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=kc>false</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>bp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>retryMessage</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 add 之前先调用<code>bp.buffer.wouldOverflow(msg)</code> 方法检查 buffer 是否存在足够空间以存放当前消息。</p><p>wouldOverflow 比较简单，就是判断当前消息大小或者消息数量是否超过设定值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ps</span> <span class=o>*</span><span class=nx>produceSet</span><span class=p>)</span> <span class=nf>wouldOverflow</span><span class=p>(</span><span class=nx>msg</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>bufferBytes</span><span class=o>+</span><span class=nx>msg</span><span class=p>.</span><span class=nf>byteSize</span><span class=p>(</span><span class=nx>version</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>MaxRequestSize</span><span class=o>-</span><span class=p>(</span><span class=mi>10</span><span class=o>*</span><span class=mi>1024</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>msgs</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>]</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>msgs</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>][</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span><span class=p>]</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>		<span class=nx>ps</span><span class=p>.</span><span class=nx>msgs</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>][</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span><span class=p>].</span><span class=nx>bufferBytes</span><span class=o>+</span><span class=nx>msg</span><span class=p>.</span><span class=nf>byteSize</span><span class=p>(</span><span class=nx>version</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>MaxMessageBytes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Flush</span><span class=p>.</span><span class=nx>MaxMessages</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>bufferCount</span> <span class=o>&gt;=</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Flush</span><span class=p>.</span><span class=nx>MaxMessages</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果不够就要调用<code>bp.waitForSpace()</code> 等待 buffer 腾出空间，其实就是把 buffer 里的消息发到 output chan。</p><blockquote><p>这个 output chan 就是前面匿名函数里的 bridge。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>bp</span> <span class=o>*</span><span class=nx>brokerProducer</span><span class=p>)</span> <span class=nf>waitForSpace</span><span class=p>(</span><span class=nx>msg</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>,</span> <span class=nx>forceRollover</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>response</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>bp</span><span class=p>.</span><span class=nx>responses</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>bp</span><span class=p>.</span><span class=nf>handleResponse</span><span class=p>(</span><span class=nx>response</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>reason</span> <span class=o>:=</span> <span class=nx>bp</span><span class=p>.</span><span class=nf>needsRetry</span><span class=p>(</span><span class=nx>msg</span><span class=p>);</span> <span class=nx>reason</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>reason</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>!</span><span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>.</span><span class=nf>wouldOverflow</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>forceRollover</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>output</span> <span class=o>&lt;-</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>bp</span><span class=p>.</span><span class=nf>rollOver</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=add>add</h3><p>接下来是调用<code>bp.buffer.add()</code>把消息添加到 buffer，功能比较简单，把待发送的消息添加到 buffer 中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ps</span> <span class=o>*</span><span class=nx>produceSet</span><span class=p>)</span> <span class=nf>add</span><span class=p>(</span><span class=nx>msg</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 1.消息编码
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>key</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>Key</span><span class=p>.</span><span class=nf>Encode</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>val</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>Value</span><span class=p>.</span><span class=nf>Encode</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 2.添加消息到 set.msgs 数组
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>set</span><span class=p>.</span><span class=nx>msgs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>set</span><span class=p>.</span><span class=nx>msgs</span><span class=p>,</span> <span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 3.添加到set.recordsToSend
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>msgToSend</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Message</span><span class=p>{</span><span class=nx>Codec</span><span class=p>:</span> <span class=nx>CompressionNone</span><span class=p>,</span> <span class=nx>Key</span><span class=p>:</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>Value</span><span class=p>:</span> <span class=nx>val</span><span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ps</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>conf</span><span class=p>.</span><span class=nx>Version</span><span class=p>.</span><span class=nf>IsAtLeast</span><span class=p>(</span><span class=nx>V0_10_0_0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>msgToSend</span><span class=p>.</span><span class=nx>Timestamp</span> <span class=p>=</span> <span class=nx>timestamp</span>
</span></span><span class=line><span class=cl>			<span class=nx>msgToSend</span><span class=p>.</span><span class=nx>Version</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>set</span><span class=p>.</span><span class=nx>recordsToSend</span><span class=p>.</span><span class=nx>MsgSet</span><span class=p>.</span><span class=nf>addMessage</span><span class=p>(</span><span class=nx>msgToSend</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 4. 增加 buffer 大小和 buffer 中的消息条数
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>ps</span><span class=p>.</span><span class=nx>bufferBytes</span> <span class=o>+=</span> <span class=nx>size</span>
</span></span><span class=line><span class=cl>		<span class=nx>ps</span><span class=p>.</span><span class=nx>bufferCount</span><span class=o>++</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>set.recordsToSend.MsgSet.addMessage</code>也很简单：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ms</span> <span class=o>*</span><span class=nx>MessageSet</span><span class=p>)</span> <span class=nf>addMessage</span><span class=p>(</span><span class=nx>msg</span> <span class=o>*</span><span class=nx>Message</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>block</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>MessageBlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>block</span><span class=p>.</span><span class=nx>Msg</span> <span class=p>=</span> <span class=nx>msg</span>
</span></span><span class=line><span class=cl>	<span class=nx>ms</span><span class=p>.</span><span class=nx>Messages</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>ms</span><span class=p>.</span><span class=nx>Messages</span><span class=p>,</span> <span class=nx>block</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=定时发送>定时发送</h3><p>因为异步发送者除了消息数或者消息大小达到阈值会触发一次发送之外，到了一定时间也会触发一次发送，具体逻辑也在这个 run 方法里，这个地方比较有意思。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>bp</span> <span class=o>*</span><span class=nx>brokerProducer</span><span class=p>)</span> <span class=nf>run</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>output</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=o>*</span><span class=nx>produceSet</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>msg</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>bp</span><span class=p>.</span><span class=nx>input</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 1.时间到了就将 bp.timerFired 设置为 true
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>bp</span><span class=p>.</span><span class=nx>timer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			 <span class=nx>bp</span><span class=p>.</span><span class=nx>timerFired</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 3.直接把 buffer 里的消息往局部变量 output 里发
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>case</span> <span class=nx>output</span> <span class=o>&lt;-</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>bp</span><span class=p>.</span><span class=nf>rollOver</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 2.如果时间到了，或者 buffer 里的消息达到阈值后都会触发真正的发送逻辑，这里实现比较有意思，需要发送的时候就把 bp.output 也就是存放真正需要发送的批量消息的 chan 赋值给局部变量 output，如果不需要发送就把局部变量 output 清空
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>timerFired</span> <span class=o>||</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>buffer</span><span class=p>.</span><span class=nf>readyToFlush</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>output</span> <span class=p>=</span> <span class=nx>bp</span><span class=p>.</span><span class=nx>output</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>output</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>根据注释中的 1、2、3步骤看来，如果第二步需要发送就会给 output 赋值，这样下一轮 select 的时候<code>case output &lt;- bp.buffer:</code> 这个 case 就可能会执行到，就会把消息发给 output，实际上就是发送给了 bp.output.</p><p>如果第二步时不需要发消息，output 就被置空，select 时对应的 case 就不会被执行。</p><blockquote><p>正常写法一般是在启动一个 goroutine 来处理定时发送的功能，但是这样两个 goroutine 之间就会存在竞争，会影响性能。这样处理省去了加解锁过程，性能会高一些，但是随之而来的是代码复杂度的提升。</p></blockquote><p>作者能力实在是有限，文中很有可能会有一些错误的理解。所以当你发现了一些违和的地方，也请不吝指教，谢谢你！</p><p>再次感谢你能看到这里！</p><h2 id=4-小结>4. 小结</h2><p><strong>1）具体流程：见开篇图</strong></p><p><strong>2）常见优化手段：批量处理。</strong></p><p>异步消费者 Go 实现中做了<strong>消息批量发送</strong>这个优化，当累积了足够的消息后一次性发送，减少网络请求次数以提升性能。</p><blockquote><p>类似于 Redis Pipeline，将多次命令一次性发送，以减少 RTT。</p></blockquote><p>当然为了避免在消息少的时候很久都凑不齐足够消息，导致的无法发送，一般还会设定一个<strong>定时发送阈值</strong>，每隔一段时间也会发送一次。</p><p>这是一种常见的优化手段，比如 IO 相关的地方肯定会有什么 bufferio 之类的库，在写时先写 buffer，buffer 满了再一次性写入到磁盘。读取也是同样的，先读到 buffer 里，然后应用程序再从 buffer 里一行行读出去。</p><p><strong>3）代码复杂度和性能取舍</strong></p><p>在分析 Sarama Proudcer 的最后一段可以看到是有一个骚操作的，这种操作可以提升性能，但是随之而来的就是代码复杂度的提升。</p><blockquote><p>最近在看 Go runtime 里面也有很多骚操作。这种底层库、中间件这样写没什么问题，但是平常我们的业务代码就尽量别搞骚炒作了。</p></blockquote><blockquote><p>&ldquo;The performance improvement does not materialize from the air,it comes with code complexity increase.&ldquo;一dvyokov</p></blockquote><p>性能不会凭空提升，随之而来的一定是代码复杂度的增加。</p><blockquote><p>Kafka 系列相关代码见 <a href=https://github.com/barrypt/kafka-go-example target=_blank rel="noopener noreffer">Github</a></p></blockquote><h2 id=5-参考>5. 参考</h2><p><code>https://github.com/Shopify/sarama</code></p><p><code>https://cs50mu.github.io/post/2021/01/22/source-code-of-sarama-part-i/</code></p><p><code>https://www.jianshu.com/p/138e0ac2e1f0</code></p><p><code>https://juejin.cn/post/6866316565348876296</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-08-14</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/kafka/06-sarama-producer/ data-title="Kafka(Go)教程(六)---sarama 客户端 producer 源码分析" data-hashtags=Kafka><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/kafka/06-sarama-producer/ data-hashtag=Kafka><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/kafka/06-sarama-producer/ data-title="Kafka(Go)教程(六)---sarama 客户端 producer 源码分析"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/kafka/06-sarama-producer/ data-title="Kafka(Go)教程(六)---sarama 客户端 producer 源码分析"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/kafka/06-sarama-producer/ data-title="Kafka(Go)教程(六)---sarama 客户端 producer 源码分析"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/kafka/>Kafka</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/kafka/05-quick-start/ class=prev rel=prev title="Kafka(Go)教程(五)---Producer-Consumer API 基本使用"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Kafka(Go)教程(五)---Producer-Consumer API 基本使用</a>
<a href=/posts/kafka/07-partition/ class=next rel=next title=Kafka(Go)教程(七)---生产者分区机制原理剖析及实战>Kafka(Go)教程(七)---生产者分区机制原理剖析及实战<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>