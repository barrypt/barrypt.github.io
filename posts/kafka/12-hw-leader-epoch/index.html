<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制 -</title><meta name=Description content="Kafka 中的高水位（High Watermark）和 Leader Epoch 机制"><meta property="og:title" content="Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制"><meta property="og:description" content="Kafka 中的高水位（High Watermark）和 Leader Epoch 机制"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/kafka/12-hw-leader-epoch/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-30T22:00:00+00:00"><meta property="article:modified_time" content="2021-09-30T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制"><meta name=twitter:description content="Kafka 中的高水位（High Watermark）和 Leader Epoch 机制"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/kafka/12-hw-leader-epoch/><link rel=prev href=https://blog.yudlk.com/posts/mysql/10-acid/><link rel=next href=https://blog.yudlk.com/posts/go/sync-pool/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/kafka\/12-hw-leader-epoch\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Kafka","wordcount":3624,"url":"https:\/\/blog.yudlk.com\/posts\/kafka\/12-hw-leader-epoch\/","datePublished":"2021-09-30T22:00:00+00:00","dateModified":"2021-09-30T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Kafka 中的高水位（High Watermark）和 Leader Epoch 机制"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/kafka/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kafka</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-09-30>2021-09-30</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;3624 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;8 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-概述>1. 概述</a></li><li><a href=#2-高水位high-watermark>2. 高水位（High Watermark）</a><ul><li><a href=#高水位的作用>高水位的作用</a></li><li><a href=#高水位更新机制>高水位更新机制</a></li><li><a href=#副本同步机制解析>副本同步机制解析</a></li><li><a href=#消息丢失问题>消息丢失问题</a></li></ul></li><li><a href=#3-leader-epoch-机制>3. Leader Epoch 机制</a></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文解释了 Kafka 中的高水位和 Leader Epoch 机制。</p><h2 id=1-概述>1. 概述</h2><blockquote><p>Kafka 系列相关代码见 <a href=https://github.com/barrypt/kafka-go-example target=_blank rel="noopener noreffer">Github</a></p></blockquote><p>高水位（High Watermark）是 Kafka 中非常重要的概念，而 Leader Epoch 是社区在 0.11 版本中新推出的，主要是为了弥补高水位机制的一些缺陷。</p><h2 id=2-高水位high-watermark>2. 高水位（High Watermark）</h2><p>水位一词多用于流式处理领域，比如，Spark Streaming 或 Flink 框架中都有水位的概念。教科书中关于水位的经典定义通常是这样的：</p><blockquote><p>在时刻 T，任意创建时间（Event Time）为 T’，且 T’≤T 的所有事件都已经到达或被观测到，那么 T 就被定义为水位。</p></blockquote><p>具体如下图所示：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/Steaming-Pipeline.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/Steaming-Pipeline.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/Steaming-Pipeline.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/Steaming-Pipeline.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/Steaming-Pipeline.webp title=Steaming-Pipeline></p><p>图中标注“Completed”的蓝色部分代表已完成的工作，标注“In-Flight”的红色部分代表正在进行中的工作，两者的边界就是水位线。</p><p>在 Kafka 的世界中，水位的概念有一点不同，<strong>它是用消息位移来表征的</strong>。</p><blockquote><p>另外 Kafka 中只有高水位没有低水位的说法，所以下文主要围绕 高水位展开。</p></blockquote><h3 id=高水位的作用>高水位的作用</h3><p>在 Kafka 中，高水位的作用主要有 2 个。</p><ul><li>1）定义消息可见性，即用来标识分区下的哪些消息是可以被消费者消费的。</li><li>2）帮助 Kafka 完成副本同步。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/Kafka-Leader%E5%89%AF%E6%9C%AC%E7%9A%84%E9%AB%98%E6%B0%B4%E4%BD%8D%E5%9B%BE.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/Kafka-Leader%E5%89%AF%E6%9C%AC%E7%9A%84%E9%AB%98%E6%B0%B4%E4%BD%8D%E5%9B%BE.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/Kafka-Leader%E5%89%AF%E6%9C%AC%E7%9A%84%E9%AB%98%E6%B0%B4%E4%BD%8D%E5%9B%BE.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/Kafka-Leader%E5%89%AF%E6%9C%AC%E7%9A%84%E9%AB%98%E6%B0%B4%E4%BD%8D%E5%9B%BE.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/Kafka-Leader%E5%89%AF%E6%9C%AC%E7%9A%84%E9%AB%98%E6%B0%B4%E4%BD%8D%E5%9B%BE.webp title=HW></p><p>我们假设这是某个分区 Leader 副本的高水位图。首先，请你注意图中的“已提交消息”和“未提交消息”。</p><p><strong>在分区高水位以下的消息被认为是已提交消息，反之就是未提交消息。消费者只能消费已提交消息</strong>，即图中位移小于 8 的所有消息。</p><blockquote><p>注意，这里我们不讨论 Kafka 事务，因为事务机制会影响消费者所能看到的消息的范围，它不只是简单依赖高水位来判断。它依靠一个名为 LSO（Log Stable Offset）的位移值来判断事务型消费者的可见性。</p></blockquote><p>图中还有一个日志末端位移的概念，即 Log End Offset，简写是 <strong>LEO</strong>。它表示副本写入下一条消息的位移值。</p><blockquote><p>注意，数字 15 所在的方框是虚线，这就说明，这个副本当前只有 15 条消息，位移值是从 0 到 14，下一条新消息的位移是 15</p></blockquote><p>**高水位和 LEO 是副本对象的两个重要属性。**Kafka 所有副本都有对应的高水位和 LEO 值，而不仅仅是 Leader 副本。只不过 Leader 副本比较特殊，Kafka 使用 Leader 副本的高水位来定义所在分区的高水位。换句话说，<strong>分区的高水位就是其 Leader 副本的高水位</strong>。</p><h3 id=高水位更新机制>高水位更新机制</h3><p>实际上，除了保存一组高水位值和 LEO 值=之外，在 Leader 副本所在的 Broker 上，还保存了其他 Follower 副本（也称为远程副本）的 LEO 值。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E4%BF%9D%E5%AD%98%E5%85%B6%E4%BB%96%E5%89%AF%E6%9C%ACLEO%E5%80%BC.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E4%BF%9D%E5%AD%98%E5%85%B6%E4%BB%96%E5%89%AF%E6%9C%ACLEO%E5%80%BC.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E4%BF%9D%E5%AD%98%E5%85%B6%E4%BB%96%E5%89%AF%E6%9C%ACLEO%E5%80%BC.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E4%BF%9D%E5%AD%98%E5%85%B6%E4%BB%96%E5%89%AF%E6%9C%ACLEO%E5%80%BC.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E4%BF%9D%E5%AD%98%E5%85%B6%E4%BB%96%E5%89%AF%E6%9C%ACLEO%E5%80%BC.webp title=Other-LEO></p><p>在这张图中，我们可以看到，Broker 0 上保存了某分区的 Leader 副本和所有 Follower 副本的 LEO 值，而 Broker 1 上仅仅保存了该分区的某个 Follower 副本。</p><p><em>为什么要在 Broker 0 上保存这些远程副本呢？</em></p><p>其实，它们的主要作用是，<strong>帮助 Leader 副本确定其高水位，也就是分区高水位</strong>。</p><p>更新机制如下表：</p><table><thead><tr><th>更新对象</th><th>更新时机</th></tr></thead><tbody><tr><td>Broker 1 上的 Follow 副本 LEO</td><td>Follower 副本从 Leader 副本拉取消息，写入到本地磁盘后，会更新其 LEO 值。</td></tr><tr><td>Broker 0 上Leader 副本 LEO</td><td>Leader副本接收到生产者发送的消息，写入到本地磁盘后，会更新其LEO值。</td></tr><tr><td>Broker 0 上远程副本 LEO</td><td>Follower副本从eader副本拉取消息时，会告诉L eader副本从哪个位移处开始拉取。L eader副本会使用这个位移值来更新远程副本的L EO。</td></tr><tr><td>Broker 1 上Follower副本高水位</td><td>Follower副本成功更新完LEO之后，会比较其LEO值与Leader副本发来的高水位值，并用两者的较小值去更新它自己的高水位。</td></tr><tr><td>Broker 0上Leader副本高水位</td><td>主要有两个更新时机: 一个是Leader副本更新其LEO之后;另一个是更新完远程副本LEO之后。具体的算法是:取 Leader副本和所有与Leader同步的远程副本LEO中的最小值</td></tr></tbody></table><p><strong>Leader 副本</strong></p><p>处理生产者请求的逻辑如下：</p><ul><li>1）写入消息到本地磁盘。</li><li>2）更新分区高水位值。<ul><li>获取 Leader 副本所在 Broker 端保存的所有远程副本 LEO 值（LEO-1，LEO-2，……，LEO-n）。</li><li>获取 Leader 副本高水位值：currentHW。</li><li>更新 currentHW = max{currentHW, min（LEO-1, LEO-2, ……，LEO-n）}。</li></ul></li></ul><p>处理 Follower 副本拉取消息的逻辑如下：</p><ul><li>1）读取磁盘（或页缓存）中的消息数据。</li><li>2）使用 Follower 副本发送请求中的位移值更新远程副本 LEO 值。</li><li>3）更新分区高水位值（具体步骤与处理生产者请求的步骤相同）。</li></ul><p><strong>Follower 副本</strong></p><p>从 Leader 拉取消息的处理逻辑如下：</p><ul><li>1）写入消息到本地磁盘。</li><li>2）更新 LEO 值。</li><li>3）更新高水位值。<ul><li>获取 Leader 发送的高水位值：currentHW。</li><li>获取步骤 2 中更新过的 LEO 值：currentLEO。</li><li>更新高水位为 min(currentHW, currentLEO)。</li></ul></li></ul><h3 id=副本同步机制解析>副本同步机制解析</h3><p>首先是初始状态。下面这张图中的 remote LEO 就是刚才的远程副本的 LEO 值。在初始状态时，所有值都是 0。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A51.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A51.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A51.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A51.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A51.webp title=Sync-1></p><p>当生产者给主题分区发送一条消息后，状态变更为：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A52.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A52.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A52.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A52.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A52.webp title=Sync-2></p><p>此时，Leader 副本成功将消息写入了本地磁盘，故 LEO 值被更新为 1。</p><p>Follower 再次尝试从 Leader 拉取消息。和之前不同的是，这次有消息可以拉取了，因此状态进一步变更为：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A53.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A53.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A53.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A53.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A53.webp title=Sync-3></p><p>这时，Follower 副本也成功地更新 LEO 为 1。此时，Leader 和 Follower 副本的 LEO 都是 1，但各自的高水位依然是 0，还没有被更新。它们需要在下一轮的拉取中被更新，如下图所示：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A54.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A54.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A54.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A54.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A54.webp title=Sync-4></p><p>在新一轮的拉取请求中，由于位移值是 0 的消息已经拉取成功，因此 Follower 副本这次请求拉取的是位移值 =1 的消息。Leader 副本接收到此请求后，更新远程副本 LEO 为 1，然后更新 Leader 高水位为 1。做完这些之后，它会将当前已更新过的高水位值 1 发送给 Follower 副本。Follower 副本接收到以后，也将自己的高水位值更新成 1。至此，一次完整的消息同步周期就结束了。事实上，Kafka 就是利用这样的机制，实现了 Leader 和 Follower 副本之间的同步。</p><h3 id=消息丢失问题>消息丢失问题</h3><p>从刚才的分析中，我们知道，Follower 副本的高水位更新需要一轮额外的拉取请求才能实现。如果把上面那个例子扩展到多个 Follower 副本，情况可能更糟，也许需要多轮拉取请求。也就是说，<strong>Leader 副本高水位更新和 Follower 副本高水位更新在时间上是存在错配的</strong>。这种错配是很多“数据丢失”或“数据不一致”问题的根源。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp title=Msg-Lost></p><p>开始时，副本 A 和副本 B 都处于正常状态，A 是 Leader 副本。某个使用了默认 acks 设置的生产者程序向 A 发送了两条消息，A 全部写入成功，此时 Kafka 会通知生产者说两条消息全部发送成功。</p><p>现在我们假设 Leader 和 Follower 都写入了这两条消息，而且 Leader 副本的高水位也已经更新了，但 Follower 副本高水位还未更新——这是可能出现的。还记得吧，Follower 端高水位的更新与 Leader 端有时间错配。倘若此时副本 B 所在的 Broker 宕机，当它重启回来后，副本 B 会执行日志截断操作，将 LEO 值调整为之前的高水位值，也就是 1。这就是说，位移值为 1 的那条消息被副本 B 从磁盘中删除，此时副本 B 的底层磁盘文件中只保存有 1 条消息，即位移值为 0 的那条消息。</p><p>当执行完截断操作后，副本 B 开始从 A 拉取消息，执行正常的消息同步。如果就在这个节骨眼上，副本 A 所在的 Broker 宕机了，那么 Kafka 就别无选择，只能让副本 B 成为新的 Leader，此时，当 A 回来后，需要执行相同的日志截断操作，即将高水位调整为与 B 相同的值，也就是 1。这样操作之后，位移值为 1 的那条消息就从这两个副本中被永远地抹掉了。</p><h2 id=3-leader-epoch-机制>3. Leader Epoch 机制</h2><p>社区在 0.11 版本正式引入了 Leader Epoch 概念，来规避因高水位更新错配导致的各种不一致问题。</p><p>所谓 Leader Epoch，我们大致可以认为是 Leader 版本。它由两部分数据组成。</p><ul><li>1）Epoch。一个单调增加的版本号。每当副本领导权发生变更时，都会增加该版本号。小版本号的 Leader 被认为是过期 Leader，不能再行使 Leader 权力。</li><li>2）起始位移（Start Offset）。Leader 副本在该 Epoch 值上写入的首条消息的位移。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/kafka/hw/Leader%20Epoch%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp data-srcset="https://github.com/barrypt/blog/raw/master/images/kafka/hw/Leader%20Epoch%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp, https://github.com/barrypt/blog/raw/master/images/kafka/hw/Leader%20Epoch%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp 1.5x, https://github.com/barrypt/blog/raw/master/images/kafka/hw/Leader%20Epoch%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/kafka/hw/Leader%20Epoch%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.webp title=LEO></p><p>场景和之前大致是类似的，只不过引用 Leader Epoch 机制后，Follower 副本 B 重启回来后，需要向 A 发送一个特殊的请求去获取 Leader 的 LEO 值。在这个例子中，该值为 2。当获知到 Leader LEO=2 后，B 发现该 LEO 值不比它自己的 LEO 值小，而且缓存中也没有保存任何起始位移值 > 2 的 Epoch 条目，因此 B 无需执行任何日志截断操作。这是对高水位机制的一个明显改进，即副本是否执行日志截断不再依赖于高水位进行判断。</p><p>现在，副本 A 宕机了，B 成为 Leader。同样地，当 A 重启回来后，执行与 B 相同的逻辑判断，发现也不用执行日志截断，至此位移值为 1 的那条消息在两个副本中均得到保留。后面当生产者程序向 B 写入新消息时，副本 B 所在的 Broker 缓存中，会生成新的 Leader Epoch 条目：[Epoch=1, Offset=2]。之后，副本 B 会使用这个条目帮助判断后续是否执行日志截断操作。</p><p>这样，通过 Leader Epoch 机制，Kafka 完美地规避了这种数据丢失场景。</p><h2 id=4-小结>4. 小结</h2><p>本文主要介绍了 Kafka 的高水位机制以及 Leader Epoch 机制。</p><p>高水位的作用：</p><ul><li>1）定义消息可见性<ul><li>在分区高水位以下的消息被认为是已提交消息，反之就是未提交消息。消费者只能消费已提交消息。</li></ul></li><li>2）帮助 Kafka 完成副本同步</li></ul><p>高水位在界定 Kafka 消息对外可见性以及实现副本机制等方面起到了非常重要的作用，但其设计上的缺陷给 Kafka 留下了很多数据丢失或数据不一致的潜在风险。</p><p>为此，社区引入了 Leader Epoch 机制，尝试规避掉这类风险。</p><p>Leader Epoch，我们大致可以认为是Leader版本。它由两部分数据组成：</p><ul><li>1）Epoch,一个单调增加的版本号。每当副本领导权发生变更时，都会增加该
版本号。</li><li>2）起始位移Leader副本在该Epoch值上写入的首条消息的位移。</li></ul><blockquote><p>Kafka 系列相关代码见 <a href=https://github.com/barrypt/kafka-go-example target=_blank rel="noopener noreffer">Github</a></p></blockquote><h2 id=5-参考>5. 参考</h2><p><code>《Kafka 核心技术与实战》</code></p><p><code>《Apache Kafka实战》</code></p><p><code>https://www.cnblogs.com/youngchaolin/p/12641463.html</code></p><p><code>https://juejin.cn/post/6979110739416088607</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-09-30</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/kafka/12-hw-leader-epoch/ data-title="Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制" data-hashtags=Kafka><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/kafka/12-hw-leader-epoch/ data-hashtag=Kafka><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/kafka/12-hw-leader-epoch/ data-title="Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/kafka/12-hw-leader-epoch/ data-title="Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/kafka/12-hw-leader-epoch/ data-title="Kafka(Go)教程(十二)---Kafka 中的高水位和 Leader Epoch 机制"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/kafka/>Kafka</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/mysql/10-acid/ class=prev rel=prev title="MySQL教程(十)---MySQL ACID 实现原理"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>MySQL教程(十)---MySQL ACID 实现原理</a>
<a href=/posts/go/sync-pool/ class=next rel=next title="Go语言之 sync.pool 源码分析">Go语言之 sync.pool 源码分析<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>