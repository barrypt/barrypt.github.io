<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Kafka(Go)教程(七)---生产者分区机制原理剖析及实战 -</title><meta name=Description content="Kafka 生产者分区机制原理剖析及 Go 客户端 sarama 实战"><meta property="og:title" content="Kafka(Go)教程(七)---生产者分区机制原理剖析及实战"><meta property="og:description" content="Kafka 生产者分区机制原理剖析及 Go 客户端 sarama 实战"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/kafka/07-partition/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-20T22:00:00+00:00"><meta property="article:modified_time" content="2021-08-20T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Kafka(Go)教程(七)---生产者分区机制原理剖析及实战"><meta name=twitter:description content="Kafka 生产者分区机制原理剖析及 Go 客户端 sarama 实战"><meta name=application-name content="指月小筑"><meta name=apple-mobile-web-app-title content="指月小筑"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/kafka/07-partition/><link rel=prev href=https://blog.yudlk.com/posts/kafka/06-sarama-producer/><link rel=next href=https://blog.yudlk.com/posts/kafka/08-compression/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Kafka(Go)教程(七)---生产者分区机制原理剖析及实战","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/kafka\/07-partition\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Kafka","wordcount":3124,"url":"https:\/\/blog.yudlk.com\/posts\/kafka\/07-partition\/","datePublished":"2021-08-20T22:00:00+00:00","dateModified":"2021-08-20T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Kafka 生产者分区机制原理剖析及 Go 客户端 sarama 实战"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=指月小筑>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=指月小筑>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Kafka(Go)教程(七)---生产者分区机制原理剖析及实战</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/lixd title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/kafka/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kafka</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-08-20>2021-08-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;3124 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;7 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-概述>1. 概述</a></li><li><a href=#2-分区策略>2. 分区策略</a><ul><li><a href=#自定义分区策略>自定义分区策略</a></li><li><a href=#轮询策略>轮询策略</a></li><li><a href=#随机策略>随机策略</a></li><li><a href=#按消息键保序策略>按消息键保序策略</a></li></ul></li><li><a href=#3-go-自定义分区策略>3. Go 自定义分区策略</a><ul><li><a href=#1-demo>1. Demo</a></li><li><a href=#2-源码分析>2. 源码分析</a></li></ul></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要分析了 Kafka 消息分区（Partition）机制的原理，包括常见分区策略以及自定义分区策略。最后对 Go 客户端 Sarama 具体实现进行了演示和分析。</p><blockquote><p>Kakfa 相关代码见 <a href=https://github.com/lixd/kafka-go-example target=_blank rel="noopener noreffer">Github</a></p></blockquote><h2 id=1-概述>1. 概述</h2><p>Kafka 有主题（Topic）的概念，它是承载真实数据的逻辑容器，而在主题之下还分为若干个分区，也就是说 Kafka 的消息组织方式实际上是三级结构：<strong>主题 - 分区 - 消息</strong>。</p><p>主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。官网上的这张图非常清晰地展示了 Kafka 的三级结构，如下所示：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/lixd/blog/raw/master/images/kafka/partition/Anatomy%20of%20a%20Topic.webp data-srcset="https://github.com/lixd/blog/raw/master/images/kafka/partition/Anatomy%20of%20a%20Topic.webp, https://github.com/lixd/blog/raw/master/images/kafka/partition/Anatomy%20of%20a%20Topic.webp 1.5x, https://github.com/lixd/blog/raw/master/images/kafka/partition/Anatomy%20of%20a%20Topic.webp 2x" data-sizes=auto alt=https://github.com/lixd/blog/raw/master/images/kafka/partition/Anatomy%20of%20a%20Topic.webp title="Anatomy of a Topic"></p><p><em>你觉得为什么 Kafka 要做这样的设计？为什么使用分区的概念而不是直接使用多个主题呢？</em></p><p><strong>其实分区的作用就是提供负载均衡的能力，或者说对数据进行分区的主要原因，就是为了实现系统的高伸缩性（Scalability）。</strong></p><p>不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。</p><p>不同的分布式系统对分区的叫法也不尽相同。比如在 Kafka 中叫分区，在 MongoDB 和 Elasticsearch 中就叫分片 Shard，而在 HBase 中则叫 Region，在 Cassandra 中又被称作 vnode。</p><blockquote><p>从表面看起来它们实现原理可能不尽相同，但对底层分区（Partitioning）的整体思想却从未改变。</p></blockquote><h2 id=2-分区策略>2. 分区策略</h2><p><strong>所谓分区策略是决定生产者将消息发送到哪个分区的算法</strong>。Kafka 为我们提供了默认的分区策略，同时它也支持你自定义分区策略。</p><h3 id=自定义分区策略>自定义分区策略</h3><p>如果要自定义分区策略，你需要显式地配置生产者端的参数 partitioner.class。</p><p>这个参数该怎么设定呢？方法很简单，在编写生产者程序时，你可以编写一个具体的类实现 org.apache.kafka.clients.producer.Partitioner 接口。这个接口也很简单，只定义了两个方法：partition() 和 close()，通常你只需要实现最重要的 partition 方法。我们来看看这个方法的方法签名：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span> <span class=nf>partition</span><span class=o>(</span><span class=n>String</span> <span class=n>topic</span><span class=o>,</span> <span class=n>Object</span> <span class=n>key</span><span class=o>,</span> <span class=kt>byte</span><span class=o>[]</span> <span class=n>keyBytes</span><span class=o>,</span> <span class=n>Object</span> <span class=n>value</span><span class=o>,</span> <span class=kt>byte</span><span class=o>[]</span> <span class=n>valueBytes</span><span class=o>,</span> <span class=n>Cluster</span> <span class=n>cluster</span><span class=o>);</span>
</span></span></code></pre></div><p>这里的 topic、key、keyBytes、value和valueBytes都属于消息数据，cluster则是集群信息（比如当前 Kafka 集群共有多少主题、多少 Broker 等）。</p><p>Kafka 给你这么多信息，就是希望让你能够充分地利用这些信息对消息进行分区，计算出它要被发送到哪个分区中。</p><p>只要你自己的实现类定义好了 partition 方法，同时设置 partitioner.class 参数为你自己实现类的 Full Qualified Name，那么生产者程序就会按照你的代码逻辑对消息进行分区。</p><h3 id=轮询策略>轮询策略</h3><p>也称 Round-robin 策略，即顺序分配。</p><blockquote><p>比如一个主题下有 3 个分区，那么第一条消息被发送到分区 0，第二条被发送到分区 1，第三条被发送到分区 2，以此类推。</p></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/lixd/blog/raw/master/images/kafka/partition/Round-robin.webp data-srcset="https://github.com/lixd/blog/raw/master/images/kafka/partition/Round-robin.webp, https://github.com/lixd/blog/raw/master/images/kafka/partition/Round-robin.webp 1.5x, https://github.com/lixd/blog/raw/master/images/kafka/partition/Round-robin.webp 2x" data-sizes=auto alt=https://github.com/lixd/blog/raw/master/images/kafka/partition/Round-robin.webp title=Round-robin></p><p><strong>轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们最常用的分区策略之一。</strong></p><h3 id=随机策略>随机策略</h3><p>也称 Randomness 策略。所谓随机就是我们随意地将消息放置到任意一个分区上，如下面这张图所示。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/lixd/blog/raw/master/images/kafka/partition/Randomness.webp data-srcset="https://github.com/lixd/blog/raw/master/images/kafka/partition/Randomness.webp, https://github.com/lixd/blog/raw/master/images/kafka/partition/Randomness.webp 1.5x, https://github.com/lixd/blog/raw/master/images/kafka/partition/Randomness.webp 2x" data-sizes=auto alt=https://github.com/lixd/blog/raw/master/images/kafka/partition/Randomness.webp title=Randomness></p><p>从实际表现来看，它要逊于轮询策略，所以<strong>如果追求数据的均匀分布，还是使用轮询策略比较好</strong>。</p><h3 id=按消息键保序策略>按消息键保序策略</h3><p>也称 Key-ordering 策略。</p><p>Kafka 允许为每条消息定义消息键，简称为 Key。这个 Key 的作用非常大，它可以是一个有着明确业务含义的字符串，比如客户代码、部门编号或是业务 ID 等；也可以用来表征消息元数据。</p><p>特别是在 Kafka 不支持时间戳的年代，在一些场景中，工程师们都是直接将消息创建时间封装进 Key 里面的。一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略，如下图所示。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/lixd/blog/raw/master/images/kafka/partition/Key-ordering.webp data-srcset="https://github.com/lixd/blog/raw/master/images/kafka/partition/Key-ordering.webp, https://github.com/lixd/blog/raw/master/images/kafka/partition/Key-ordering.webp 1.5x, https://github.com/lixd/blog/raw/master/images/kafka/partition/Key-ordering.webp 2x" data-sizes=auto alt=https://github.com/lixd/blog/raw/master/images/kafka/partition/Key-ordering.webp title=Key-ordering></p><p>实现这个策略的 partition 方法同样简单，只需要下面两行代码即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>PartitionInfo</span><span class=o>&gt;</span> <span class=n>partitions</span> <span class=o>=</span> <span class=n>cluster</span><span class=o>.</span><span class=na>partitionsForTopic</span><span class=o>(</span><span class=n>topic</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>Math</span><span class=o>.</span><span class=na>abs</span><span class=o>(</span><span class=n>key</span><span class=o>.</span><span class=na>hashCode</span><span class=o>())</span> <span class=o>%</span> <span class=n>partitions</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span></code></pre></div><p>前面提到的 Kafka 默认分区策略实际上同时实现了两种策略：如果指定了 Key，那么默认实现按消息键保序策略；如果没有指定 Key，则使用轮询策略。</p><p>注：<strong>Kafka 是不能保证全局消息顺序的，只能保证单个 Partition 下的顺序</strong>，所以在需要保证顺序的场景可以<strong>使用 Key-Ordering 策略将同一个用户的消息发送到同一分区，即可保证顺序</strong>。</p><h2 id=3-go-自定义分区策略>3. Go 自定义分区策略</h2><h3 id=1-demo>1. Demo</h3><p>前面讲的自定义分区策略是按照 Java客户端的逻辑，不同语言 客户端 可能实现上有所不同，这里用 Go Client sarama 写个 Demo 展示一下：</p><blockquote><p>大致逻辑相同，只是具体实现不同</p></blockquote><p>首先还是创建生产者时通过参数配置具体的分区策略</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Config</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=nx>Producer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>Partitioner</span> <span class=nx>PartitionerConstructor</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到 Config.Producer 里有一个 Partitioner 的参数，这就是分区策略配置项。</p><p>类型为 PartitionerConstructor，分区构造器，具体如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>PartitionerConstructor</span> <span class=kd>func</span><span class=p>(</span><span class=nx>topic</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>Partitioner</span>
</span></span></code></pre></div><p>这是一个 构造方法，该方法返回的 Partitioner 才是正在的 分区器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Partitioner</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>Partition</span><span class=p>(</span><span class=nx>message</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>,</span> <span class=nx>numPartitions</span> <span class=kt>int32</span><span class=p>)</span> <span class=p>(</span><span class=kt>int32</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>RequiresConsistency</span><span class=p>()</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>是一个 接口类型，所以要定义自定义分区策略只需要实现该接口即可。</p><p>我们先实现一个自定义的 Partitioner</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>myPartitioner</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>partition</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Partition 返回的是分区的位置或者索引，并不是具体的分区号。比如有十个分区[0,1，2,3...9] 这里返回 0 表示取数组中的第0个位置的分区。在 Go 客户端中是这样实现的，具体见下文源码分析
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>myPartitioner</span><span class=p>)</span> <span class=nf>Partition</span><span class=p>(</span><span class=nx>message</span> <span class=o>*</span><span class=nx>sarama</span><span class=p>.</span><span class=nx>ProducerMessage</span><span class=p>,</span> <span class=nx>numPartitions</span> <span class=kt>int32</span><span class=p>)</span> <span class=p>(</span><span class=kt>int32</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>partition</span> <span class=o>&gt;=</span> <span class=nx>numPartitions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span><span class=p>.</span><span class=nx>partition</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ret</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>partition</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>partition</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>ret</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 该方法的作用在下文源码分析中有详细解释
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>myPartitioner</span><span class=p>)</span> <span class=nf>RequiresConsistency</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后在实现一个构造方法即可</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewMyPartitioner</span><span class=p>(</span><span class=nx>topic</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>sarama</span><span class=p>.</span><span class=nx>Partitioner</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>myPartitioner</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最后构造生产者时指定自定义的 分区策略</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>config</span> <span class=o>:=</span> <span class=nx>sarama</span><span class=p>.</span><span class=nf>NewConfig</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>config</span><span class=p>.</span><span class=nx>Producer</span><span class=p>.</span><span class=nx>Partitioner</span> <span class=p>=</span> <span class=nx>NewMyPartitioner</span> <span class=c1>// 这个就是我们自定义 Partitioner 的构造方法
</span></span></span></code></pre></div><p>这样就完成了自定义分区策略。</p><p>运行起来看一下效果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>2021/08/21 08:39:47 <span class=o>[</span>Producer<span class=o>]</span> partitionid: 0<span class=p>;</span> offset:0, value: <span class=m>1629506387755300000</span>
</span></span><span class=line><span class=cl>2021/08/21 08:39:47 <span class=o>[</span>Producer<span class=o>]</span> partitionid: 1<span class=p>;</span> offset:0, value: <span class=m>1629506387969360200</span>
</span></span><span class=line><span class=cl>2021/08/21 08:39:48 <span class=o>[</span>Producer<span class=o>]</span> partitionid: 0<span class=p>;</span> offset:1, value: <span class=m>1629506387969760600</span>
</span></span><span class=line><span class=cl>2021/08/21 08:39:48 <span class=o>[</span>Producer<span class=o>]</span> partitionid: 1<span class=p>;</span> offset:1, value: <span class=m>1629506388011270100</span>
</span></span></code></pre></div><p>可以看到确实是轮询的在往两个分区里发送。</p><h3 id=2-源码分析>2. 源码分析</h3><p>在上一篇文章<a href=https://www.lixueduan.com/post/kafka/06-sarama-producer/ target=_blank rel="noopener noreffer">Kafka(Go)教程(六)&mdash;sarama 客户端 producer 源码分析</a> 中分析了 Producer 的具体流程，其中消息会经过 TopicProducer、PartitionProducer 最终通过 BrokerProudcer 到达 Kafka。</p><p>那么分区策略肯定是在到 PartitionProducer 之前执行了，于是找到对应源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>tp</span> <span class=o>*</span><span class=nx>topicProducer</span><span class=p>)</span> <span class=nf>dispatch</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>msg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>input</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>retries</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>tp</span><span class=p>.</span><span class=nf>partitionMessage</span><span class=p>(</span><span class=nx>msg</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>tp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>returnError</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>handler</span> <span class=o>:=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>handlers</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>handler</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>handler</span> <span class=p>=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nf>newPartitionProducer</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>,</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>tp</span><span class=p>.</span><span class=nx>handlers</span><span class=p>[</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span><span class=p>]</span> <span class=p>=</span> <span class=nx>handler</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>handler</span> <span class=o>&lt;-</span> <span class=nx>msg</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到,<code>tp.partitionMessage(msg)</code>这里就是在对消息进行分区处理：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>tp</span> <span class=o>*</span><span class=nx>topicProducer</span><span class=p>)</span> <span class=nf>partitionMessage</span><span class=p>(</span><span class=nx>msg</span> <span class=o>*</span><span class=nx>ProducerMessage</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>partitions</span> <span class=p>[]</span><span class=kt>int32</span>
</span></span><span class=line><span class=cl> 	<span class=c1>// 1.首先找到对应 Broker 的所有 partition
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>breaker</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>requiresConsistency</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ep</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>partitioner</span><span class=p>.(</span><span class=nx>DynamicConsistencyPartitioner</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>requiresConsistency</span> <span class=p>=</span> <span class=nx>ep</span><span class=p>.</span><span class=nf>MessageRequiresConsistency</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>requiresConsistency</span> <span class=p>=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>partitioner</span><span class=p>.</span><span class=nf>RequiresConsistency</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果是指定了需要一致性就调用就直接查询该Broker对应的所有分区(即使该分区当前不可用)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>requiresConsistency</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>partitions</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span> <span class=nf>Partitions</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 没有指定一致性则只会往当前可用的分区里发
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>partitions</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>parent</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>WritablePartitions</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Topic</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>numPartitions</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>partitions</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 3.最后调用配置的 partitioner 的 Partition 方法来确定分区
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>choice</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>partitioner</span><span class=p>.</span><span class=nf>Partition</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>numPartitions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span> <span class=p>=</span> <span class=nx>partitions</span><span class=p>[</span><span class=nx>choice</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>requiresConsistency 具体含义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// RequiresConsistency indicates to the user of the partitioner whether the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// mapping of key-&gt;partition is consistent or not. Specifically, if a
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// partitioner requires consistency then it must be allowed to choose from all
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// partitions (even ones known to be unavailable), and its choice must be
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// respected by the caller. The obvious example is the HashPartitioner.
</span></span></span></code></pre></div><p>即：<strong>key->partition 的映射是否需要一致</strong>,如果强制指定需要一致,那么就算这个分区不可用了也会把消息发给该分区以保证一致性,未指定则只会把消息投递给可用分区.当使用 Key-Ordering 策略的时候需要设置为 true 才能保证同一个 Key 被投递到同一个分区.</p><p>然后分区的选择逻辑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>choice</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>tp</span><span class=p>.</span><span class=nx>partitioner</span><span class=p>.</span><span class=nf>Partition</span><span class=p>(</span><span class=nx>msg</span><span class=p>,</span> <span class=nx>numPartitions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>msg</span><span class=p>.</span><span class=nx>Partition</span> <span class=p>=</span> <span class=nx>partitions</span><span class=p>[</span><span class=nx>choice</span><span class=p>]</span>
</span></span></code></pre></div><p>即 Partition 方法返回的只是一个 index，并不是具体的分区号。</p><p>到此分区逻辑就结束了，具体消息分发逻辑可以看上一篇文章<a href=https://www.lixueduan.com/post/kafka/06-sarama-producer/ target=_blank rel="noopener noreffer">Kafka(Go)教程(六)&mdash;sarama 客户端 producer 源码分析</a>。</p><blockquote><p>Kakfa 相关代码见 <a href=https://github.com/lixd/kafka-go-example target=_blank rel="noopener noreffer">Github</a></p></blockquote><h2 id=4-小结>4. 小结</h2><ul><li>Kafka的消息组织方式实际上是三级结构:主题-分区-消息。主题下的每条消息只会保存在某一一个分区中，而不会在多个分区中被保存多份。</li><li>分区是实现负载均衡以及高吞吐量的关键。</li><li>所谓分区策略，也就是决定生产者将消息发送到哪个分区的算法。Kafka为我们提供了默认分区策略，同时，它也支持你自定义分区策略。</li><li>比较常见的分区策略包括<strong>轮询策略</strong>、<strong>随机策略</strong>和<strong>按消息键保序策略</strong>。还有一种是基于地理位置的分区策略，但这种策略一-般只针对那些 大规模的Kafka集群，特别是跨城市、跨国家甚至是跨大洲的集群。</li></ul><h2 id=5-参考>5. 参考</h2><p><code>https://kafka.apache.org/documentation/#configuration</code></p><p><code>《Kafka 核心技术与实战》</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-08-20</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/kafka/07-partition/ data-title=Kafka(Go)教程(七)---生产者分区机制原理剖析及实战 data-hashtags=Kafka><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/kafka/07-partition/ data-hashtag=Kafka><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/kafka/07-partition/ data-title=Kafka(Go)教程(七)---生产者分区机制原理剖析及实战><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/kafka/07-partition/ data-title=Kafka(Go)教程(七)---生产者分区机制原理剖析及实战><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/kafka/07-partition/ data-title=Kafka(Go)教程(七)---生产者分区机制原理剖析及实战><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/kafka/>Kafka</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/kafka/06-sarama-producer/ class=prev rel=prev title="Kafka(Go)教程(六)---sarama 客户端 producer 源码分析"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Kafka(Go)教程(六)---sarama 客户端 producer 源码分析</a>
<a href=/posts/kafka/08-compression/ class=next rel=next title=Kafka(Go)教程(八)---生产者压缩算法详解及源码分析>Kafka(Go)教程(八)---生产者压缩算法详解及源码分析<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/lixd target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>