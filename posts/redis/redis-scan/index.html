<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Redis Scan 原理解析与踩坑 -</title><meta name=Description content="Redis Scan 命令原理解析与踩坑"><meta property="og:title" content="Redis Scan 原理解析与踩坑"><meta property="og:description" content="Redis Scan 命令原理解析与踩坑"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/redis/redis-scan/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-12T22:00:00+00:00"><meta property="article:modified_time" content="2021-11-12T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Redis Scan 原理解析与踩坑"><meta name=twitter:description content="Redis Scan 命令原理解析与踩坑"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/redis/redis-scan/><link rel=prev href=https://blog.yudlk.com/posts/go/sync-mutex/><link rel=next href=https://blog.yudlk.com/posts/distributed/raft/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Redis Scan 原理解析与踩坑","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/redis\/redis-scan\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Redis","wordcount":5272,"url":"https:\/\/blog.yudlk.com\/posts\/redis\/redis-scan\/","datePublished":"2021-11-12T22:00:00+00:00","dateModified":"2021-11-12T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Redis Scan 命令原理解析与踩坑"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Redis Scan 原理解析与踩坑</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/redis/><i class="far fa-folder fa-fw" aria-hidden=true></i>Redis</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-11-12>2021-11-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;5272 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;11 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-概述>1. 概述</a></li><li><a href=#2-scan-踩坑>2. Scan 踩坑</a></li><li><a href=#3-scan原理>3. Scan原理</a><ul><li><a href=#演示>演示</a></li><li><a href=#相关源码>相关源码</a></li><li><a href=#reverse-binary-iteration>reverse binary iteration</a></li><li><a href=#3-种情况>3 种情况</a></li><li><a href=#游标计算>游标计算</a></li><li><a href=#缩容处理>缩容处理</a></li></ul></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>主要分析了 Redis Scan 命令基本使用和具体实现，包括 Count 参数与 Scan 总耗时的关系，以及核心的逆二进制迭代算法分析。</p><h2 id=1-概述>1. 概述</h2><p>由于 Redis 是单线程在处理用户的命令，而 Keys 命令会一次性遍历所有 Key，于是在 命令执行过程中，无法执行其他命令。这就导致如果 Redis 中的 key 比较多，那么 Keys 命令执行时间就会比较长，从而阻塞 Redis。</p><p>所以很多教程都推荐使用 Scan 命令来代替 Keys，因为 Scan 可以限制每次遍历的 key 数量。</p><p>Keys 的缺点：</p><ul><li>1）没有limit，我们只能一次性获取所有符合条件的key，如果结果有上百万条，那么等待你的就是“无穷无尽”的字符串输出。</li><li>2）keys命令是遍历算法，时间复杂度是O(N)。如我们刚才所说，这个命令非常容易导致Redis服务卡顿。因此，我们要尽量避免在生产环境使用该命令。</li></ul><p>相比于keys命令，Scan命令有两个比较明显的优势：</p><ul><li>1）Scan命令的时间复杂度虽然也是O(N)，但它是分次进行的，不会阻塞线程。</li><li>2）Scan命令提供了 count 参数，可以控制每次遍历的集合数。</li></ul><blockquote><p>可以理解为 Scan 是渐进式的 Keys。</p></blockquote><p>Scan 命令语法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>SCAN cursor <span class=o>[</span>MATCH pattern<span class=o>]</span> <span class=o>[</span>COUNT count<span class=o>]</span>
</span></span></code></pre></div><ul><li>cursor - 游标。</li><li>pattern - 匹配的模式。</li><li>count - 指定每次遍历多少个集合。<ul><li>可以简单理解为每次遍历多少个元素</li><li>根据测试，推荐 Count大小为 1W。</li></ul></li></ul><p>Scan 返回值为数组，会返回一个游标+一系列的 Key</p><p>大致用法如下：</p><p>SCAN命令是基于游标的，每次调用后，都会返回一个游标，用于下一次迭代。当游标返回0时，表示迭代结束。</p><blockquote><p>第一次 Scan 时指定游标为 0，表示开启新的一轮迭代，然后 Scan 命令返回一个新的游标，作为第二次 Scan 时的游标值继续迭代，一直到 Scan 返回游标为0，表示本轮迭代结束。</p></blockquote><p>通过这个就可以看出，<strong>Scan 完成一次迭代，需要和 Redis 进行多次交互</strong>。</p><p>Scan 命令注意事项：</p><ul><li><strong>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</strong></li><li><strong>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</strong></li><li><strong>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;</strong></li></ul><h2 id=2-scan-踩坑>2. Scan 踩坑</h2><p>使用时遇到一个 特殊场景，<strong>跨区域远程连接 Redis 并进行模糊查询</strong>，扫描所有指定前缀的 Key。</p><p>最开始也没多想，直接就是开始 Scan，然后 Count 参数指定的是 1000。</p><blockquote><p>Redis 中大概几百万 Key。</p></blockquote><p>最后发现这个接口需要几十上百秒才返回。</p><p>什么原因呢？</p><p>Scan 命令中的 Count 指定一次扫描多少 Key，这里指定为 1000，几百万Key就需要几千次迭代，即和 Redis 交互几千次，然后因为是远程连接，网络延迟比较大，所以耗时特别长。</p><p>最后将 Count 参数调大后，减少了交互次数，就好多了。</p><blockquote><p>Count 参数越大，Redis 阻塞时间也会越长，需要取舍。</p><p>极限一点，<strong>Count 参数和总 Key 数一致时，Scan 命令就和 Keys 效果一样了</strong>。</p></blockquote><p>Count 大小和 Scan 总耗时的关系如下图：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/redis/scan/scan_time_vs_count.png data-srcset="https://github.com/barrypt/blog/raw/master/images/redis/scan/scan_time_vs_count.png, https://github.com/barrypt/blog/raw/master/images/redis/scan/scan_time_vs_count.png 1.5x, https://github.com/barrypt/blog/raw/master/images/redis/scan/scan_time_vs_count.png 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/redis/scan/scan_time_vs_count.png title=scan_time_vs_count></p><blockquote><p>图源：<a href=https://docs.keydb.dev/blog/2020/08/10/blog-post/ target=_blank rel="noopener noreffer">keydb</a></p></blockquote><p>可以发现 Count 越大，总耗时就越短，不过越后面提升就越不明显了。</p><blockquote><p>所以推荐的 Count 大小为 1W 左右。</p></blockquote><p>如果不考虑 Redis 的阻塞，其实 Keys 比 Scan 会快很多，毕竟一次性处理，省去了多余的交互。</p><h2 id=3-scan原理>3. Scan原理</h2><p>Redis使用了Hash表作为底层实现，原因不外乎高效且实现简单。类似于HashMap那样数组+链表的结构。其中第一维的数组大小为2n(n>=0)。每次扩容数组长度扩大一倍。</p><p>Scan命令就是对这个一维数组进行遍历。每次返回的游标值也都是这个数组的索引。Count 参数表示遍历多少个数组的元素，将这些元素下挂接的符合条件的结果都返回。因为每个元素下挂接的链表大小不同，所以每次返回的结果数量也就不同。</p><h3 id=演示>演示</h3><p>关于 Scan 命令的遍历顺序，我们可以用一个小栗子来具体看一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>127.0.0.1:6379&gt; keys *
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;db_number&#34;</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> <span class=s2>&#34;key1&#34;</span>
</span></span><span class=line><span class=cl>3<span class=o>)</span> <span class=s2>&#34;myKey&#34;</span>
</span></span><span class=line><span class=cl>127.0.0.1:6379&gt; scan <span class=m>0</span> MATCH * COUNT <span class=m>1</span>
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;2&#34;</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> 1<span class=o>)</span> <span class=s2>&#34;db_number&#34;</span>
</span></span><span class=line><span class=cl>127.0.0.1:6379&gt; scan <span class=m>2</span> MATCH * COUNT <span class=m>1</span>
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;1&#34;</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> 1<span class=o>)</span> <span class=s2>&#34;myKey&#34;</span>
</span></span><span class=line><span class=cl>127.0.0.1:6379&gt; scan <span class=m>1</span> MATCH * COUNT <span class=m>1</span>
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;3&#34;</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> 1<span class=o>)</span> <span class=s2>&#34;key1&#34;</span>
</span></span><span class=line><span class=cl>127.0.0.1:6379&gt; scan <span class=m>3</span> MATCH * COUNT <span class=m>1</span>
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;0&#34;</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> <span class=o>(</span>empty list or <span class=nb>set</span><span class=o>)</span>
</span></span></code></pre></div><p>如上所示，SCAN命令的遍历顺序是：0->2->1->3</p><p>这个顺序看起来有些奇怪，我们把它转换成二进制：00->10->01->11</p><p>可以看到每次这个序列是高位加1的。</p><blockquote><p>普通二进制的加法，是从右往左相加、进位。而这个序列是从左往右相加、进位的。</p></blockquote><p>相关源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>rev</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>v</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>rev</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span></code></pre></div><p>将游标倒置，加一后，再倒置，也就是我们所说的“高位加1”的操作。</p><h3 id=相关源码>相关源码</h3><p>先贴一下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>dictScan</span><span class=p>(</span><span class=n>dict</span> <span class=o>*</span><span class=n>d</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>v</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>dictScanFunction</span> <span class=o>*</span><span class=n>fn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=kt>void</span> <span class=o>*</span><span class=n>privdata</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dictht</span> <span class=o>*</span><span class=n>t0</span><span class=p>,</span> <span class=o>*</span><span class=n>t1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>dictEntry</span> <span class=o>*</span><span class=n>de</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>m0</span><span class=p>,</span> <span class=n>m1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>dictSize</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>dictIsRehashing</span><span class=p>(</span><span class=n>d</span><span class=p>))</span> <span class=p>{</span><span class=c1>//没有在做rehash，所以只有第一个表有数据的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>t0</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>m0</span> <span class=o>=</span> <span class=n>t0</span><span class=o>-&gt;</span><span class=n>sizemask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//槽位大小-1,因为大小总是2^N,所以sizemask的二进制总是后面都为1,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//比如16个slot的字典，sizemask为00001111
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Emit entries at cursor */</span>
</span></span><span class=line><span class=cl>        <span class=n>de</span> <span class=o>=</span> <span class=n>t0</span><span class=o>-&gt;</span><span class=n>table</span><span class=p>[</span><span class=n>v</span> <span class=o>&amp;</span> <span class=n>m0</span><span class=p>];</span><span class=c1>//找到当前这个槽位，然后处理数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=n>de</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>fn</span><span class=p>(</span><span class=n>privdata</span><span class=p>,</span> <span class=n>de</span><span class=p>);</span><span class=c1>//将这个slot的链表数据全部入队，准备返回给客户端。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>de</span> <span class=o>=</span> <span class=n>de</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t0</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>t1</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Make sure t0 is the smaller and t1 is the bigger table */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>t0</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>t1</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span> <span class=p>{</span><span class=c1>//将地位设置为
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>t0</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>t1</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>m0</span> <span class=o>=</span> <span class=n>t0</span><span class=o>-&gt;</span><span class=n>sizemask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>m1</span> <span class=o>=</span> <span class=n>t1</span><span class=o>-&gt;</span><span class=n>sizemask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Emit entries at cursor */</span>
</span></span><span class=line><span class=cl>        <span class=n>de</span> <span class=o>=</span> <span class=n>t0</span><span class=o>-&gt;</span><span class=n>table</span><span class=p>[</span><span class=n>v</span> <span class=o>&amp;</span> <span class=n>m0</span><span class=p>];</span><span class=c1>//处理小一点的表。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=n>de</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>fn</span><span class=p>(</span><span class=n>privdata</span><span class=p>,</span> <span class=n>de</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>de</span> <span class=o>=</span> <span class=n>de</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Iterate over indices in larger table that are the expansion
</span></span></span><span class=line><span class=cl><span class=cm>	         * of the index pointed to by the cursor in the smaller table */</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=p>{</span><span class=c1>//扫描大点的表里面的槽位，注意这里是个循环，会将小表没有覆盖的slot全部扫描一次的
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=cm>/* Emit entries at cursor */</span>
</span></span><span class=line><span class=cl>            <span class=n>de</span> <span class=o>=</span> <span class=n>t1</span><span class=o>-&gt;</span><span class=n>table</span><span class=p>[</span><span class=n>v</span> <span class=o>&amp;</span> <span class=n>m1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>de</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>fn</span><span class=p>(</span><span class=n>privdata</span><span class=p>,</span> <span class=n>de</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>de</span> <span class=o>=</span> <span class=n>de</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* Increment bits not covered by the smaller mask */</span>
</span></span><span class=line><span class=cl>            <span class=c1>//下面的意思是，还需要扩展小点的表，将其后缀固定，然后看高位可以怎么扩充。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//其实就是想扫描一下小表里面的元素可能会扩充到哪些地方，需要将那些地方处理一遍。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//后面的(v &amp; m0)是保留v在小表里面的后缀。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//((v | m0) + 1) &amp; ~m0) 是想给v的扩展部分的二进制位不断的加1，来造成高位不断增加的效果。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>v</span> <span class=o>=</span> <span class=p>(((</span><span class=n>v</span> <span class=o>|</span> <span class=n>m0</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>m0</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>v</span> <span class=o>&amp;</span> <span class=n>m0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* Continue while bits covered by mask difference is non-zero */</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>v</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>m0</span> <span class=o>^</span> <span class=n>m1</span><span class=p>));</span><span class=c1>//终止条件是 v的高位区别位没有1了，其实就是说到头了。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Set unmasked bits so incrementing the reversed cursor
</span></span></span><span class=line><span class=cl><span class=cm>	     * operates on the masked bits of the smaller table */</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span> <span class=o>|=</span> <span class=o>~</span><span class=n>m0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//按位取反，其实相当于v |= m0-1 , ~m0也就是11110000,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//这里相当于将v的不相干的高位全部置为1，待会再进行翻转二进制位，然后加1，然后再转回来
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Increment the reverse cursor */</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span> <span class=o>=</span> <span class=n>rev</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span> <span class=o>=</span> <span class=n>rev</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//下面将v的每一位倒过来再加1，再倒回去，这是什么意思呢，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//其实就是要将有效二进制位里面的高位第一个0位设置置为1，因为现在是0嘛
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=reverse-binary-iteration>reverse binary iteration</h3><p>Redis Scan 命令最终使用的是 reverse binary iteration 算法，大概可以翻译为 逆二进制迭代，具体算法细节可以看一下这个<a href=https://github.com/redis/redis/pull/579 target=_blank rel="noopener noreffer">Github 相关讨论</a></p><p>这个算法简单来说就是：</p><p><strong>依次从高位（有效位）开始，不断尝试将当前高位设置为1，然后变动更高位为不同组合，以此来扫描整个字典数组。</strong></p><p>其最大的优势在于，从高位扫描的时候，如果槽位是2^N个,扫描的临近的2个元素都是与2^(N-1)相关的就是说同模的，比如槽位8时，0%4 == 4%4， 1%4 == 5%4 ， 因此想到其实hash的时候，跟模是很相关的。</p><p>比如当整个字典大小只有4的时候，一个元素计算出的整数为5， 那么计算他的hash值需要模4，也就是hash(n) == 5%4 == 1 , 元素存放在第1个槽位中。当字典扩容的时候，字典大小变为8， 此时计算hash的时候为5%8 == 5 ， 该元素从1号slot迁移到了5号，1和5是对应的，我们称之为同模或者对应。</p><p><strong>同模的槽位的元素最容易出现合并或者拆分了。因此在迭代的时候只要及时的扫描这些相关的槽位，这样就不会造成大面积的重复扫描。</strong></p><h3 id=3-种情况>3 种情况</h3><p>迭代哈希表时，有以下三种情况：</p><ul><li>从迭代开始到结束，哈希表不 Rehash；</li><li>从迭代开始到结束，哈希表Rehash，但每次迭代，哈希表要么不开始 Rehash，要么已经结束 Rehash；</li><li>从一次迭代开始到结束，哈希表在一次或多次迭代中 Rehash。<ul><li>即再 Rehash 过程中，执行 Scan 命令，这时数据可能只迁移了一部分。</li></ul></li></ul><p>因此，游标的实现需要兼顾以上三种情况。上述三种情况下游标实现的要求如下：</p><p><strong>第一种情况比较简单</strong>。假设redis的hash表大小为4，第一个游标为0，读取第一个bucket的数据，然后游标返回2，下次读取bucket 2 ，依次遍历。</p><p><strong>第二种情况更复杂</strong>。假设redis的hash表大小为4，如果rehash后大小变成8。如果如上返回游标(即返回2)，则显示下图：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/redis/scan/redis-scale.png data-srcset="https://github.com/barrypt/blog/raw/master/images/redis/scan/redis-scale.png, https://github.com/barrypt/blog/raw/master/images/redis/scan/redis-scale.png 1.5x, https://github.com/barrypt/blog/raw/master/images/redis/scan/redis-scale.png 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/redis/scan/redis-scale.png title=redis-scale></p><p>假设bucket 0读取后返回到cursor 2，当客户端再次Scan cursor 2时，hash表已经被rehash，大小翻倍到8，redis计算一个key bucket如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span><span class=o>&amp;</span><span class=p>(</span><span class=n>size</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>即如果大小为4，hash(key)&11，如果大小为8，hash(key)&111。所以当size从4扩大到8时，2 号bucket中的原始数据会被分散到2 (010) 和 6 (110) 这两个 bucket中。</p><blockquote><p>从二进制来看，size为4时，在hash(key)之后，取低两位，即hash(key)&11，如果size为8，bucket位置为hash(key) & 111，即取低三个位。</p></blockquote><p>所以依旧不会出现漏掉数据的情况。</p><p><strong>第三种情况</strong>，如果返回游标2时正在进行rehash，则Hash表1的bucket 2中的一些数据可能已经rehash到了的Hash表2 的bucket[2]或bucket[6]，那么必须完全遍历 哈希表2的 bucket 2 和 6，否则可能会丢失数据。</p><blockquote><p>Redis 全局有两个Hash表，扩容时会渐进式的将表1的数据迁移到表2，查询时程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找。</p><p>详细信息可以查看：<a href=https://www.lixueduan.com/post/redis/04-global-datastructure/ target=_blank rel="noopener noreffer">Redis教程(四)&mdash;全局数据结构</a></p></blockquote><h3 id=游标计算>游标计算</h3><p>具体游标计算代码如下：</p><blockquote><p>Scan 命令中的游标，其实就是 Redis 内部的 bucket。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>v</span> <span class=o>|=</span> <span class=o>~</span><span class=n>m0</span><span class=p>;</span> <span class=c1>// 将游标v的unmarsked 比特都置为1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span> <span class=o>=</span> <span class=n>rev</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=c1>// 反转v
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span><span class=o>++</span><span class=p>;</span> <span class=c1>//这个是关键，加1，对一个数加1，其实就是将这个数的低位的连续1变为0，然后将最低的一个0变为1，其实就是将最低的一个0变为1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span> <span class=o>=</span> <span class=n>rev</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=c1>//再次反转，即得到下一个游标值
</span></span></span></code></pre></div><p>代码逻辑非常简单，计算过程如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/redis/scan/scan-rbi.png data-srcset="https://github.com/barrypt/blog/raw/master/images/redis/scan/scan-rbi.png, https://github.com/barrypt/blog/raw/master/images/redis/scan/scan-rbi.png 1.5x, https://github.com/barrypt/blog/raw/master/images/redis/scan/scan-rbi.png 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/redis/scan/scan-rbi.png title=scan-rbi></p><blockquote><p>图源：<a href=https://developpaper.com/redis-scan-command-principle/ target=_blank rel="noopener noreffer">developpaper</a></p></blockquote><ul><li>大小为 4 时，游标状态转换为 0-2-1-3。</li><li>当大小为 8 时，游标状态转换为 0-4-2-6-1-5-3-7。</li></ul><p>可以看出，当size由小变大时，所有原来的游标都能在大hashTable中找到对应的位置，并且顺序一致，不会重复读取，也不会被遗漏。</p><p><strong>总结一下：redis在rehash 扩容的时候，不会重复或者漏掉数据。但缩容，可能会造成重复但不会漏掉数据。</strong></p><h3 id=缩容处理>缩容处理</h3><p><strong>之所以会出现重复数据，其实就是为了保证缩容后数据不丢。</strong></p><p>假设当前 hash 大小为 8：</p><ul><li>1）第一次先遍历了 0 号槽，返回游标为 4；</li><li>2）准备遍历 4 号槽，然后此时发生了缩容，4 号槽的元素也进到 0 号槽了。</li><li>3）但是0 号槽之前已经被遍历过了，此时会丢数据吗？</li></ul><p>答案就在源码中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>do</span> <span class=p>{</span><span class=c1>//扫描大点的表里面的槽位，注意这里是个循环，会将小表没有覆盖的slot全部扫描一次的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* Emit entries at cursor */</span>
</span></span><span class=line><span class=cl>    <span class=n>de</span> <span class=o>=</span> <span class=n>t1</span><span class=o>-&gt;</span><span class=n>table</span><span class=p>[</span><span class=n>v</span> <span class=o>&amp;</span> <span class=n>m1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>de</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fn</span><span class=p>(</span><span class=n>privdata</span><span class=p>,</span> <span class=n>de</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>de</span> <span class=o>=</span> <span class=n>de</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Increment bits not covered by the smaller mask */</span>
</span></span><span class=line><span class=cl>    <span class=c1>//下面的意思是，还需要扩展小点的表，将其后缀固定，然后看高位可以怎么扩充。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//其实就是想扫描一下小表里面的元素可能会扩充到哪些地方，需要将那些地方处理一遍。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//后面的(v &amp; m0)是保留v在小表里面的后缀。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//((v | m0) + 1) &amp; ~m0) 是想给v的扩展部分的二进制位不断的加1，来造成高位不断增加的效果。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>v</span> <span class=o>=</span> <span class=p>(((</span><span class=n>v</span> <span class=o>|</span> <span class=n>m0</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>m0</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>v</span> <span class=o>&amp;</span> <span class=n>m0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Continue while bits covered by mask difference is non-zero */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>v</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>m0</span> <span class=o>^</span> <span class=n>m1</span><span class=p>));</span><span class=c1>//终止条件是 v的高位区别位没有1了，其实就是说到头了。
</span></span></span></code></pre></div><p>具体计算方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=n>v</span> <span class=o>=</span> <span class=p>(((</span><span class=n>v</span> <span class=o>|</span> <span class=n>m0</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>m0</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>v</span> <span class=o>&amp;</span> <span class=n>m0</span><span class=p>);</span>
</span></span></code></pre></div><p>右边的下半部分是v，左边的上半部分是v。 (v&m0) 取出v的低位，例如size=4时v&00000011</p><p>左半边(v|m0) + 1 将V 的低位设置为1，然后+1 将进位到v 的高位，再次&m0，V 的高位将被取出。</p><p>假设游标返回2并且正在rehashing，大小从4变为8，那么M0 = 00000011 v = 00000010</p><p>根据公式计算的下一个光标是 ((00000010 | 00000011) +1) & (11111111100) | (00000010 & 00000011) = (00000100) & (11111111100) | (00000000010) = (000000000110) 正好是 6。</p><h2 id=4-小结>4. 小结</h2><ul><li>Scan Count 参数限制的是遍历的 bucket 数，而不是限制的返回的元素个数<ul><li>由于不同 bucket 中的元素个数不同，其中满足条件的个数也不同，所以每次 Scan 返回元素也不一定相同</li></ul></li><li>Count 越大，Scan 总耗时越短，但是单次耗时越大，即阻塞Redis 时间边长<ul><li>推荐 Count 大小为 1W左右</li><li>当 Count = Redis Key 总数时，Scan 和 Keys 效果一致</li></ul></li><li>Scan 采用 逆二进制迭代法来计算游标，主要为了兼容Rehash的情况</li><li>Scan 为了兼容缩容后不漏掉数据，会出现重复遍历。<ul><li>即客户端需要做去重处理</li></ul></li></ul><p>核心就是 逆二进制迭代法，比较复杂，而且算法作者也没有具体证明，为什么这样就能实现，只是测试发现没有问题，各种情况都能兼容。</p><p>具体算法细节可以看一下这个<a href=https://github.com/redis/redis/pull/579 target=_blank rel="noopener noreffer">Github 相关讨论</a></p><blockquote><p><strong>antirez</strong>: Hello @pietern! I’m starting to re-evaluate the idea of an iterator for Redis, and the first item in this task is definitely to understand better your pull request and implementation. I don’t understand exactly the implementation with the reversed bits counter…
I wonder if there is a way to make that more intuitive… so investing some more time into this, and if I fail I’ll just merge your code trying to augment it with more comments…
Hard to explain but awesome.<br><strong>pietern</strong>： Although I don’t have a formal proof for these guarantees, I’m reasonably confident they hold. I worked through every hash table state (stable, grow, shrink) and it appears to work everywhere by means of the reverse binary iteration (for lack of a better word).</p></blockquote><p>所以只能说这个算法很巧妙。就像卡马克快速逆平方根算法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>float</span> <span class=nf>Q_rsqrt</span><span class=p>(</span> <span class=kt>float</span> <span class=n>number</span> <span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>i</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>x2</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>float</span> <span class=n>threehalfs</span> <span class=o>=</span> <span class=mf>1.5F</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x2</span> <span class=o>=</span> <span class=n>number</span> <span class=o>*</span> <span class=mf>0.5F</span> <span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=n>number</span> <span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=o>*</span> <span class=p>(</span> <span class=kt>long</span> <span class=o>*</span> <span class=p>)</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>;</span> <span class=c1>// evil floating point bit level hacking 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>i</span> <span class=o>=</span> <span class=mh>0x5f3759df</span> <span class=o>-</span> <span class=p>(</span> <span class=n>i</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=p>);</span> <span class=c1>// what the fuck? 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>y</span> <span class=o>=</span> <span class=o>*</span> <span class=p>(</span> <span class=kt>float</span> <span class=o>*</span> <span class=p>)</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=n>y</span> <span class=o>*</span> <span class=p>(</span> <span class=n>threehalfs</span> <span class=o>-</span> <span class=p>(</span> <span class=n>x2</span> <span class=o>*</span> <span class=n>y</span> <span class=o>*</span> <span class=n>y</span> <span class=p>)</span> <span class=p>);</span> <span class=c1>// 1st iteration 
</span></span></span><span class=line><span class=cl><span class=c1>//  y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>y</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中的这个<code>0x5f3759df</code>数就很巧妙。</p><h2 id=5-参考>5. 参考</h2><p><code>http://antirez.com/news/63</code></p><p><code>https://developpaper.com/redis-scan-command-principle/</code></p><p><code>https://www.cnblogs.com/thrillerz/p/4527510.html</code></p><p><code>https://www.jianshu.com/p/abe5d8ae4852</code></p><p><code>https://zhuanlan.zhihu.com/p/46353221</code></p><p><code>https://docs.keydb.dev/blog/2020/08/10/blog-post/</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-11-12</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/redis/redis-scan/ data-title="Redis Scan 原理解析与踩坑" data-hashtags=Redis><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/redis/redis-scan/ data-hashtag=Redis><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/redis/redis-scan/ data-title="Redis Scan 原理解析与踩坑"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/redis/redis-scan/ data-title="Redis Scan 原理解析与踩坑"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/redis/redis-scan/ data-title="Redis Scan 原理解析与踩坑"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/redis/>Redis</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/go/sync-mutex/ class=prev rel=prev title="Go语言之sync.Mutex 源码分析"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Go语言之sync.Mutex 源码分析</a>
<a href=/posts/distributed/raft/ class=next rel=next title="Raft 算法概述">Raft 算法概述<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>