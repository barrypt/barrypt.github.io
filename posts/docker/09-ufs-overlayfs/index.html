<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Docker教程(九)---如何使用UFS(overlayfs)实现rootfs -</title><meta name=Description content="Union File System中的 overlayfs 演示，以及docker 通过 overlayfs构建 rootfs流程分析"><meta property="og:title" content="Docker教程(九)---如何使用UFS(overlayfs)实现rootfs"><meta property="og:description" content="Union File System中的 overlayfs 演示，以及docker 通过 overlayfs构建 rootfs流程分析"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/docker/09-ufs-overlayfs/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-19T22:00:00+00:00"><meta property="article:modified_time" content="2022-03-19T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Docker教程(九)---如何使用UFS(overlayfs)实现rootfs"><meta name=twitter:description content="Union File System中的 overlayfs 演示，以及docker 通过 overlayfs构建 rootfs流程分析"><meta name=application-name content="指月小筑"><meta name=apple-mobile-web-app-title content="指月小筑"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/docker/09-ufs-overlayfs/><link rel=prev href=https://blog.yudlk.com/posts/go/chan/><link rel=next href=https://blog.yudlk.com/posts/docker/10-bridge-network/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Docker教程(九)---如何使用UFS(overlayfs)实现rootfs","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/docker\/09-ufs-overlayfs\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Docker","wordcount":5483,"url":"https:\/\/blog.yudlk.com\/posts\/docker\/09-ufs-overlayfs\/","datePublished":"2022-03-19T22:00:00+00:00","dateModified":"2022-03-19T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Union File System中的 overlayfs 演示，以及docker 通过 overlayfs构建 rootfs流程分析"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=指月小筑>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=指月小筑>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Docker教程(九)---如何使用UFS(overlayfs)实现rootfs</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/lixd title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/docker/><i class="far fa-folder fa-fw" aria-hidden=true></i>Docker</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-03-19>2022-03-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;5483 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;11 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-概述>1. 概述</a><ul><li><a href=#union-file-system>Union File System</a></li><li><a href=#常见实现>常见实现</a></li></ul></li><li><a href=#2-overlayfs-演示>2. overlayfs 演示</a><ul><li><a href=#环境准备>环境准备</a></li><li><a href=#修改文件>修改文件</a></li><li><a href=#删除文件>删除文件</a></li><li><a href=#添加文件>添加文件</a></li></ul></li><li><a href=#3-docker-是如何使用-overlay-的>3. docker 是如何使用 overlay 的？</a><ul><li><a href=#大致流程>大致流程</a></li><li><a href=#具体分析>具体分析</a></li></ul></li><li><a href=#4-参考>4. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要介绍了 Docker 的另一个核心技术：Union File System。主要包括对 overlayfs 的演示，以及分析 docker 是如何借助 ufs 实现容器 rootfs 的。</p><blockquote><p>跟着《自己动手写 docker》从零开始实现了一个简易版的 docker，主要用于加深对 docker 的理解。</p><p>源码及相关教程见 <a href=https://github.com/lixd/mydocker target=_blank rel="noopener noreffer">Github</a>。</p></blockquote><h2 id=1-概述>1. 概述</h2><h3 id=union-file-system>Union File System</h3><p>Union File System ，简称 UnionFS 是一种为 Linux FreeBSD NetBSD 操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。</p><p>它使用 branch 不同文件系统的文件和目录“透明地”覆盖，形成 个单一一致的文件系统。这些branches或者是read-only或者是read-write的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。看起来这个虚拟后的联合文件系统是可以对任何文件进行操作的，但是其实它并没有改变原来的文件，这是因为unionfs用到了一个重要的资管管理技术叫写时复制。</p><p><strong>写时复制（copy-on-write，下文简称CoW）</strong>，也叫隐式共享，是一种对可修改资源实现高效复制的资源管理技术。它的思想是，如果一个资源是重复的，但没有任何修改，这时候并不需要立即创建一个新的资源；这个资源可以被新旧实例共享。创建新资源发生在第一次写操作，也就是对资源进行修改的时候。通过这种资源共享的方式，可以显著地减少未修改资源复制带来的消耗，但是也会在进行资源修改的时候增减小部分的开销。</p><p><strong>举个例子</strong></p><p>假设我们存在2个目录X,Y，里面分别有A，B文件，那么UFS的作用就是将这两个目录合并，并且重新挂载的Z上,这样在Z目录上就可以同时看到A和B文件。这就是联合文件系统，目的就是<strong>将多个文件联合在一起成为一个统一的视图</strong>。</p><p>然后我们在Z目录中删除B文件，同时，在A文件中增加一些内容，如添加Hello字符串。此时可以发现，X内的A文件新增了Hello,并且新增了一条B被删除的记录，但是Y中的B并没有任何变化。这是UFS的一个重要特性。<strong>在所有的联合起来的目录中，只有第一个目录是有写的权限</strong>，即我们不管如何的去对Z进行修改操作，都只能对第一个联合进来的X修改，对Y是没有权限修改的。</p><p>但是如果我们在Z中对Y中的文件进行了修改，它虽然没有权限去修改Y目录中的文件，但是它会在第一层目录添加一个记录来记录更改内容。</p><p>Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。比如，我现在有两个目录 A 和 B，它们分别有两个文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ tree
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── A
</span></span><span class=line><span class=cl>│  ├── a
</span></span><span class=line><span class=cl>│  └── x
</span></span><span class=line><span class=cl>└── B
</span></span><span class=line><span class=cl>  ├── b
</span></span><span class=line><span class=cl>  └── x
</span></span></code></pre></div><p>然后，我使用联合挂载的方式，将这两个目录挂载到一个公共的目录 C 上：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir C
</span></span><span class=line><span class=cl>$ mount -t aufs -o <span class=nv>dirs</span><span class=o>=</span>./A:./B none ./C
</span></span></code></pre></div><p>这时，我再查看目录 C 的内容，就能看到目录 A 和 B 下的文件被合并到了一起：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ tree ./C
</span></span><span class=line><span class=cl>./C
</span></span><span class=line><span class=cl>├── a
</span></span><span class=line><span class=cl>├── b
</span></span><span class=line><span class=cl>└── x
</span></span></code></pre></div><p>可以看到，在这个合并后的目录 C 里，有 a、b、x 三个文件，并且 x 文件只有一份。这，就是“合并”的含义。此外，如果你在目录 C 里对 a、b、x 文件做修改，这些修改也会在对应的目录 A、B 中生效。</p><h3 id=常见实现>常见实现</h3><h4 id=aufs>AUFS</h4><p>AuFS 的全称是 Another UnionFS，后改名为 Alternative UnionFS，再后来干脆改名叫作 Advance UnionFS。AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS的一些实现已经被纳入UnionFS 2.x版本。</p><p>AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，包括 <code>aufs</code>、<code>devicemapper</code>、<code>overlay2</code>、<code>zfs</code> 和 <code>vfs</code> 等等，在最新的 Docker 中，<code>overlay2</code> 取代了 <code>aufs</code> 成为了推荐的存储驱动，但是在没有 <code>overlay2</code> 驱动的机器上仍然会使用 <code>aufs</code> 作为 Docker 的默认驱动。</p><h4 id=overlayfs>overlayfs</h4><p>Overlayfs 是一种类似 aufs 的一种堆叠文件系统，于 2014 年正式合入 Linux-3.18 主线内核，目前其功能已经基本稳定（虽然还存在一些特性尚未实现）且被逐渐推广，特别在容器技术中更是势头难挡。</p><p>Overlayfs 是一种堆叠文件系统，它依赖并建立在其它的文件系统之上（例如 ext4fs 和 xfs 等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。</p><p>简单的总结为以下3点：</p><p>（1）上下层同名目录合并；</p><p>（2）上下层同名文件覆盖；</p><p>（3）lower dir文件写时拷贝。</p><p>这三点对用户都是不感知的。</p><p>假设我们有 dir1 和 dir2 两个目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>  dir1                    dir2
</span></span><span class=line><span class=cl>    /                       /
</span></span><span class=line><span class=cl>      a                       a
</span></span><span class=line><span class=cl>      b                       c
</span></span></code></pre></div><p>然后我们可以把 dir1 和 dir2 挂载到 dir3上，就像这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl> dir3
</span></span><span class=line><span class=cl>    /
</span></span><span class=line><span class=cl>      a
</span></span><span class=line><span class=cl>      b
</span></span><span class=line><span class=cl>      c
</span></span></code></pre></div><p>需要注意的是：在 overlay 中 dir1 和 dir2 是有上下关系的。lower 和 upper 目录不是完全一致，有一些区别，具体见下一节。</p><h2 id=2-overlayfs-演示>2. overlayfs 演示</h2><h3 id=环境准备>环境准备</h3><p>具体演示如下：</p><p>创建一个如下结构的目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── lower
</span></span><span class=line><span class=cl>│   ├── a
</span></span><span class=line><span class=cl>│   └── c
</span></span><span class=line><span class=cl>├── merged
</span></span><span class=line><span class=cl>├── upper
</span></span><span class=line><span class=cl>│   ├── a
</span></span><span class=line><span class=cl>│   └── b
</span></span><span class=line><span class=cl>└── work
</span></span></code></pre></div><p>具体命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir ./<span class=o>{</span>merged,work,upper,lower<span class=o>}</span>
</span></span><span class=line><span class=cl>$ touch ./upper/<span class=o>{</span>a,b<span class=o>}</span>
</span></span><span class=line><span class=cl>$ touch ./lower/<span class=o>{</span>a,c<span class=o>}</span>
</span></span></code></pre></div><p>然后进行 mount 操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># -t overlay 表示文件系统为 overlay</span>
</span></span><span class=line><span class=cl><span class=c1># -o lowerdir=./lower,upperdir=./upper,workdir=./work 指定 lowerdir、upperdir以及 workdir这3个目录。</span>
</span></span><span class=line><span class=cl><span class=c1># 其中 lowerdir 是自读的，upperdir是可读写的，</span>
</span></span><span class=line><span class=cl>$ sudo mount <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            -t overlay <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            overlay <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            -o <span class=nv>lowerdir</span><span class=o>=</span>./lower,upperdir<span class=o>=</span>./upper,workdir<span class=o>=</span>./work <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            ./merged
</span></span></code></pre></div><p>此时目录结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── lower
</span></span><span class=line><span class=cl>│   ├── a
</span></span><span class=line><span class=cl>│   └── c
</span></span><span class=line><span class=cl>├── merged
</span></span><span class=line><span class=cl>│   ├── a
</span></span><span class=line><span class=cl>│   ├── b
</span></span><span class=line><span class=cl>│   └── c
</span></span><span class=line><span class=cl>├── upper
</span></span><span class=line><span class=cl>│   ├── a
</span></span><span class=line><span class=cl>│   └── b
</span></span><span class=line><span class=cl>└── work
</span></span><span class=line><span class=cl>    └── work
</span></span></code></pre></div><p>可以看到，merged 目录已经可以同时看到 lower和upper中的文件了，而由于文件a同时存在于lower和upper中，因此被覆盖了，只显示了一个a。</p><h3 id=修改文件>修改文件</h3><p>虽然 lower 和 upper 中的文件都出现在了 merged 目录，但是二者还是有区别的。</p><p>lower 为底层目录，只提供数据，不能写。</p><p>upper 为上层目录，是可读写的。</p><p>测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 分别对 merged 中的文件b和c写入数据</span>
</span></span><span class=line><span class=cl><span class=c1># 其中文件 c 来自 lower，b来自 upper</span>
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=s2>&#34;will-persist&#34;</span>  &gt; ./merged/b
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=s2>&#34;wont-persist&#34;</span>  &gt; ./merged/c
</span></span></code></pre></div><p>修改后从 merged 这个视图进行查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat ./merged/b
</span></span><span class=line><span class=cl>will-persist
</span></span><span class=line><span class=cl>$ cat ./merged/c
</span></span><span class=line><span class=cl>wont-persist
</span></span></code></pre></div><p>可以发现，好像两个文件都被更新了，难道上面的结论是错的？</p><p>再从 upper 和 lower 视角进行查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat ./upper/b
</span></span><span class=line><span class=cl>will-persist
</span></span><span class=line><span class=cl>$ cat ./lower/c
</span></span><span class=line><span class=cl><span class=o>(</span>empty<span class=o>)</span>
</span></span></code></pre></div><p>可以发现 lower 中的文件 c 确实没有被改变。</p><p>那么 merged 中查看的时候，文件 c 为什么有数据呢？</p><p>由于 lower 是不可写的，因此采用了 CoW 技术，在对 c 进行修改时，复制了一份数据到 overlay 的 upperdir，即这里的 upper 目录，进入 upper 目录查看是否存在 c 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ upper<span class=o>]</span>$ ll
</span></span><span class=line><span class=cl>total <span class=m>8</span>
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> root root  <span class=m>0</span> Jan <span class=m>18</span> 18:50 a
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> root root <span class=m>13</span> Jan <span class=m>18</span> 19:10 b
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> root root <span class=m>13</span> Jan <span class=m>18</span> 19:10 c
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ upper<span class=o>]</span>$ cat c 
</span></span><span class=line><span class=cl>wont-persist
</span></span></code></pre></div><blockquote><p>从 lower copy 到 upper，也叫做 copy_up</p></blockquote><h3 id=删除文件>删除文件</h3><p>首先往 lower 中增加文件 f</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ lower<span class=o>]</span>$ <span class=nb>echo</span> fff &gt;&gt; f
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ lower<span class=o>]</span>$ ls ../merged/
</span></span><span class=line><span class=cl>f
</span></span></code></pre></div><p>果然 lower 中添加后，merged 中也能直接看到了，然后再 merged 中去删除文件 f：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ lower<span class=o>]</span>$ <span class=nb>cd</span> ../merged/
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ rm -rf f
</span></span><span class=line><span class=cl><span class=c1># merged 中删除后 lower 中文件还在</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ ls ../lower/
</span></span><span class=line><span class=cl>a  c  e  f
</span></span><span class=line><span class=cl><span class=c1># 而 upper 中出现了一个大小为0的c类型文件f</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span><span class=c1># ls -l ../upper/</span>
</span></span><span class=line><span class=cl>total <span class=m>0</span>
</span></span><span class=line><span class=cl>c--------- <span class=m>1</span> root root 0, <span class=m>0</span> Jan <span class=m>18</span> 19:28 f
</span></span></code></pre></div><p>可以发现，overlay 中删除 lower 中的文件，其实也是在 upper 中创建一个标记，表示这个文件已经被删除了，测试一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ rm -rf ../upper/f
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ ls
</span></span><span class=line><span class=cl>f
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ cat f 
</span></span><span class=line><span class=cl>fff
</span></span></code></pre></div><p>把 upper 中的大小为0的f文件给删掉后，merged中又可以看到lower中 f 了，而且内容也是一样的。</p><p>说明 overlay 中的删除其实是<strong>标记删除</strong>。再 upper 中添加一个删除标记，这样该文件就被隐藏了，从merged中看到的效果就是文件被删除了。</p><blockquote><p>删除文件或文件夹时，会在 upper 中添加一个同名的 <code>c</code> 标识的文件，这个文件叫 <code>whiteout</code> 文件。当扫描到此文件时，会忽略此文件名。</p></blockquote><h3 id=添加文件>添加文件</h3><p>最后再试一下添加文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 首先在 merged 中创建文件 g</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ <span class=nb>echo</span> ggg &gt;&gt; g
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ ls
</span></span><span class=line><span class=cl>g
</span></span><span class=line><span class=cl><span class=c1># 然后查看 upper，发现也存在文件 g</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ ls ../upper/
</span></span><span class=line><span class=cl>g
</span></span><span class=line><span class=cl><span class=c1># 在查看内容，发送是一样的</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ cat ../upper/g
</span></span><span class=line><span class=cl>ggg
</span></span></code></pre></div><p>说明 overlay 中添加文件其实就是在 upper 中添加文件。</p><p>测试一下删除会怎么样呢：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ rm -rf ../upper/g
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ merged<span class=o>]</span>$ ls
</span></span><span class=line><span class=cl>f
</span></span></code></pre></div><p>把 upper 中的文件 g 删除了，果然 merged 中的文件 g 也消失了。</p><h2 id=3-docker-是如何使用-overlay-的>3. docker 是如何使用 overlay 的？</h2><h3 id=大致流程>大致流程</h3><p>每一个Docker image都是由一系列的read-only layers组成：</p><ul><li>image layers的内容都存储在Docker hosts filesystem的/var/lib/docker/aufs/diff目录下</li><li>而/var/lib/docker/aufs/layers目录则存储着image layer如何堆栈这些layer的metadata。</li></ul><p>docker支持多种graphDriver，包括vfs、devicemapper、overlay、overlay2、aufs等等，其中最常用的就是aufs了，但随着linux内核3.18把overlay纳入其中，overlay的地位变得更重。</p><p><code>docker info</code>命令可以查看docker的文件系统。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker info 
</span></span><span class=line><span class=cl><span class=c1># ...</span>
</span></span><span class=line><span class=cl> Storage Driver: overlay2
</span></span><span class=line><span class=cl><span class=c1>#...</span>
</span></span></code></pre></div><p>比如这里用的就是 overlay2.</p><p>例如，假设我们有一个由两层组成的容器镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>   layer1:                 layer2:
</span></span><span class=line><span class=cl>    /etc                    /bin
</span></span><span class=line><span class=cl>      myconf.ini              my-binary
</span></span></code></pre></div><p>然后，在容器运行时将把这两层作为 lower 目录，创建一个空<code>upper</code>目录，并将其挂载到某个地方：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>sudo mount <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            -t overlay <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            overlay <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            -o <span class=nv>lowerdir</span><span class=o>=</span>/layer1:/layer2,upperdir<span class=o>=</span>/upper,workdir<span class=o>=</span>/work <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>            /merged
</span></span></code></pre></div><p>最后将<code>/merged</code>用作容器的 rootfs。</p><p>这样，容器中的文件系统就完成了。</p><h3 id=具体分析>具体分析</h3><p><strong>以构建镜像方式演示以下 docker 是如何使用 overlayfs 的。</strong></p><p>先拉一下 Ubuntu:20.04 的镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker pull ubuntu:20.04
</span></span><span class=line><span class=cl>20.04: Pulling from library/ubuntu
</span></span><span class=line><span class=cl>Digest: sha256:626ffe58f6e7566e00254b638eb7e0f3b11d4da9675088f4781a50ae288f3322
</span></span><span class=line><span class=cl>Status: Downloaded newer image <span class=k>for</span> ubuntu:20.04
</span></span><span class=line><span class=cl>docker.io/library/ubuntu:20.04
</span></span></code></pre></div><p>然后写个简单的 Dockerfile ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl> FROM ubuntu:20.04<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span> RUN <span class=nb>echo</span> <span class=s2>&#34;Hello world&#34;</span> &gt; /tmp/newfile<span class=err>
</span></span></span></code></pre></div><p>开始构建：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build -t hello-ubuntu .
</span></span><span class=line><span class=cl>Sending build context to Docker daemon  2.048kB
</span></span><span class=line><span class=cl>Step 1/2 : FROM ubuntu:20.04
</span></span><span class=line><span class=cl> ---&gt; ba6acccedd29
</span></span><span class=line><span class=cl>Step 2/2 : RUN <span class=nb>echo</span> <span class=s2>&#34;Hello world&#34;</span> &gt; /tmp/newfile
</span></span><span class=line><span class=cl> ---&gt; Running in ee79bb9802d0
</span></span><span class=line><span class=cl>Removing intermediate container ee79bb9802d0
</span></span><span class=line><span class=cl> ---&gt; 290d8cc1f75a
</span></span><span class=line><span class=cl>Successfully built 290d8cc1f75a
</span></span><span class=line><span class=cl>Successfully tagged hello-ubuntu:latest
</span></span></code></pre></div><p>查看构建好的镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker images
</span></span><span class=line><span class=cl>REPOSITORY                                             TAG            IMAGE ID       CREATED          SIZE
</span></span><span class=line><span class=cl>hello-ubuntu                                           latest         290d8cc1f75a   <span class=m>13</span> minutes ago   72.8MB
</span></span><span class=line><span class=cl>ubuntu                                                 20.04          ba6acccedd29   <span class=m>3</span> months ago     72.8MB
</span></span></code></pre></div><p>使用<code>docker history</code>命令，查看镜像使用的 image layer 情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker <span class=nb>history</span> hello-ubuntu
</span></span><span class=line><span class=cl>IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT
</span></span><span class=line><span class=cl>290d8cc1f75a   <span class=m>22</span> seconds ago   /bin/sh -c <span class=nb>echo</span> <span class=s2>&#34;Hello world&#34;</span> &gt; /tmp/newfile    12B       
</span></span><span class=line><span class=cl>ba6acccedd29   <span class=m>3</span> months ago     /bin/sh -c <span class=c1>#(nop)  CMD [&#34;bash&#34;]                 0B        </span>
</span></span><span class=line><span class=cl>&lt;missing&gt;      <span class=m>3</span> months ago     /bin/sh -c <span class=c1>#(nop) ADD file:5d68d27cc15a80653…   72.8MB</span>
</span></span></code></pre></div><blockquote><p>missing ”标记的 layer ，是自 Docker 1.10 之后，一个镜像的 image layer image history 数据都存储在 个文件中导致的，这是 Docker 官方认为 正常行为。</p></blockquote><p>可以看到，290d8cc1f75a 这一层在最上面，只用了 12Bytes，而下面的两层都是共享的，这也证明了AUFS是如何高效使用磁盘空间的。</p><p>然后去找一下具体的文件：</p><p>docker默认的存储目录是<code>/var/lib/docker</code>,具体如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ docker<span class=o>]</span>$ ls -al
</span></span><span class=line><span class=cl>total <span class=m>24</span>
</span></span><span class=line><span class=cl>drwx--x--x  <span class=m>13</span> root root   <span class=m>167</span> Jul <span class=m>16</span>  <span class=m>2021</span> .
</span></span><span class=line><span class=cl>drwxr-xr-x. <span class=m>42</span> root root  <span class=m>4096</span> Oct <span class=m>13</span> 15:07 ..
</span></span><span class=line><span class=cl>drwx--x--x   <span class=m>4</span> root root   <span class=m>120</span> May <span class=m>24</span>  <span class=m>2021</span> buildkit
</span></span><span class=line><span class=cl>drwx-----x   <span class=m>7</span> root root  <span class=m>4096</span> Jan <span class=m>17</span> 20:25 containers
</span></span><span class=line><span class=cl>drwx------   <span class=m>3</span> root root    <span class=m>22</span> May <span class=m>24</span>  <span class=m>2021</span> image
</span></span><span class=line><span class=cl>drwxr-x---   <span class=m>3</span> root root    <span class=m>19</span> May <span class=m>24</span>  <span class=m>2021</span> network
</span></span><span class=line><span class=cl>drwx-----x  <span class=m>53</span> root root <span class=m>12288</span> Jan <span class=m>17</span> 20:25 overlay2
</span></span><span class=line><span class=cl>drwx------   <span class=m>4</span> root root    <span class=m>32</span> May <span class=m>24</span>  <span class=m>2021</span> plugins
</span></span><span class=line><span class=cl>drwx------   <span class=m>2</span> root root     <span class=m>6</span> Jul <span class=m>16</span>  <span class=m>2021</span> runtimes
</span></span><span class=line><span class=cl>drwx------   <span class=m>2</span> root root     <span class=m>6</span> May <span class=m>24</span>  <span class=m>2021</span> swarm
</span></span><span class=line><span class=cl>drwx------   <span class=m>2</span> root root     <span class=m>6</span> Jan <span class=m>17</span> 20:25 tmp
</span></span><span class=line><span class=cl>drwx------   <span class=m>2</span> root root     <span class=m>6</span> May <span class=m>24</span>  <span class=m>2021</span> trust
</span></span><span class=line><span class=cl>drwx-----x   <span class=m>5</span> root root   <span class=m>266</span> Dec <span class=m>29</span> 14:31 volumes
</span></span></code></pre></div><p>在这里，我们只关心<code>image</code>和<code>overlay2</code>就足够了。</p><ul><li>image：镜像相关</li><li>overlay2：docker 文件所在目录，也可能不叫这个名字，具体和文件系统有关，比如可能是 aufs 等。</li></ul><p>先看 <code>image</code>目录：</p><p>docker会在<code>/var/lib/docker/image</code>目录下按每个存储驱动的名字创建一个目录，如这里的<code>overlay2</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ docker<span class=o>]</span>$ <span class=nb>cd</span> image/
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ image<span class=o>]</span>$ ls
</span></span><span class=line><span class=cl>overlay2
</span></span><span class=line><span class=cl><span class=c1># 看下里面有哪些文件</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ image<span class=o>]</span>$ tree -L <span class=m>2</span> overlay2/
</span></span><span class=line><span class=cl>overlay2/
</span></span><span class=line><span class=cl>├── distribution
</span></span><span class=line><span class=cl>│   ├── diffid-by-digest
</span></span><span class=line><span class=cl>│   └── v2metadata-by-diffid
</span></span><span class=line><span class=cl>├── imagedb
</span></span><span class=line><span class=cl>│   ├── content
</span></span><span class=line><span class=cl>│   └── metadata
</span></span><span class=line><span class=cl>├── layerdb
</span></span><span class=line><span class=cl>│   ├── mounts
</span></span><span class=line><span class=cl>│   ├── sha256
</span></span><span class=line><span class=cl>│   └── tmp
</span></span><span class=line><span class=cl>└── repositories.json
</span></span></code></pre></div><p>这里的关键地方是<code>imagedb</code>和<code>layerdb</code>目录，看这个目录名字，很明显就是专门用来存储元数据的地方。</p><ul><li>layerdb：docker image layer 信息</li><li>imagedb：docker image 信息</li></ul><p>因为 docker image 是由 layer 组成的，而 layer 也已复用，所以分成了 layerdb 和 imagedb。</p><p>先去 imagedb 看下刚才构建的镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$  <span class=nb>cd</span> overlay2/imagedb/content/sha256
</span></span><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ sha256<span class=o>]</span><span class=c1># ls</span>
</span></span><span class=line><span class=cl>0c7ea9afc0b18a08b8d6a660e089da618541f9aa81ac760bd905bb802b05d8d5  61ad638751093d94c7878b17eee862348aa9fc5b705419b805f506d51b9882e7 
</span></span><span class=line><span class=cl>// .... 省略
</span></span><span class=line><span class=cl>b20b605ed599feb3c4757d716a27b6d3c689637430e18d823391e56aa61ecf01
</span></span><span class=line><span class=cl>60d84e80b842651a56cd4187669dc1efb5b1fe86b90f69ed24b52c37ba110aba  ba6acccedd2923aee4c2acc6a23780b14ed4b8a5fa4e14e252a23b846df9b6c1
</span></span></code></pre></div><p>可以看到，都是 64 位的ID，这些就是具体镜像信息，刚才构建的镜像ID为<code>290d8cc1f75a</code>,所以就找<code>290d8cc1f75a</code>开头的文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ sha256<span class=o>]</span>$ cat 290d8cc1f75a4e230d645bf03c49bbb826f17d1025ec91a1eb115012b32d1ff8 
</span></span><span class=line><span class=cl><span class=o>{</span><span class=s2>&#34;architecture&#34;</span>:<span class=s2>&#34;amd64&#34;</span>,<span class=s2>&#34;config&#34;</span>:<span class=o>{</span><span class=s2>&#34;Hostname&#34;</span>:<span class=s2>&#34;&#34;</span>,<span class=s2>&#34;Domainname&#34;</span>:<span class=s2>&#34;&#34;</span>,<span class=s2>&#34;User&#34;</span>:<span class=s2>&#34;&#34;</span>,<span class=s2>&#34;AttachStdin&#34;</span>:false,<span class=s2>&#34;AttachStdout&#34;</span>:false,<span class=s2>&#34;AttachStderr&#34;</span>:false,<span class=s2>&#34;Tty&#34;</span>:false,<span class=s2>&#34;OpenStdin&#34;</span>:false,<span class=s2>&#34;StdinOnce&#34;</span>:false,<span class=s2>&#34;Env&#34;</span>:<span class=o>[</span><span class=s2>&#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;</span><span class=o>]</span>,<span class=s2>&#34;Cmd&#34;</span>:<span class=o>[</span><span class=s2>&#34;bash&#34;</span><span class=o>]</span>,<span class=s2>&#34;Image&#34;</span>:<span class=s2>&#34;sha256:ba6acccedd2923aee4c2acc6a23780b14ed4b8a5fa4e14e252a23b846df9b6c1&#34;</span>,<span class=s2>&#34;Volumes&#34;</span>:null,<span class=s2>&#34;WorkingDir&#34;</span>:<span class=s2>&#34;&#34;</span>,<span class=s2>&#34;Entrypoint&#34;</span>:null,<span class=s2>&#34;OnBuild&#34;</span>:null,<span class=s2>&#34;Labels&#34;</span>:null<span class=o>}</span>,<span class=s2>&#34;container&#34;</span>:<span class=s2>&#34;ee79bb9802d0ff311de6d606fad35fa7e9ab0c1cb4113837a50571e79c9454df&#34;</span>,<span class=s2>&#34;container_config&#34;</span>:<span class=o>{</span><span class=s2>&#34;Hostname&#34;</span>:<span class=s2>&#34;&#34;</span>,<span class=s2>&#34;Domainname&#34;</span>:<span class=s2>&#34;&#34;</span>,<span class=s2>&#34;User&#34;</span>:<span class=s2>&#34;&#34;</span>,<span class=s2>&#34;AttachStdin&#34;</span>:false,<span class=s2>&#34;AttachStdout&#34;</span>:false,<span class=s2>&#34;AttachStderr&#34;</span>:false,<span class=s2>&#34;Tty&#34;</span>:false,<span class=s2>&#34;OpenStdin&#34;</span>:false,<span class=s2>&#34;StdinOnce&#34;</span>:false,<span class=s2>&#34;Env&#34;</span>:<span class=o>[</span><span class=s2>&#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;</span><span class=o>]</span>,<span class=s2>&#34;Cmd&#34;</span>:<span class=o>[</span><span class=s2>&#34;/bin/sh&#34;</span>,<span class=s2>&#34;-c&#34;</span>,<span class=s2>&#34;echo \&#34;Hello world\&#34; \u003e /tmp/newfile&#34;</span><span class=o>]</span>,<span class=s2>&#34;Image&#34;</span>:<span class=s2>&#34;sha256:ba6acccedd2923aee4c2acc6a23780b14ed4b8a5fa4e14e252a23b846df9b6c1&#34;</span>,<span class=s2>&#34;Volumes&#34;</span>:null,<span class=s2>&#34;WorkingDir&#34;</span>:<span class=s2>&#34;&#34;</span>,<span class=s2>&#34;Entrypoint&#34;</span>:null,<span class=s2>&#34;OnBuild&#34;</span>:null,<span class=s2>&#34;Labels&#34;</span>:null<span class=o>}</span>,<span class=s2>&#34;created&#34;</span>:<span class=s2>&#34;2022-01-17T12:25:14.91890037Z&#34;</span>,<span class=s2>&#34;docker_version&#34;</span>:<span class=s2>&#34;20.10.6&#34;</span>,<span class=s2>&#34;history&#34;</span>:<span class=o>[{</span><span class=s2>&#34;created&#34;</span>:<span class=s2>&#34;2021-10-16T00:37:47.226745473Z&#34;</span>,<span class=s2>&#34;created_by&#34;</span>:<span class=s2>&#34;/bin/sh -c #(nop) ADD file:5d68d27cc15a80653c93d3a0b262a28112d47a46326ff5fc2dfbf7fa3b9a0ce8 in / &#34;</span><span class=o>}</span>,<span class=o>{</span><span class=s2>&#34;created&#34;</span>:<span class=s2>&#34;2021-10-16T00:37:47.578710012Z&#34;</span>,<span class=s2>&#34;created_by&#34;</span>:<span class=s2>&#34;/bin/sh -c #(nop)  CMD [\&#34;bash\&#34;]&#34;</span>,<span class=s2>&#34;empty_layer&#34;</span>:true<span class=o>}</span>,<span class=o>{</span><span class=s2>&#34;created&#34;</span>:<span class=s2>&#34;2022-01-17T12:25:14.91890037Z&#34;</span>,<span class=s2>&#34;created_by&#34;</span>:<span class=s2>&#34;/bin/sh -c echo \&#34;Hello world\&#34; \u003e /tmp/newfile&#34;</span><span class=o>}]</span>,<span class=s2>&#34;os&#34;</span>:<span class=s2>&#34;linux&#34;</span>,<span class=s2>&#34;rootfs&#34;</span>:<span class=o>{</span><span class=s2>&#34;type&#34;</span>:<span class=s2>&#34;layers&#34;</span>,<span class=s2>&#34;diff_ids&#34;</span>:<span class=o>[</span><span class=s2>&#34;sha256:9f54eef412758095c8079ac465d494a2872e02e90bf1fb5f12a1641c0d1bb78b&#34;</span>,<span class=s2>&#34;sha256:b3cce2ce0405ffbb4971b872588c5b7fc840514b807f18047bf7d486af79884c&#34;</span><span class=o>]}}</span>
</span></span></code></pre></div><p>这就是 image 的 metadata，这里主要关注 rootfs：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 和 docker inspect 命令显示的内容差不多</span>
</span></span><span class=line><span class=cl>// ...
</span></span><span class=line><span class=cl><span class=s2>&#34;rootfs&#34;</span>:<span class=o>{</span><span class=s2>&#34;type&#34;</span>:<span class=s2>&#34;layers&#34;</span>,<span class=s2>&#34;diff_ids&#34;</span>:
</span></span><span class=line><span class=cl><span class=o>[</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;sha256:9f54eef412758095c8079ac465d494a2872e02e90bf1fb5f12a1641c0d1bb78b&#34;</span>,
</span></span><span class=line><span class=cl><span class=s2>&#34;sha256:b3cce2ce0405ffbb4971b872588c5b7fc840514b807f18047bf7d486af79884c&#34;</span>
</span></span><span class=line><span class=cl><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>// ...
</span></span></code></pre></div><p>可以看到rootfs的diff_ids是一个包含了两个元素的数组，这两个元素就是组成hello-ubuntu镜像的两个Layer的**<code>diffID</code>**。从上往下看，就是底层到顶层，也就是说<code>9f54eef412...</code>是image的最底层。</p><p>然后根据 layerID 去<code>layerdb</code>目录寻找对应的 layer：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ overlay2<span class=o>]</span><span class=c1># tree -L 2 layerdb/</span>
</span></span><span class=line><span class=cl>layerdb/
</span></span><span class=line><span class=cl>├── mounts
</span></span><span class=line><span class=cl>├── sha256
</span></span><span class=line><span class=cl>└── tmp
</span></span></code></pre></div><p>在这里我们只管<code>mounts</code>和<code>sha256</code>两个目录，先打印以下 sha256 目录</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>cd</span> /var/lib/docker/image/overlay2/layerdb/sha256/
</span></span><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl>05dd34c0b83038031c0beac0b55e00f369c2d6c67aed11ad1aadf7fe91fbecda  
</span></span><span class=line><span class=cl>// ... 省略
</span></span><span class=line><span class=cl>6aa07175d1ac03e27c9dd42373c224e617897a83673aa03a2dd5fb4fd58d589f  
</span></span></code></pre></div><p>可以看到，layer 里也是 64位随机ID构成的目录，找到刚才hello-ubuntu镜像的最底层layer：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>cd</span> 9f54eef412758095c8079ac465d494a2872e02e90bf1fb5f12a1641c0d1bb78b
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ 9f54eef412758095c8079ac465d494a2872e02e90bf1fb5f12a1641c0d1bb78b<span class=o>]</span>$ ls
</span></span><span class=line><span class=cl>cache-id  diff  size  tar-split.json.gz
</span></span></code></pre></div><p>文件含义如下：</p><ul><li>cache-id：为具体<code>/var/lib/docker/overlay2/&lt;cache-id></code>存储路径</li><li>diff：diffID，用于计算 ChainID</li><li>size：当前 layer 的大小</li></ul><p>docker使用了chainID的方式来保存layer，layer.ChainID只用本地，根据layer.DiffID计算，并用于layerdb的目录名称。</p><p>chainID唯一标识了一组（像糖葫芦一样的串的底层）diffID的hash值，包含了这一层和它的父层(底层)，</p><ul><li>当然这个糖葫芦可以有一颗山楂，也就是chainID(layer0)==diffID(layer0)；</li><li>对于多颗山楂的糖葫芦，ChainID(layerN) = SHA256hex(ChainID(layerN-1) + " " + DiffID(layerN))。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 查看 diffID，</span>
</span></span><span class=line><span class=cl>$ cat diff 
</span></span><span class=line><span class=cl>sha256:9f54eef412758095c8079ac465d494a2872e02e90bf1fb5f12a1641c0d1bb78b
</span></span></code></pre></div><p>由于这是 layer0,所以 chainID 就是 diffID，然后开始计算 layer1 的 chainID：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ChainID<span class=o>(</span>layer1<span class=o>)</span> <span class=o>=</span> SHA256hex<span class=o>(</span>ChainID<span class=o>(</span>layer0<span class=o>)</span> + <span class=s2>&#34; &#34;</span> + DiffID<span class=o>(</span>layer1<span class=o>))</span>
</span></span></code></pre></div><p>layer0的 chainID就是<code>9f54...</code>,而 layer1的 diffID 根据 rootfs 中的数组可知，为<code>b3cce...</code></p><p>计算ChainID：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>echo</span> -n <span class=s2>&#34;sha256:9f54eef412758095c8079ac465d494a2872e02e90bf1fb5f12a1641c0d1bb78b sha256:b3cce2ce0405ffbb4971b872588c5b7fc840514b807f18047bf7d486af79884c&#34;</span> <span class=p>|</span> sha256sum<span class=p>|</span> awk <span class=s1>&#39;{print $1}&#39;</span>
</span></span><span class=line><span class=cl>6613b10b697b0a267c9573ee23e54c0373ccf72e7991cf4479bd0b66609a631c
</span></span></code></pre></div><blockquote><p>一定注意要加上 “sha256:”和中间的空格“ ” 这两部分。</p></blockquote><p>因此 layer1的 chainID 就是<code>6613...</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>cd</span> /var/lib/docker/image/overlay2/layerdb/sha2566613b10b697b0a267c9573ee23e54c0373ccf72e7991cf4479bd0b66609a631c
</span></span><span class=line><span class=cl><span class=c1># 根据这个大小可以知道，就是hello-ubuntu 镜像的最上面层 layer</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ 6613b10b697b0a267c9573ee23e54c0373ccf72e7991cf4479bd0b66609a631c<span class=o>]</span>$ cat size 
</span></span><span class=line><span class=cl><span class=m>12</span>
</span></span><span class=line><span class=cl><span class=c1># 查看 cache-id 找到 文件系统中的具体位置</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ 6613b10b697b0a267c9573ee23e54c0373ccf72e7991cf4479bd0b66609a631c<span class=o>]</span>$ cat cache-id 
</span></span><span class=line><span class=cl>83b569c0f5de093192944931e4f41dafb2d7f80eae97e4bd62425c20e2079f65
</span></span></code></pre></div><p>进入具体目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 进入刚才生成的目录</span>
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> /var/lib/docker/overlay2/83b569c0f5de093192944931e4f41dafb2d7f80eae97e4bd62425c20e2079f65
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ 83b569c0f5de093192944931e4f41dafb2d7f80eae97e4bd62425c20e2079f65<span class=o>]</span><span class=c1># ls -al</span>
</span></span><span class=line><span class=cl>total <span class=m>24</span>
</span></span><span class=line><span class=cl>drwx-----x  <span class=m>4</span> root root    <span class=m>55</span> Jan <span class=m>17</span> 20:25 .
</span></span><span class=line><span class=cl>drwx-----x <span class=m>53</span> root root <span class=m>12288</span> Jan <span class=m>17</span> 20:25 ..
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>3</span> root root    <span class=m>17</span> Jan <span class=m>17</span> 20:25 diff
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> root root    <span class=m>26</span> Jan <span class=m>17</span> 20:25 link
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> root root    <span class=m>28</span> Jan <span class=m>17</span> 20:25 lower
</span></span><span class=line><span class=cl>drwx------  <span class=m>2</span> root root     <span class=m>6</span> Jan <span class=m>17</span> 20:25 work
</span></span><span class=line><span class=cl><span class=c1># 查看 diff 目录</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ 
</span></span><span class=line><span class=cl>83b569c0f5de093192944931e4f41dafb2d7f80eae97e4bd62425c20e2079f65<span class=o>]</span>$ <span class=nb>cd</span> diff/
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ diff<span class=o>]</span>$ ls
</span></span><span class=line><span class=cl>tmp
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ diff<span class=o>]</span>$ <span class=nb>cd</span> tmp/
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ tmp<span class=o>]</span>$ ls
</span></span><span class=line><span class=cl>newfile
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ tmp<span class=o>]</span><span class=c1># cat newfile </span>
</span></span><span class=line><span class=cl>Hello world
</span></span></code></pre></div><p>可以看到，我们新增的 newfile 就在这里。</p><h2 id=4-参考>4. 参考</h2><p><a href=https://ops.tips/notes/practical-look-into-overlayfs/ target=_blank rel="noopener noreffer">a practical look into overlayfs</a></p><p><a href=https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt target=_blank rel="noopener noreffer">overlayfs.txt</a></p><p><a href=https://www.jianshu.com/p/3826859a6d6e target=_blank rel="noopener noreffer">docker-overlay2文件系统</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-03-19</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/docker/09-ufs-overlayfs/ data-title=Docker教程(九)---如何使用UFS(overlayfs)实现rootfs data-hashtags=Docker><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/docker/09-ufs-overlayfs/ data-hashtag=Docker><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/docker/09-ufs-overlayfs/ data-title=Docker教程(九)---如何使用UFS(overlayfs)实现rootfs><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/docker/09-ufs-overlayfs/ data-title=Docker教程(九)---如何使用UFS(overlayfs)实现rootfs><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/docker/09-ufs-overlayfs/ data-title=Docker教程(九)---如何使用UFS(overlayfs)实现rootfs><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/docker/>Docker</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/go/chan/ class=prev rel=prev title="Go语言之 chan 源码分析"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Go语言之 chan 源码分析</a>
<a href=/posts/docker/10-bridge-network/ class=next rel=next title="Docker教程(十)---Docker 单机(桥接)网络实现">Docker教程(十)---Docker 单机(桥接)网络实现<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/lixd target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>