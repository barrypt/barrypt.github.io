<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Docker教程(五)---namespace 初体验 -</title><meta name=Description content="Linux namespace 概述"><meta property="og:title" content="Docker教程(五)---namespace 初体验"><meta property="og:description" content="Linux namespace 概述"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/docker/05-namespace/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-11T22:00:00+00:00"><meta property="article:modified_time" content="2022-02-11T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Docker教程(五)---namespace 初体验"><meta name=twitter:description content="Linux namespace 概述"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/docker/05-namespace/><link rel=prev href=https://blog.yudlk.com/posts/etcd/14-watch-analyze-2/><link rel=next href=https://blog.yudlk.com/posts/docker/06-cgroups-1/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Docker教程(五)---namespace 初体验","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/docker\/05-namespace\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Docker","wordcount":6180,"url":"https:\/\/blog.yudlk.com\/posts\/docker\/05-namespace\/","datePublished":"2022-02-11T22:00:00+00:00","dateModified":"2022-02-11T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Linux namespace 概述"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Docker教程(五)---namespace 初体验</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/docker/><i class="far fa-folder fa-fw" aria-hidden=true></i>Docker</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-02-11>2022-02-11</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;6180 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;13 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-namespace-概述>1. Namespace 概述</a><ul><li><a href=#简介>简介</a></li><li><a href=#相关api>相关API</a></li><li><a href=#查看进程所属的-namespaces>查看进程所属的 namespaces</a></li><li><a href=#namespace-limit>namespace limit</a></li><li><a href=#namespace-lifetime>namespace lifetime</a></li></ul></li><li><a href=#2-go-演示>2. Go 演示</a><ul><li><a href=#uts>UTS</a></li><li><a href=#ipc>IPC</a></li><li><a href=#pid>PID</a></li><li><a href=#mount>Mount</a></li><li><a href=#user>User</a></li><li><a href=#network>Network</a></li></ul></li><li><a href=#3-小结>3. 小结</a></li><li><a href=#4-参考>4. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要介绍了 Linux namespace 以及如何使用 Go 语言操作 namespace。</p><p>Docker 基础知识之 Namespace 篇。</p><p>主要内容为：</p><ul><li>1）Namespace 介绍</li><li>2）Go 语言操作 Namespace 演示</li></ul><blockquote><p>准备跟着《自己动手写 docker》这本书从零开始实现一个简易版的 docker，加深对 docker 的理解。</p><p>源码及相关教程见 <a href=https://github.com/barrypt/mydocker target=_blank rel="noopener noreffer">Github</a>，欢迎 star。</p></blockquote><h2 id=1-namespace-概述>1. Namespace 概述</h2><h3 id=简介>简介</h3><p><strong>Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法</strong>，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p><blockquote><p>Namespace 就是对资源的隔离</p></blockquote><p>目前，Linux 内核里面实现了 8 种不同类型的 namespace。</p><table><thead><tr><th>分类</th><th>系统调用参数</th><th>隔离内容</th><th>相关内核版本</th></tr></thead><tbody><tr><td><strong>Mount namespaces</strong></td><td>CLONE_NEWNS</td><td>Mount points</td><td><a href=https://lwn.net/2001/0301/a/namespaces.php3 target=_blank rel="noopener noreffer">Linux 2.4.19</a></td></tr><tr><td><strong>UTS namespaces</strong></td><td>CLONE_NEWUTS</td><td>Hostname and NIS domain name</td><td><a href=https://lwn.net/Articles/179345/ target=_blank rel="noopener noreffer">Linux 2.6.19</a></td></tr><tr><td><strong>IPC namespaces</strong></td><td>CLONE_NEWIPC</td><td>System V IPC, POSIX message queues</td><td><a href=https://lwn.net/Articles/187274/ target=_blank rel="noopener noreffer">Linux 2.6.19</a></td></tr><tr><td><strong>PID namespaces</strong></td><td>CLONE_NEWPID</td><td>Process IDs</td><td><a href=https://lwn.net/Articles/259217/ target=_blank rel="noopener noreffer">Linux 2.6.24</a></td></tr><tr><td><strong>Network namespaces</strong></td><td>CLONE_NEWNET</td><td>Network devices, stacks, ports, etc.</td><td><a href=https://lwn.net/Articles/219794/ target=_blank rel="noopener noreffer">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td></tr><tr><td><strong>User namespaces</strong></td><td>CLONE_NEWUSER</td><td>User and group IDs</td><td><a href=https://lwn.net/Articles/528078/ target=_blank rel="noopener noreffer">始于 Linux 2.6.23 完成于 Linux 3.8)</a></td></tr><tr><td><strong>Cgroup namespace</strong></td><td>CLONE_NEWCGROUP</td><td>Cgroup root directory</td><td><a href=https://lkml.org/lkml/2016/3/18/564 target=_blank rel="noopener noreffer">Linux 4.6</a></td></tr><tr><td><strong>Time namespace</strong></td><td>CLONE_NEWTIME</td><td>Boot and monotonic</td><td><a href="https://www.phoronix.com/scan.php?page=news_item&px=Time-Namespace-In-Linux-5.6" target=_blank rel="noopener noreffer">Linux 5.6</a></td></tr></tbody></table><blockquote><p><strong>注意：</strong> 由于 Cgroup namespace 在 4.6 的内核中才实现，并且和 cgroup v2 关系密切，现在普及程度还不高，比如 docker 现在就还没有用它。</p></blockquote><h3 id=相关api>相关API</h3><p>和 namespace 相关的函数只有四个，这里简单的看一下：</p><ul><li>clone</li><li>setns</li><li>unshare</li><li>ioctl_ns</li></ul><p><a href=https://man7.org/linux/man-pages/man2/clone.2.html target=_blank rel="noopener noreffer">clone</a>： 创建一个新的进程并把他放到新的namespace中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl> <span class=kt>int</span> <span class=nf>clone</span><span class=p>(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fn</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>),</span> <span class=kt>void</span> <span class=o>*</span><span class=n>stack</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>                 <span class=cm>/* pid_t *parent_tid, void *tls, pid_t *child_tid */</span> <span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> flags： 
</span></span></span><span class=line><span class=cl><span class=cm>    指定一个或者多个上面的CLONE_NEW*（当然也可以包含跟namespace无关的flags）， 
</span></span></span><span class=line><span class=cl><span class=cm>    这样就会创建一个或多个新的不同类型的namespace， 
</span></span></span><span class=line><span class=cl><span class=cm>    并把新创建的子进程加入新创建的这些namespace中。
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></div><p><a href=https://man7.org/linux/man-pages/man2/setns.2.html target=_blank rel="noopener noreffer">setns</a>： 将当前进程加入到已有的namespace中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setns</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nstype</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>fd： 
</span></span></span><span class=line><span class=cl><span class=cm>    指向/proc/[pid]/ns/目录里相应namespace对应的文件，
</span></span></span><span class=line><span class=cl><span class=cm>    表示要加入哪个namespace
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>nstype：
</span></span></span><span class=line><span class=cl><span class=cm>    指定namespace的类型（上面的任意一个CLONE_NEW*）：
</span></span></span><span class=line><span class=cl><span class=cm>    1. 如果当前进程不能根据fd得到它的类型，如fd由其他进程创建，
</span></span></span><span class=line><span class=cl><span class=cm>    并通过UNIX domain socket传给当前进程，
</span></span></span><span class=line><span class=cl><span class=cm>    那么就需要通过nstype来指定fd指向的namespace的类型
</span></span></span><span class=line><span class=cl><span class=cm>    2. 如果进程能根据fd得到namespace类型，比如这个fd是由当前进程打开的，
</span></span></span><span class=line><span class=cl><span class=cm>    那么nstype设置为0即可
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p><a href=https://man7.org/linux/man-pages/man2/unshare.2.html target=_blank rel="noopener noreffer">unshare</a>: 使当前进程退出指定类型的 namespace，并加入到新创建的 namespace（相当于创建并加入新的namespace）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>unshare</span><span class=p>(</span><span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>flags：
</span></span></span><span class=line><span class=cl><span class=cm>    指定一个或者多个上面的CLONE_NEW*，
</span></span></span><span class=line><span class=cl><span class=cm>    这样当前进程就退出了当前指定类型的namespace并加入到新创建的namespace
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p><a href=https://man7.org/linux/man-pages/man2/ioctl_ns.2.html target=_blank rel="noopener noreffer">ioctl_ns</a>：查询 namespace 信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>new_fd</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>request</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>fd: 指向/proc/[pid]/ns/目录里相应namespace对应的文件
</span></span></span><span class=line><span class=cl><span class=cm>request: 
</span></span></span><span class=line><span class=cl><span class=cm>	NS_GET_USERNS: 返回指向拥有用户的文件描述符namespace fd引用的命名空间
</span></span></span><span class=line><span class=cl><span class=cm>    NS_GET_PARENT: 返回引用父级的文件描述符由fd引用的命名空间的命名空间。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p><strong>clone 和 unshare 的区别</strong></p><p>clone 和 unshare 的功能都是创建并加入新的 namespace， 他们的区别是：</p><ul><li>unshare 是使当前进程加入新的 namespace</li><li>clone 是创建一个新的子进程，然后让子进程加入新的 namespace，而当前进程保持不变</li></ul><h3 id=查看进程所属的-namespaces>查看进程所属的 namespaces</h3><p>系统中的每个进程都有 <code>/proc/[pid]/ns/</code> 这样一个目录，里面包含了这个进程所属 namespace 的信息，里面每个文件的描述符都可以用来作为 setns 函数(后面会介绍)的参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#查看当前bash进程所属的namespace</span>
</span></span><span class=line><span class=cl> barrypt  ~  ls -l /proc/<span class=nv>$$</span>/ns
</span></span><span class=line><span class=cl>total <span class=m>0</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> barrypt barrypt <span class=m>0</span> Jan  <span class=m>6</span> 19:00 cgroup -&gt; <span class=s1>&#39;cgroup:[4026531835]&#39;</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> barrypt barrypt <span class=m>0</span> Jan  <span class=m>6</span> 19:00 ipc -&gt; <span class=s1>&#39;ipc:[4026532227]&#39;</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> barrypt barrypt <span class=m>0</span> Jan  <span class=m>6</span> 19:00 mnt -&gt; <span class=s1>&#39;mnt:[4026532241]&#39;</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> barrypt barrypt <span class=m>0</span> Jan  <span class=m>6</span> 19:00 net -&gt; <span class=s1>&#39;net:[4026531992]&#39;</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> barrypt barrypt <span class=m>0</span> Jan  <span class=m>6</span> 19:00 pid -&gt; <span class=s1>&#39;pid:[4026532243]&#39;</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> barrypt barrypt <span class=m>0</span> Jan  <span class=m>6</span> 19:00 pid_for_children -&gt; <span class=s1>&#39;pid:[4026532243]&#39;</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> barrypt barrypt <span class=m>0</span> Jan  <span class=m>6</span> 19:00 user -&gt; <span class=s1>&#39;user:[4026531837]&#39;</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> barrypt barrypt <span class=m>0</span> Jan  <span class=m>6</span> 19:00 uts -&gt; <span class=s1>&#39;uts:[4026532242]&#39;</span>
</span></span></code></pre></div><p>以<code>ipc:[4026532227]</code>为例，ipc 是 namespace 的类型，4026532227 是 inode number。</p><p><strong>如果两个进程的 ipc namespace 的 inode number一样，说明他们属于同一个 namespace</strong>，这条规则对其他类型的 namespace 也同样适用。</p><h3 id=namespace-limit>namespace limit</h3><p><code>/proc/sys/user</code> 目录中公开了对各种命名空间数量的限制，具体如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ tree /proc/sys/user/
</span></span><span class=line><span class=cl>/proc/sys/user/
</span></span><span class=line><span class=cl>├── max_cgroup_namespaces
</span></span><span class=line><span class=cl>├── max_inotify_instances
</span></span><span class=line><span class=cl>├── max_inotify_watches
</span></span><span class=line><span class=cl>├── max_ipc_namespaces
</span></span><span class=line><span class=cl>├── max_mnt_namespaces
</span></span><span class=line><span class=cl>├── max_net_namespaces
</span></span><span class=line><span class=cl>├── max_pid_namespaces
</span></span><span class=line><span class=cl>├── max_user_namespaces
</span></span><span class=line><span class=cl>└── max_uts_namespaces
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat /proc/sys/user/max_pid_namespaces
</span></span><span class=line><span class=cl><span class=m>6784</span>
</span></span></code></pre></div><h3 id=namespace-lifetime>namespace lifetime</h3><p>当一个 namespace 中的所有进程都结束或者移出该 namespace 时，该 namespace 将会被销毁。</p><p>不过也有一些特殊情况，可以再没有进程的时候保留 namespace：</p><ul><li>存在打开的 FD，或者对 <code>/proc/[pid]/ns/*</code> 执行了 bind mount</li><li>存在子 namespace</li><li>它是一个拥有一个或多个非用户 namespace 的 namespace。</li><li>它是一个 PID namespace，并且有一个进程通过 <code>/proc/[pid]/ns/pid_for_children</code> 符号链接引用了这个 namespace。</li><li>它是一个 Time namespace，并且有一个进程通过 <code>/proc/[pid]/ns/time_for_children</code> 符号链接引用了这个 namespace。</li><li>它是一个 IPC namespace，并且有一个 mqueue 文件系统的 mount 引用了该 namespace</li><li>它是一个 PIDnamespace，并且有一个 proc 文件系统的 mount 引用了该 namespace</li></ul><h2 id=2-go-演示>2. Go 演示</h2><h3 id=uts>UTS</h3><p><strong>UTS Namespace主要用来隔离nodename和domainname两个系统标识</strong>。在UTS Namespace里面，每个Namespace允许有自己的hostname.</p><p>以下程序展示了如何在 Go 中切换 UTS Namespace。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 注: 运行时需要 root 权限。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span> <span class=o>:=</span> <span class=nx>exec</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=s>&#34;bash&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>SysProcAttr</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SysProcAttr</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Cloneflags</span><span class=p>:</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUTS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdin</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdin</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdout</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stderr</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalln</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行并测试</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>DESKTOP-9K4GB6E# go run main.go
</span></span><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker#
</span></span></code></pre></div><p>运行后会进入了一个新的 shell 环境。</p><p>查看以下是否真的进入了新的 UTS Namespace。</p><p>首先使用<code> pstree</code>查看进程关系：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# pstree -pl
</span></span><span class=line><span class=cl>init<span class=o>(</span>1<span class=o>)</span>─┬─init<span class=o>(</span>1272<span class=o>)</span>───init<span class=o>(</span>1273<span class=o>)</span>───server<span class=o>(</span>1274<span class=o>)</span>─┬─<span class=o>{</span>server<span class=o>}(</span>1282<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1283<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1284<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1285<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1286<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1287<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1288<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        └─<span class=o>{</span>server<span class=o>}(</span>1289<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>3701<span class=o>)</span>───init<span class=o>(</span>3702<span class=o>)</span>───zsh<span class=o>(</span>3703<span class=o>)</span>───su<span class=o>(</span>7520<span class=o>)</span>───bash<span class=o>(</span>7521<span class=o>)</span>───zsh<span class=o>(</span>7575<span class=o>)</span>───go<span class=o>(</span>8104<span class=o>)</span>─┬─main<span class=o>(</span>8182<span class=o>)</span>─┬─bash<span class=o>(</span>8187<span class=o>)</span>───pstree<span class=o>(</span>8194<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    │            ├─<span class=o>{</span>main<span class=o>}(</span>8183<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    │            ├─<span class=o>{</span>main<span class=o>}(</span>8184<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    │            ├─<span class=o>{</span>main<span class=o>}(</span>8185<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    │            └─<span class=o>{</span>main<span class=o>}(</span>8186<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8105<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8106<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8107<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8108<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8109<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8110<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8111<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8112<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>8117<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    └─<span class=o>{</span>go<span class=o>}(</span>8143<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>3763<span class=o>)</span>───init<span class=o>(</span>3764<span class=o>)</span>───zsh<span class=o>(</span>3765<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>5171<span class=o>)</span>───init<span class=o>(</span>5172<span class=o>)</span>───fsnotifier-wsl<span class=o>(</span>5173<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>7459<span class=o>)</span>───init<span class=o>(</span>7460<span class=o>)</span>───bash<span class=o>(</span>7461<span class=o>)</span>───su<span class=o>(</span>7476<span class=o>)</span>───bash<span class=o>(</span>7477<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─<span class=o>{</span>init<span class=o>}(</span>5<span class=o>)</span>
</span></span><span class=line><span class=cl>        └─<span class=o>{</span>init<span class=o>}(</span>6<span class=o>)</span>
</span></span></code></pre></div><p>主要关注这条：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>├─init<span class=o>(</span>3701<span class=o>)</span>───init<span class=o>(</span>3702<span class=o>)</span>───zsh<span class=o>(</span>3703<span class=o>)</span>───su<span class=o>(</span>7520<span class=o>)</span>───bash<span class=o>(</span>7521<span class=o>)</span>───zsh<span class=o>(</span>7575<span class=o>)</span>───go<span class=o>(</span>8104<span class=o>)</span>─┬─main<span class=o>(</span>8182<span class=o>)</span>─┬─bash<span class=o>(</span>8187<span class=o>)</span>
</span></span></code></pre></div><p>main 程序 pid 为 8182,后续新创建的 bash pid 为 8187，现在查看二者 uts 是否相同即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# readlink /proc/8182/ns/uts
</span></span><span class=line><span class=cl>uts:<span class=o>[</span>4026532242<span class=o>]</span>
</span></span><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# readlink /proc/8187/ns/uts
</span></span><span class=line><span class=cl>uts:<span class=o>[</span>4026532386<span class=o>]</span>
</span></span></code></pre></div><p>可以发现二者确实不在一个 UTS Namespace 中。由于 UTS Namespace hostname 做了隔离 所以在这个环境内修改 hostname 应该不影响外部主机， 下面来做 下实验。</p><p>在这个新的 bash 环境中修改 hostname</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# hostname bash
</span></span><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# hostname
</span></span><span class=line><span class=cl>bash
</span></span></code></pre></div><p>新开一个在宿主机上查看 hostname：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl> barrypt  ~ $ hostname
</span></span><span class=line><span class=cl>DESKTOP-9K4GB6E
</span></span></code></pre></div><p>可以看到外部的 hostname 并没有被修改影响，由此可了解 UTS Namespace 的作用。</p><h3 id=ipc>IPC</h3><p><strong>IPC Namespace 用来隔离 sys V IPC和 POSIX message queues</strong>。每个 IPC Namespace 都有自己的 Sys V IPC 和 POSIX message queues。</p><p>微调一下程序，只是修改了 Cloneflags，新增了 CLONE_NEWIPC，表示同时创建 IPC Namespace。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 注: 运行时需要 root 权限。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span> <span class=o>:=</span> <span class=nx>exec</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=s>&#34;bash&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>SysProcAttr</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SysProcAttr</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Cloneflags: syscall.CLONE_NEWUTS,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Cloneflags</span><span class=p>:</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUTS</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWIPC</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdin</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdin</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdout</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stderr</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalln</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行并测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 先查看宿主机上的 ipc message queue</span>
</span></span><span class=line><span class=cl>DESKTOP-9K4GB6E# ipcs -q
</span></span><span class=line><span class=cl>------ Message Queues --------
</span></span><span class=line><span class=cl>key        msqid      owner      perms      used-bytes   messages
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 然后创建一个 </span>
</span></span><span class=line><span class=cl>DESKTOP-9K4GB6E# ipcmk -Q
</span></span><span class=line><span class=cl>Message queue id: <span class=m>0</span>
</span></span><span class=line><span class=cl><span class=c1># 再次查看，发现有了</span>
</span></span><span class=line><span class=cl>DESKTOP-9K4GB6E# ipcs -q
</span></span><span class=line><span class=cl>------ Message Queues --------
</span></span><span class=line><span class=cl>key        msqid      owner      perms      used-bytes   messages
</span></span><span class=line><span class=cl>0x70ffd07c <span class=m>0</span>          root       <span class=m>644</span>        <span class=m>0</span>            <span class=m>0</span>
</span></span></code></pre></div><p>运行程序进入新的 shell</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>DESKTOP-9K4GB6E# go run main.go
</span></span><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# ipcs -q
</span></span><span class=line><span class=cl>------ Message Queues --------
</span></span><span class=line><span class=cl>key        msqid      owner      perms      used-bytes   messages
</span></span></code></pre></div><p>可以发现，在新的 Namespace 中已经看不到宿主机上的 message queue 了。说明 IPC Namespace 创建成功，IPC 已经被隔离。</p><h3 id=pid>PID</h3><p><strong>PID Namespace是用来隔离进程ID的</strong>。同样一个进程在不同的PID Namespace里可以拥有不同的PID。这样就可以理解，在docker container 里面，使用ps -ef经常会发现，在容器内，前台运行的那个进程PID是1，但是在容器外，使用ps -ef会发现同样的进程却有不同的PID，这就是PID Namespace做的事情。</p><p>再次调整程序，增加 PID flags：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 注: 运行时需要 root 权限。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span> <span class=o>:=</span> <span class=nx>exec</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=s>&#34;bash&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>SysProcAttr</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SysProcAttr</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Cloneflags: syscall.CLONE_NEWUTS,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Cloneflags</span><span class=p>:</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUTS</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWIPC</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWPID</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdin</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdin</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdout</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stderr</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalln</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行并测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>DESKTOP-9K4GB6E# go run main.go
</span></span><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# pstree -pl
</span></span><span class=line><span class=cl>init<span class=o>(</span>1<span class=o>)</span>─┬─init<span class=o>(</span>1272<span class=o>)</span>───init<span class=o>(</span>1273<span class=o>)</span>───server<span class=o>(</span>1274<span class=o>)</span>─┬─<span class=o>{</span>server<span class=o>}(</span>1282<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1283<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1284<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1285<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1286<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1287<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        ├─<span class=o>{</span>server<span class=o>}(</span>1288<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                        └─<span class=o>{</span>server<span class=o>}(</span>1289<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>3701<span class=o>)</span>───init<span class=o>(</span>3702<span class=o>)</span>───zsh<span class=o>(</span>3703<span class=o>)</span>───su<span class=o>(</span>7520<span class=o>)</span>───bash<span class=o>(</span>7521<span class=o>)</span>───zsh<span class=o>(</span>7575<span class=o>)</span>───go<span class=o>(</span>9103<span class=o>)</span>─┬─main<span class=o>(</span>9184<span class=o>)</span>─┬─bash<span class=o>(</span>9189<span class=o>)</span>───pstree<span class=o>(</span>9196<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    │            ├─<span class=o>{</span>main<span class=o>}(</span>9185<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    │            ├─<span class=o>{</span>main<span class=o>}(</span>9186<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    │            ├─<span class=o>{</span>main<span class=o>}(</span>9187<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    │            └─<span class=o>{</span>main<span class=o>}(</span>9188<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9104<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9105<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9106<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9107<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9108<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9109<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9110<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9111<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    ├─<span class=o>{</span>go<span class=o>}(</span>9112<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                                                                                    └─<span class=o>{</span>go<span class=o>}(</span>9120<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>3763<span class=o>)</span>───init<span class=o>(</span>3764<span class=o>)</span>───zsh<span class=o>(</span>3765<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>5171<span class=o>)</span>───init<span class=o>(</span>5172<span class=o>)</span>───fsnotifier-wsl<span class=o>(</span>5173<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>7459<span class=o>)</span>───init<span class=o>(</span>7460<span class=o>)</span>───bash<span class=o>(</span>7461<span class=o>)</span>───su<span class=o>(</span>7476<span class=o>)</span>───bash<span class=o>(</span>7477<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>8201<span class=o>)</span>───init<span class=o>(</span>8202<span class=o>)</span>───zsh<span class=o>(</span>8203<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─<span class=o>{</span>init<span class=o>}(</span>5<span class=o>)</span>
</span></span><span class=line><span class=cl>        └─<span class=o>{</span>init<span class=o>}(</span>6<span class=o>)</span>
</span></span></code></pre></div><p>可以看到 main 函数 pid 为 9184，而新开的 bash pid 为 9189。</p><p>然后再新开的 bash 中查看自己的 pid：</p><blockquote><p>这里只能使用 <code>echo $$</code> 命令查看，ps、top 等命令会查看到其他 Namespace 中的信息。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# <span class=nb>echo</span> <span class=nv>$$</span>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span></code></pre></div><p>发现 pid 是1，说明再新开的 PID Namespace 中只有一个 bash 这个进程，而且被伪装成了 1 号进程。</p><h3 id=mount>Mount</h3><p><strong>Mount Namespace用来隔离各个进程看到的挂载点视图</strong>。在不同Namespace的进程中，看到的文件系统层次是不一样的。 在Mount Namespace中调用mount()和umount()仅仅只会影响当前Namespace内的文件系统，而对全局的文件系统是没有影响的。</p><p>看到这里，也许就会想到chroot()，它也是将某一个子目录变成根节点。但是，Mount Namespace不仅能实现这个功能，而且能以更加灵活和安全的方式实现。</p><blockquote><p>需要注意的是，Mount Namespace 的 flag 是<code>CLONE_NEWNS</code>,直接是 NEWNS 而不是 NEWMOUNT,因为 Mount Namespace 是 Linux 中实现的第一个 Namespace，当时也没想到后续会有很多类型的 Namespace 加入。</p></blockquote><p>再次修改代码，增加 Mount Namespace 的 flag</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>SysProcAttr</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SysProcAttr</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Cloneflags: syscall.CLONE_NEWUTS,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID,
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Cloneflags</span><span class=p>:</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUTS</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWIPC</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWPID</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWNS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>运行并测试：</p><p>首先运行程序并在新的 bash 环境中查看 /proc</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>DESKTOP-9K4GB6E# go run main.go
</span></span><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# ls /proc
</span></span><span class=line><span class=cl><span class=m>1</span>     <span class=m>3764</span>  <span class=m>7476</span>  <span class=m>9476</span>       cmdline    driver       kallsyms     loadavg  net           swaps        vmallocinfo
</span></span><span class=line><span class=cl><span class=m>1272</span>  <span class=m>3765</span>  <span class=m>7477</span>  <span class=m>9557</span>       config.gz  execdomains  kcore        locks    pagetypeinfo  sys          vmstat
</span></span><span class=line><span class=cl><span class=m>1273</span>  <span class=m>5171</span>  <span class=m>7520</span>  <span class=m>9562</span>       consoles   filesystems  key-users    mdstat   partitions    sysvipc      zoneinfo
</span></span><span class=line><span class=cl><span class=m>1274</span>  <span class=m>5172</span>  <span class=m>7521</span>  <span class=m>9569</span>       cpuinfo    fs           keys         meminfo  sched_debug   thread-self
</span></span><span class=line><span class=cl><span class=m>3701</span>  <span class=m>5173</span>  <span class=m>7575</span>  acpi       crypto     interrupts   kmsg         misc     schedstat     timer_list
</span></span><span class=line><span class=cl><span class=m>3702</span>  <span class=m>7459</span>  <span class=m>8201</span>  buddyinfo  devices    iomem        kpagecgroup  modules  self          tty
</span></span><span class=line><span class=cl><span class=m>3703</span>  <span class=m>7460</span>  <span class=m>8202</span>  bus        diskstats  ioports      kpagecount   mounts   softirqs      uptime
</span></span><span class=line><span class=cl><span class=m>3763</span>  <span class=m>7461</span>  <span class=m>8203</span>  cgroups    dma        irq          kpageflags   mtrr     stat          version
</span></span></code></pre></div><p>可以看到，有一大堆文件，这是因为现在查看到的其实是宿主机上的 /proc 目录。</p><p>现在把 proc 目录挂载到当前 Namespace 中来：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# mount -t proc proc /proc
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# ls /proc
</span></span><span class=line><span class=cl><span class=m>1</span>          cmdline    diskstats    interrupts  key-users    loadavg  mounts        schedstat  sysvipc      vmallocinfo
</span></span><span class=line><span class=cl><span class=m>10</span>         config.gz  dma          iomem       keys         locks    mtrr          self       thread-self  vmstat
</span></span><span class=line><span class=cl>acpi       consoles   driver       ioports     kmsg         mdstat   net           softirqs   timer_list   zoneinfo
</span></span><span class=line><span class=cl>buddyinfo  cpuinfo    execdomains  irq         kpagecgroup  meminfo  pagetypeinfo  stat       tty
</span></span><span class=line><span class=cl>bus        crypto     filesystems  kallsyms    kpagecount   misc     partitions    swaps      uptime
</span></span><span class=line><span class=cl>cgroups    devices    fs           kcore       kpageflags   modules  sched_debug   sys        version
</span></span></code></pre></div><p>可以看到，少了一些文件，少的主要是数字命名的目录，因为当前 Namespace 下没有这些进程，自然就看不到对应的信息了。</p><p>此时就可以通过 ps 命令来查看了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker# ps -ef
</span></span><span class=line><span class=cl>UID        PID  PPID  C STIME TTY          TIME CMD
</span></span><span class=line><span class=cl>root         <span class=m>1</span>     <span class=m>0</span>  <span class=m>0</span> 13:13 pts/2    00:00:00 bash
</span></span><span class=line><span class=cl>root        <span class=m>11</span>     <span class=m>1</span>  <span class=m>0</span> 13:13 pts/2    00:00:00 ps -ef
</span></span></code></pre></div><p>可以看到，在当前 Namespace 中 bash 为 1 号进程。</p><p>这就说明，<strong>当前 Mount Namespace 中的 mount 和外部是隔离的，mount 操作并没有影响到外部</strong>，Docker volume 也是利用了这个特性。</p><h3 id=user>User</h3><p>User Narespace 主要是隔离用户的用户组ID。也就是说，一个进程的 UserID 和GroupID 在不同的 User Namespace 中可以是不同的。比较常用的是，在宿主机上以一个非root用户运行创建一个User Namespace,然后在User Namespace里面却映射成root用户。这意味着，这个进程在User Namespace里面有root 权限，但是在User Namespace外面却没有root 的权限。</p><p>从Linux Kernel 3.8开始，非root进程也可以创建UserNamespace,并且此用户在Namespace里面可以被映射成root，且在Namespace内有root权限。</p><p>再次修改代码，增加 User Namespace 的 flag：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>SysProcAttr</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SysProcAttr</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Cloneflags</span><span class=p>:</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUTS</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWIPC</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWPID</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWNS</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUSER</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>运行并测试：</p><p>首先在宿主机上查看一个 user 和 group：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>DESKTOP-9K4GB6E# id
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>0<span class=o>(</span>root<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>0<span class=o>(</span>root<span class=o>)</span> <span class=nv>groups</span><span class=o>=</span>0<span class=o>(</span>root<span class=o>)</span>
</span></span></code></pre></div><p>可以看到，此时是 root 用户。</p><p>运行程序，进入新的 bash 环境：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>DESKTOP-9K4GB6E# go run main.go
</span></span><span class=line><span class=cl>nobody@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker$ id
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>65534<span class=o>(</span>nobody<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>65534<span class=o>(</span>nogroup<span class=o>)</span> <span class=nv>groups</span><span class=o>=</span>65534<span class=o>(</span>nogroup<span class=o>)</span>
</span></span></code></pre></div><p>可以看到，UID 是不同的，说明 User Namespace 生效了。</p><h3 id=network>Network</h3><p>Network Namespace 是用来隔离网络设备、IP 地址端口等网络栈的 Namespace。Network Namespace 可以让每个容器拥有自己独立的(虛拟的)网络设备，而且容器内的应用可以绑定到自己的端口，每个 Namespace 内的端口都不会互相冲突。在宿主机上搭建网桥后，就能很方便地实现容器之间的通信，而且不同容器上的应用可以使用相同的端口。</p><p>再次修改代码，增加 Network Namespace 的 flag：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>SysProcAttr</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SysProcAttr</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Cloneflags</span><span class=p>:</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUTS</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWIPC</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWPID</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWNS</span> <span class=p>|</span> 
</span></span><span class=line><span class=cl>			<span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUSER</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWNET</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>运行并测试：</p><p>首先看一下宿主机上的网络设备：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>DESKTOP-9K4GB6E# ip addr
</span></span><span class=line><span class=cl>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class=m>65536</span> qdisc noqueue state UNKNOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=cl>    inet 127.0.0.1/8 scope host lo
</span></span><span class=line><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=cl>    inet6 ::1/128 scope host
</span></span><span class=line><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=cl>2: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu <span class=m>1500</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/ether 22:2f:1f:8e:f7:72 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=cl>3: dummy0: &lt;BROADCAST,NOARP&gt; mtu <span class=m>1500</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/ether 7e:46:8b:04:23:81 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=cl>4: tunl0@NONE: &lt;NOARP&gt; mtu <span class=m>1480</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/ipip 0.0.0.0 brd 0.0.0.0
</span></span><span class=line><span class=cl>5: sit0@NONE: &lt;NOARP&gt; mtu <span class=m>1480</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/sit 0.0.0.0 brd 0.0.0.0
</span></span><span class=line><span class=cl>6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc mq state UP group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/ether 00:15:5d:6e:f2:65 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=cl>    inet 172.18.167.21/20 brd 172.18.175.255 scope global eth0
</span></span><span class=line><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=cl>    inet6 fe80::215:5dff:fe6e:f265/64 scope link
</span></span><span class=line><span class=cl>       valid_lft forever preferred_lft forever
</span></span></code></pre></div><p>有 lo、eth0 等6 个设备。</p><p>然后运行程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>DESKTOP-9K4GB6E# go run main.go
</span></span><span class=line><span class=cl>nobody@DESKTOP-9K4GB6E:/home/barrypt/projects/docker/mydocker$ ip addr
</span></span><span class=line><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=cl>2: tunl0@NONE: &lt;NOARP&gt; mtu <span class=m>1480</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/ipip 0.0.0.0 brd 0.0.0.0
</span></span><span class=line><span class=cl>3: sit0@NONE: &lt;NOARP&gt; mtu <span class=m>1480</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/sit 0.0.0.0 brd 0.0.0.0
</span></span></code></pre></div><p>可以发现，新的 Namespace 中只有3个设备了，说明 Network Namespace 生效了。</p><h2 id=3-小结>3. 小结</h2><ul><li>1）本质：Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法，本质就是对全局系统资源的一种封装隔离。</li><li>2）使用：Namespace API 一共 4个，最常用的就是 clone，而 Go 已经把 clone 调用给封装好了，使用时只需要传入不同参数即可控制创建不同 Namespace。</li></ul><h2 id=4-参考>4. 参考</h2><ul><li><a href=https://man7.org/linux/man-pages/man7/namespaces.7.html target=_blank rel="noopener noreffer">overview of Linux namespaces</a></li><li><a href=https://lwn.net/Articles/531114/ target=_blank rel="noopener noreffer">Namespaces in operation, part 1: namespaces overview</a></li><li><a href=https://www.wikiwand.com/en/Linux_namespaces target=_blank rel="noopener noreffer">Linux namespaces</a></li><li><a href=https://en.wikipedia.org/wiki/Linux_namespaces target=_blank rel="noopener noreffer">Linux_namespaces</a></li><li><a href=https://coolshell.cn/articles/17010.html target=_blank rel="noopener noreffer">DOCKER基础技术：LINUX NAMESPACE（上）</a></li><li><a href=https://coolshell.cn/articles/17029.html target=_blank rel="noopener noreffer">DOCKER基础技术：LINUX NAMESPACE（下）</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-02-11</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/docker/05-namespace/ data-title="Docker教程(五)---namespace 初体验" data-hashtags=Docker><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/docker/05-namespace/ data-hashtag=Docker><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/docker/05-namespace/ data-title="Docker教程(五)---namespace 初体验"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/docker/05-namespace/ data-title="Docker教程(五)---namespace 初体验"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/docker/05-namespace/ data-title="Docker教程(五)---namespace 初体验"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/docker/>Docker</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/etcd/14-watch-analyze-2/ class=prev rel=prev title="etcd教程(十四)---watch 机制源码分析（下）"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>etcd教程(十四)---watch 机制源码分析（下）</a>
<a href=/posts/docker/06-cgroups-1/ class=next rel=next title=Docker教程(六)---Cgroups-1-初体验>Docker教程(六)---Cgroups-1-初体验<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>