<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Docker教程(三)---核心实现原理分析 -</title><meta name=Description content="Docker容器核心实现原理分析"><meta property="og:title" content="Docker教程(三)---核心实现原理分析"><meta property="og:description" content="Docker容器核心实现原理分析"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/docker/03-container-core/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-14T22:00:00+00:00"><meta property="article:modified_time" content="2021-02-14T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Docker教程(三)---核心实现原理分析"><meta name=twitter:description content="Docker容器核心实现原理分析"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/docker/03-container-core/><link rel=prev href=https://blog.yudlk.com/posts/grpc/09-retry/><link rel=next href=https://blog.yudlk.com/posts/docker/04-container-network/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Docker教程(三)---核心实现原理分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/docker\/03-container-core\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Docker","wordcount":4227,"url":"https:\/\/blog.yudlk.com\/posts\/docker\/03-container-core\/","datePublished":"2021-02-14T22:00:00+00:00","dateModified":"2021-02-14T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Docker容器核心实现原理分析"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Docker教程(三)---核心实现原理分析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/docker/><i class="far fa-folder fa-fw" aria-hidden=true></i>Docker</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-02-14>2021-02-14</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4227 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;9 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-容器与进程>1. 容器与进程</a></li><li><a href=#2-隔离与限制>2. 隔离与限制</a><ul><li><a href=#1-namespace>1. Namespace</a></li><li><a href=#2-cgroups>2. Cgroups</a></li></ul></li><li><a href=#3-容器镜像>3. 容器镜像</a><ul><li><a href=#1-文件系统>1. 文件系统</a></li><li><a href=#2-rootfs>2. rootfs</a></li><li><a href=#3-镜像层layer>3. 镜像层（Layer）</a></li></ul></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要介绍了 Docker容器的核心实现原理，包括 Namespace、Cgroups、rootfs 等。</p><blockquote><p>接触容器也很长时间了，期间也查阅了不少资料，神秘的 Docker 容器也逐渐变得不那么神秘，于是想着简单整理一下 docker 容器的核心实现原理。</p></blockquote><h2 id=1-容器与进程>1. 容器与进程</h2><p><strong>进程就是程序运行起来后的计算机执行环境的总和</strong>。</p><blockquote><p>即：计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。</p></blockquote><p><strong>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”</strong>。</p><blockquote><p>对于 Docker 等大多数 Linux 容器来说，<strong>Cgroups</strong> 技术是用来制造约束的主要手段，而 <strong>Namespace</strong> 技术则是用来修改进程视图的主要方法。</p></blockquote><h2 id=2-隔离与限制>2. 隔离与限制</h2><h3 id=1-namespace>1. Namespace</h3><p><strong>Namespace</strong> 技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。</p><p>在 Linux 下可以根据隔离的属性不同分为不同的 Namespace ：</p><ul><li>1）PID Namespace</li><li>2）Mount Namespace</li><li>3）UTS Namespace</li><li>4）IPC Namespace</li><li>5）Network Namespace</li><li>6）User Namespace</li></ul><p><strong>Namespace 存在的问题</strong></p><p>最大的问题就是隔离得不彻底。</p><p>首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。</p><p>其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。</p><blockquote><p>容器中修改了时间，实际修改的是宿主机时间，那么宿主机上所有容器的时间都跟着变化了。</p></blockquote><h3 id=2-cgroups>2. Cgroups</h3><p>Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。</p><blockquote><p>Linux Cgroups 的全称是 Linux Control Group。</p></blockquote><p><strong>它最主要的作用，就是限制一个进程组能够使用的资源上限</strong>，包括 CPU、内存、磁盘、网络带宽等等。</p><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1>#查看 cgroups 相关文件</span>
</span></span><span class=line><span class=cl>$ mount -t cgroup
</span></span><span class=line><span class=cl><span class=c1># 结果大概是这样的</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/systemd <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,xattr,release_agent<span class=o>=</span>/usr/lib/systemd/systemd-cgroups-agent,name<span class=o>=</span>systemd<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/net_cls,net_prio <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,net_prio,net_cls<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/memory <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,memory<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/devices <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,devices<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/cpu,cpuacct <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,cpuacct,cpu<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/cpuset <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,cpuset<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/perf_event <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,perf_event<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/freezer <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,freezer<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/blkio <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,blkio<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/hugetlb <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,hugetlb<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/pids <span class=nb>type</span> cgroup <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,pids<span class=o>)</span>
</span></span></code></pre></div><p>可以看到，在<code>/sys/fs/cgroup</code> 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。也就是这台机器当前可以被 Cgroups 进行限制的资源种类。</p><p>比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ls /sys/fs/cgroup/cpu
</span></span><span class=line><span class=cl><span class=c1># 目录下大概有这么一些内容</span>
</span></span><span class=line><span class=cl>assist                 cgroup.event_control  cgroup.sane_behavior  cpuacct.stat   cpuacct.usage_percpu  cpu.cfs_quota_us  cpu.rt_runtime_us  cpu.stat  notify_on_release  system.slice
</span></span><span class=line><span class=cl>cgroup.clone_children  cgroup.procs                 cpuacct.usage  cpu.cfs_period_us     cpu.rt_period_us  cpu.shares      release_agent      tasks
</span></span></code></pre></div><p><strong>例子：限制CPU使用</strong></p><p>而这样的配置文件又如何使用呢？</p><p>你需要在对应的子系统下面创建一个目录，比如，我们现在进入 /sys/fs/cgroup/cpu 目录下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>root@iz2ze0ephck4d0aztho5r5z cpu<span class=o>]</span><span class=c1># mkdir container</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iz2ze0ephck4d0aztho5r5z cpu<span class=o>]</span><span class=c1># ls container/</span>
</span></span><span class=line><span class=cl>cgroup.clone_children  cgroup.event_control  cgroup.procs  cpuacct.stat  cpuacct.usage  cpuacct.usage_percpu  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat  notify_on_release  tasks
</span></span></code></pre></div><p>这个目录就称为一个“控制组”。你会发现，操作系统会在你新创建的 container 目录下，自动生成该子系统对应的资源限制文件。</p><p>现在，我们在后台执行这样一条脚本:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ <span class=k>while</span> : <span class=p>;</span> <span class=k>do</span> : <span class=p>;</span> <span class=k>done</span> <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>27218</span>
</span></span></code></pre></div><p>显然，它执行了一个死循环，可以把计算机的 CPU 吃到 100%，根据它的输出，我们可以看到这个脚本在后台运行的进程号（PID）是 27218。</p><p>查看一下CPU占用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ top
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND    
</span></span><span class=line><span class=cl><span class=m>27218</span> root      <span class=m>20</span>   <span class=m>0</span>  <span class=m>115680</span>    <span class=m>672</span>    <span class=m>152</span> R 99.9  0.0   2:07.07 bash                                                  
</span></span></code></pre></div><p>果然这个PID=27218的进程占用了差不多100%的CPU。</p><p>结下来我们就通过Cgroups对其进行限制，这里就用前面创建的 container这个“控制组”。</p><p>我们可以通过查看 container 目录下的文件，看到 container 控制组里的 CPU quota 还没有任何限制（即：-1），CPU period 则是默认的 100 ms（100000 us）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us 
</span></span><span class=line><span class=cl>-1
</span></span><span class=line><span class=cl>$ cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us 
</span></span><span class=line><span class=cl><span class=m>100000</span>
</span></span></code></pre></div><p>接下来，我们可以通过修改这些文件的内容来设置限制。比如，向 container 组里的 cfs_quota 文件写入 20 ms（20000 us）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=m>20000</span> &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us
</span></span></code></pre></div><p>这样意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。</p><p>接下来，我们把被限制的进程的 PID 写入 container 组里的 tasks 文件，上面的设置就会对该进程生效了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=m>27218</span> &gt; /sys/fs/cgroup/cpu/container/tasks 
</span></span></code></pre></div><p>使用 top 指令查看一下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ top
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND    
</span></span><span class=line><span class=cl><span class=m>27218</span> root      <span class=m>20</span>   <span class=m>0</span>  <span class=m>115680</span>    <span class=m>672</span>    <span class=m>152</span> R <span class=m>20</span> 0.0   2:07.07 bash                                                  
</span></span></code></pre></div><p>果然CPU被限制到了20%.</p><p>除 CPU 子系统外，Cgroups 的每一个子系统都有其独有的资源限制能力，比如：</p><ul><li>blkio，为块设备设定I/O 限制，一般用于磁盘等设备；</li><li>cpuset，为进程分配单独的 CPU 核和对应的内存节点；</li><li>memory，为进程设定内存使用的限制。</li></ul><p><strong>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。</strong></p><p>而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。</p><p>而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -it --cpu-period<span class=o>=</span><span class=m>100000</span> --cpu-quota<span class=o>=</span><span class=m>20000</span> ubuntu /bin/bash
</span></span></code></pre></div><p>在启动这个容器后，我们可以通过查看 Cgroups 文件系统下，CPU 子系统中，“docker”这个控制组里的资源限制文件的内容来确认：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us 
</span></span><span class=line><span class=cl><span class=m>100000</span>
</span></span><span class=line><span class=cl>$ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us 
</span></span><span class=line><span class=cl><span class=m>20000</span>
</span></span></code></pre></div><p><strong>Cgroups 存在的问题</strong></p><p>Cgroups 对资源的限制能力也有很多不完善的地方，被提及最多的自然是 /proc 文件系统的问题。</p><p><strong>问题</strong></p><p>如果在容器里执行 top 指令，就会发现，它显示的信息居然是宿主机的 CPU 和内存数据，而不是当前容器的数据。</p><p>造成这个问题的原因就是，/proc 文件系统并不知道用户通过 Cgroups 给这个容器做了什么样的资源限制，即：/proc 文件系统不了解 Cgroups 限制的存在。</p><p><strong>解决方案</strong></p><p>使用 <code>lxcfs</code></p><p>top 命令是从 /prof/stats 目录下获取数据，所以从道理上来讲，容器不挂载宿主机的 /prof/stats 目录就可以了。</p><p>lxcfs就是来实现这个功能的，做法是把宿主机的 /var/lib/lxcfs/proc/memoinfo 文件挂载到Docker容器的/proc/meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制。从而使得应用获得正确的资源约束设定。kubernetes环境下，也能用，以 ds 方式运行 lxcfs ，自动给容器注入争取的 proc 信息。</p><h2 id=3-容器镜像>3. 容器镜像</h2><h3 id=1-文件系统>1. 文件系统</h3><p><strong>容器中的文件系统是什么样子的?</strong></p><p>因为容器中的文件系统经过 Mount Namespace 隔离，所以应该是独立的。</p><p>其中 <strong>Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知</strong>。只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。</p><p>不难想到，我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。</p><p>Linux 中<strong>chroot</strong>命令（change root file system）就能很方便的完成上述工作。</p><blockquote><p>而 Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。</p></blockquote><h3 id=2-rootfs>2. rootfs</h3><p><strong>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）</strong>。</p><p><strong>rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核</strong>。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p><p>所以说，rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。<strong>实际上，同一台机器上的所有容器，都共享宿主机操作系统的内核</strong>。</p><blockquote><p>这也是容器相比于虚拟机的主要缺陷之一：毕竟后者不仅有模拟出来的硬件机器充当沙盒，而且每个沙盒里还运行着一个完整的 Guest OS 给应用随便折腾。</p></blockquote><p>不过，正是<strong>由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：一致性</strong>。由于 rootfs 里打包的不只是应用，而是<strong>整个操作系统的文件和目录</strong>，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。</p><h3 id=3-镜像层layer>3. 镜像层（Layer）</h3><p>Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p><p><strong>通过引入层（layer）的概念，实现了 rootfs 的复用</strong>。不必每次都重新创建一个 rootfs，而是基于某一层进行修改即可。</p><p>Docker 镜像层用到了一种叫作**联合文件系统（Union File System）**的能力。Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。</p><blockquote><p>例如将目录A和目录B挂载到目录C下面，这样目录C下就包含目录A和目录B的所有文件。</p></blockquote><p>Docker 镜像分为多个层，然后使用 UFS 将这多个层挂载到一个目录下面，这样这个目录就包含了完整的文件了。</p><blockquote><p>UnionFS 在不同系统有各自的实现，所以Docker的不同发行版使用的也不一样，可以通过 docker info 查看。常见有 aufs（ubuntu常用）、overlay2（centos常用）</p></blockquote><p>镜像只包含了静态文件，但是容器会产生实时数据，所以容器的 rootfs 在镜像的基础上增加了<strong>可读写层和 Init 层</strong>。</p><blockquote><p>即容器 rootfs包括：只读层（镜像rootfs）+ init 层（容器启动时初始化修改的部分数据） + 可读写层（容器中产生的实时数据）。</p></blockquote><p><strong>只读层（镜像rootfs）</strong></p><p>它是这个容器的 rootfs 最下面的几层，即<strong>镜像中的所有层的总和</strong>，它们的挂载方式都是只读的（ro+wh，即 readonly+whiteout）</p><p><strong>可读写层（容器中产生的实时数据）</strong></p><p>它是这个容器的 rootfs 最上面的一层，它的挂载方式为：rw，即 read write。在没有写入文件之前，这个目录是空的。</p><p>而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中，删除操作实现比较特殊（类似于标记删除）。</p><p>AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。</p><p>为了实现删除操作，aufs（UnionFS的一种实现） 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。</p><blockquote><p>比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。</p></blockquote><p><strong>init 层（容器启动时初始化修改的部分数据）</strong></p><p>它是一个以“-init”结尾的层，夹在只读层和读写层之间，Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。</p><p><strong>为什么需要init层？</strong></p><p>比如 hostname 这样的数据，原本是属于镜像层的一部分，要修改的话只能在可读写层进行修改，但是又不想在 docker commit 的时候把这些信息提交上去，所以使用init 层来保存这些修改。</p><blockquote><p>可以理解为提交代码的时候一般也不会把各种配置信息一起提交上去。</p></blockquote><blockquote><p>docker commit 只会提交 只读层和可读写层。</p></blockquote><h2 id=4-小结>4. 小结</h2><p>Docker 容器的实现主要使用了如下3个功能：</p><ul><li><p>1）Linux Namespace 的隔离能力</p></li><li><p>2）Linux Cgroups 的限制能力</p></li><li><p>3）基于 rootfs 的文件系统</p></li></ul><p>Docker 容器全景图如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/docker/docker-overview.jpg data-srcset="https://github.com/barrypt/blog/raw/master/images/docker/docker-overview.jpg, https://github.com/barrypt/blog/raw/master/images/docker/docker-overview.jpg 1.5x, https://github.com/barrypt/blog/raw/master/images/docker/docker-overview.jpg 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/docker/docker-overview.jpg title=docker-overview></p><blockquote><p>图源：深入剖析Kubernetes</p></blockquote><h2 id=5-参考>5. 参考</h2><p><code>https://draveness.me/docker/</code></p><p><code>https://en.wikipedia.org/wiki/Linux_namespaces</code></p><p><code>https://0xax.gitbooks.io/linux-insides/content/Cgroups/linux-cgroups-1.html</code></p><p><code>https://coolshell.cn/articles/17061.html</code></p><p><code>深入剖析Kubernetes</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-02-14</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/docker/03-container-core/ data-title=Docker教程(三)---核心实现原理分析 data-hashtags=Docker><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/docker/03-container-core/ data-hashtag=Docker><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/docker/03-container-core/ data-title=Docker教程(三)---核心实现原理分析><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/docker/03-container-core/ data-title=Docker教程(三)---核心实现原理分析><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/docker/03-container-core/ data-title=Docker教程(三)---核心实现原理分析><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/docker/>Docker</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/grpc/09-retry/ class=prev rel=prev title=gRPC(Go)教程(九)---配置retry自动重试><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>gRPC(Go)教程(九)---配置retry自动重试</a>
<a href=/posts/docker/04-container-network/ class=next rel=next title=Docker教程(四)---容器网络实现分析>Docker教程(四)---容器网络实现分析<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>