<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo -</title><meta name=Description content="Cgroups 概念讲解及简单演示"><meta property="og:title" content="Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo"><meta property="og:description" content="Cgroups 概念讲解及简单演示"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/docker/08-cgroups-3/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-26T22:00:00+00:00"><meta property="article:modified_time" content="2022-02-26T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo"><meta name=twitter:description content="Cgroups 概念讲解及简单演示"><meta name=application-name content="指月小筑"><meta name=apple-mobile-web-app-title content="指月小筑"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/docker/08-cgroups-3/><link rel=prev href=https://blog.yudlk.com/posts/docker/07-cgroups-2/><link rel=next href=https://blog.yudlk.com/posts/etcd/15-raft-leader-election/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/docker\/08-cgroups-3\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Docker","wordcount":4990,"url":"https:\/\/blog.yudlk.com\/posts\/docker\/08-cgroups-3\/","datePublished":"2022-02-26T22:00:00+00:00","dateModified":"2022-02-26T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Cgroups 概念讲解及简单演示"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=指月小筑>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=指月小筑>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/lixd title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/docker/><i class="far fa-folder fa-fw" aria-hidden=true></i>Docker</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-02-26>2022-02-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4990 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;10 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-hierarchy>1. hierarchy</a><ul><li><a href=#创建>创建</a></li><li><a href=#删除>删除</a></li><li><a href=#文件含义>文件含义</a></li><li><a href=#release_agent>release_agent</a></li></ul></li><li><a href=#2-cgroup>2. cgroup</a><ul><li><a href=#创建-1>创建</a></li><li><a href=#删除-1>删除</a></li><li><a href=#添加进程>添加进程</a></li><li><a href=#cgroupprocs-vs-tasks>cgroup.procs vs tasks</a></li></ul></li><li><a href=#3-演示>3. 演示</a><ul><li><a href=#docker-是如何使用-cgroup-的>Docker 是如何使用 cgroup 的</a></li><li><a href=#go-demo>Go Demo</a></li></ul></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本章主要记录了 Cgroups 相关的命令和操作，最后用一个 Demo 演示了如何用 Go 语言操作 Cgroups。</p><blockquote><p>主要是之前学习 Cgroups 的时候没有找到相关命令，这里简单记录一下 Cgroup 具体是如何创建删除及管理的。</p></blockquote><blockquote><p>准备跟着《自己动手写 docker》这本书从零开始实现一个简易版的 docker，加深对 docker 的理解。</p><p>源码及相关教程见 <a href=https://github.com/lixd/mydocker target=_blank rel="noopener noreffer">Github</a>，欢迎 star。</p></blockquote><h2 id=1-hierarchy>1. hierarchy</h2><h3 id=创建>创建</h3><p>由于 Linux Cgroups 是基于内核中的 cgroup virtual filesystem 的，所以创建 hierarchy 其实就是将其挂载到指定目录。</p><p>语法为: <code>mount -t cgroup -o subsystems name /cgroup/name</code></p><ul><li>其中 subsystems 表示需要挂载的 cgroups 子系统</li><li>/cgroup/name 表示挂载点（一般为具体目录）</li></ul><p>这条命令同在内核中创建了一个 hierarchy 以及一个默认的 root cgroup。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir cg1
</span></span><span class=line><span class=cl>$ mount -t cgroup -o cpuset cg1 ./cg1
</span></span></code></pre></div><p>比如以上命令就是挂载一个 cg1 的 hierarchy 到 ./cg1 目录，如果指定的 hierarchy 不存在则会新建。</p><blockquote><p>hierarchy 创建的时候就会就会自动创建一个 cgroup 以作为 cgroup树中的 root 节点。</p></blockquote><h3 id=删除>删除</h3><p>删除 hierarchy 则是卸载。</p><p>语法为：<code>umount /cgroup/name</code></p><ul><li>/cgroup/name 表示挂载点（一般为具体目录）</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ umount ./cg1
</span></span></code></pre></div><p>以上命令就是卸载 ./cg1 这个目录上挂载的 hierarchy，也就是前面挂载的 cg。</p><blockquote><p>hierarchy 卸载后，相关的 cgroup 都会被删除。</p><p>不过 cg1 目录需要手动删除。</p></blockquote><h3 id=文件含义>文件含义</h3><p>hierarchy 挂载后会生成一些文件，具体如下：</p><blockquote><p>为了避免干扰，未关联任何 subsystem</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir cg1
</span></span><span class=line><span class=cl>$ mount -t cgroup -o none,name<span class=o>=</span>cg1 cg1 ./cg1
</span></span><span class=line><span class=cl>$ tree cg1
</span></span><span class=line><span class=cl>cg1
</span></span><span class=line><span class=cl>├── cgroup.clone_children
</span></span><span class=line><span class=cl>├── cgroup.procs
</span></span><span class=line><span class=cl>├── cgroup.sane_behavior
</span></span><span class=line><span class=cl>├── notify_on_release
</span></span><span class=line><span class=cl>├── release_agent
</span></span><span class=line><span class=cl>└── tasks
</span></span></code></pre></div><p>具体含义如下：</p><ul><li><strong>cgroup.clone_children</strong>：这个文件只对cpuset subsystem有影响，当该文件的内容为1时，新创建的cgroup将会继承父cgroup的配置，即从父cgroup里面拷贝配置文件来初始化新cgroup，可以参考<a href=https://lkml.org/lkml/2010/7/29/368 target=_blank rel="noopener noreffer">这里</a></li><li><strong>cgroup.procs</strong>：当前cgroup中的所有<strong>进程</strong>ID，系统不保证ID是顺序排列的，且ID有可能重复</li><li><strong>cgroup.sane_behavior</strong>：具体功能不详，可以参考<a href=https://lkml.org/lkml/2014/7/2/684 target=_blank rel="noopener noreffer">这里</a>和<a href=https://lkml.org/lkml/2014/7/2/686 target=_blank rel="noopener noreffer">这里</a></li><li><strong>notify_on_release</strong>：该文件的内容为1时，当cgroup退出时（不再包含任何进程和子cgroup），将调用release_agent里面配置的命令。<ul><li>新cgroup被创建时将默认继承父cgroup的这项配置。</li></ul></li><li><strong>release_agent</strong>：里面包含了cgroup退出时将会执行的命令，系统调用该命令时会将相应cgroup的相对路径当作参数传进去。<ul><li>注意：这个文件只会存在于root cgroup下面，其他cgroup里面不会有这个文件。</li><li>相当于配置一个回调用于清理资源。</li></ul></li><li><strong>tasks</strong>：当前cgroup中的所有<strong>线程</strong>ID，系统不保证ID是顺序排列的</li></ul><blockquote><p>cgroup.procs 和 tasks 的区别见 cgroup 操作章节。</p></blockquote><h3 id=release_agent>release_agent</h3><p>当一个cgroup里没有进程也没有子cgroup时，release_agent将被调用来执行cgroup的清理工作。</p><p>具体操作流程：</p><ul><li>首先需要配置 notify_on_release 以开启该功能。</li><li>然后将脚本内容写入到 release_agent 中去。</li><li>最后cgroup退出时（不再包含任何进程和子cgroup）就会执行 release_agent 中的命令。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#创建新的cgroup用于演示</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo mkdir <span class=nb>test</span>
</span></span><span class=line><span class=cl><span class=c1>#先enable release_agent</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo sh -c <span class=s1>&#39;echo 1 &gt; ./test/notify_on_release&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#然后创建一个脚本/home/dev/cgroup/release_demo.sh，</span>
</span></span><span class=line><span class=cl><span class=c1>#一般情况下都会利用这个脚本执行一些cgroup的清理工作，但我们这里为了演示简单，仅仅只写了一条日志到指定文件</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ cat &gt; /home/dev/cgroup/release_demo.sh <span class=s>&lt;&lt; EOF
</span></span></span><span class=line><span class=cl><span class=s>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=s>echo \$0:\$1 &gt;&gt; /home/dev/release_demo.log
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#添加可执行权限</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ chmod +x ../release_demo.sh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#将该脚本设置进文件release_agent</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo sh -c <span class=s1>&#39;echo /home/dev/cgroup/release_demo.sh &gt; ./release_agent&#39;</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ cat release_agent
</span></span><span class=line><span class=cl>/home/dev/cgroup/release_demo.sh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#往test里面添加一个进程，然后再移除，这样就会触发release_demo.sh</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ <span class=nb>echo</span> <span class=nv>$$</span>
</span></span><span class=line><span class=cl><span class=m>27597</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo sh -c <span class=s1>&#39;echo 27597 &gt; ./test/cgroup.procs&#39;</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo sh -c <span class=s1>&#39;echo 27597 &gt; ./cgroup.procs&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#从日志可以看出，release_agent被触发了，/test是cgroup的相对路径</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ cat /home/dev/release_demo.log
</span></span><span class=line><span class=cl>/home/dev/cgroup/release_demo.sh:/test
</span></span></code></pre></div><h2 id=2-cgroup>2. cgroup</h2><h3 id=创建-1>创建</h3><p>创建 cgroup 很简单，在父 cgroup 或者 hierarchy 目录下新建一个目录就可以了。</p><blockquote><p>具体层级关系就和目录层级关系一样。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 创建子cgroup cgroup-cpu</span>
</span></span><span class=line><span class=cl>$ mkdir cgroup-cpu
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> cgroup-cpu
</span></span><span class=line><span class=cl><span class=c1># 创建cgroup-cpu的子cgroup</span>
</span></span><span class=line><span class=cl>$ mkdir cgroup-cpu-1
</span></span></code></pre></div><h3 id=删除-1>删除</h3><p>删除也很简单，删除对应<strong>目录</strong>即可。</p><blockquote><p>注意：是删除目录 rmdir，而不是递归删除目录下的所有文件。</p></blockquote><p>如果有多层 cgroup 则需要先删除子 cgroup，否则会报错：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ rmdir cgroup-cpu
</span></span><span class=line><span class=cl><span class=c1># 如果cgroup中有进程正在本限制，也会出现这个错误，需要先停掉对应进程，或者把进程移动到另外的 cgroup 中(比如父cgroup)</span>
</span></span><span class=line><span class=cl>rmdir: failed to remove <span class=s1>&#39;cgroup-cpu&#39;</span>: Device or resource busy
</span></span></code></pre></div><p>先删除子 cgroup 就可以了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ rmdir cg1
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> ../
</span></span><span class=line><span class=cl>$ rmdir cgroup-cpu
</span></span></code></pre></div><p>也可以借助 libcgroup 工具来创建或删除。</p><p>使用 libcgroup 工具前，请先安装 libcgroup 和 libcgroup-tools 数据包</p><p>redhat系统安装：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ yum install libcgroup
</span></span><span class=line><span class=cl>$ yum install libcgroup-tools
</span></span></code></pre></div><p>ubuntu系统安装:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ apt-get install cgroup-bin
</span></span><span class=line><span class=cl><span class=c1># 如果提示cgroup-bin找不到，可以用 cgroup-tools 替换</span>
</span></span><span class=line><span class=cl>$ apt-get install cgroup-tools
</span></span></code></pre></div><p>具体语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># controllers就是subsystem</span>
</span></span><span class=line><span class=cl><span class=c1># path可以用相对路径或者绝对路径</span>
</span></span><span class=line><span class=cl>$ cgdelete controllers:path
</span></span></code></pre></div><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cgcreate cpu:./mycgroup
</span></span><span class=line><span class=cl>$ cgdelete cpu:./mycgroup
</span></span></code></pre></div><h3 id=添加进程>添加进程</h3><p>创建新的 cgroup 后，就可以往里面添加进程了。注意下面几点：</p><ul><li>在一颗 cgroup 树里面，<strong>一个进程必须要属于一个 cgroup</strong>。<ul><li>所以不能凭空从一个 cgroup 里面删除一个进程，只能将一个进程从一个 cgroup 移到另一个 cgroup</li></ul></li><li>新创建的子进程将会自动加入父进程所在的 cgroup。<ul><li>这也就是 tasks 和 cgroup.proc 的区别。</li></ul></li><li>从一个 cgroup 移动一个进程到另一个 cgroup 时，只要有目的 cgroup 的写入权限就可以了，系统不会检查源 cgroup 里的权限。</li><li>用户只能操作属于自己的进程，不能操作其他用户的进程，root 账号除外。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#--------------------------第一个shell窗口----------------------</span>
</span></span><span class=line><span class=cl><span class=c1>#创建一个新的cgroup</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo mkdir <span class=nb>test</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ <span class=nb>cd</span> <span class=nb>test</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#将当前bash加入到上面新创建的cgroup中</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ <span class=nb>echo</span> <span class=nv>$$</span>
</span></span><span class=line><span class=cl><span class=m>1421</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ sudo sh -c <span class=s1>&#39;echo 1421 &gt; cgroup.procs&#39;</span>
</span></span><span class=line><span class=cl><span class=c1>#注意：一次只能往这个文件中写一个进程ID，如果需要写多个的话，需要多次调用这个命令</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#--------------------------第二个shell窗口----------------------</span>
</span></span><span class=line><span class=cl><span class=c1>#重新打开一个shell窗口，避免第一个shell里面运行的命令影响输出结果</span>
</span></span><span class=line><span class=cl><span class=c1>#这时可以看到cgroup.procs里面包含了上面的第一个shell进程</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ cat cgroup.procs
</span></span><span class=line><span class=cl><span class=m>1421</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#--------------------------第一个shell窗口----------------------</span>
</span></span><span class=line><span class=cl><span class=c1>#回到第一个窗口，随便运行一个命令，比如 top</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ top
</span></span><span class=line><span class=cl><span class=c1>#这里省略输出内容</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#--------------------------第二个shell窗口----------------------</span>
</span></span><span class=line><span class=cl><span class=c1>#这时再在第二个窗口查看，发现top进程自动加入了它的父进程（1421）所在的cgroup</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ cat cgroup.procs
</span></span><span class=line><span class=cl><span class=m>1421</span>
</span></span><span class=line><span class=cl><span class=m>16515</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ ps -ef<span class=p>|</span>grep top
</span></span><span class=line><span class=cl>dev      <span class=m>16515</span>  <span class=m>1421</span>  <span class=m>0</span> 04:02 pts/0    00:00:00 top
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#在一颗cgroup树里面，一个进程必须要属于一个cgroup，</span>
</span></span><span class=line><span class=cl><span class=c1>#所以我们不能凭空从一个cgroup里面删除一个进程，只能将一个进程从一个cgroup移到另一个cgroup，</span>
</span></span><span class=line><span class=cl><span class=c1>#这里我们将1421移动到root cgroup</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ sudo sh -c <span class=s1>&#39;echo 1421 &gt; ../cgroup.procs&#39;</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ cat cgroup.procs
</span></span><span class=line><span class=cl><span class=m>16515</span>
</span></span><span class=line><span class=cl><span class=c1>#移动1421到另一个cgroup之后，它的子进程不会随着移动</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#--------------------------第一个shell窗口----------------------</span>
</span></span><span class=line><span class=cl><span class=c1>##回到第一个shell窗口，进行清理工作</span>
</span></span><span class=line><span class=cl><span class=c1>#先用ctrl+c退出top命令</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo/test$ <span class=nb>cd</span> ..
</span></span><span class=line><span class=cl><span class=c1>#然后删除创建的cgroup</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo rmdir <span class=nb>test</span>
</span></span></code></pre></div><h3 id=cgroupprocs-vs-tasks>cgroup.procs vs tasks</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#创建两个新的cgroup用于演示</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo mkdir c1 c2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#为了便于操作，先给root账号设置一个密码，然后切换到root账号</span>
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ sudo passwd root
</span></span><span class=line><span class=cl>dev@ubuntu:~/cgroup/demo$ su root
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo#
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#系统中找一个有多个线程的进程</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# ps -efL<span class=p>|</span>grep /lib/systemd/systemd-timesyncd
</span></span><span class=line><span class=cl>systemd+   <span class=m>610</span>     <span class=m>1</span>   <span class=m>610</span>  <span class=m>0</span>    <span class=m>2</span> 01:52 ?        00:00:00 /lib/systemd/systemd-timesyncd
</span></span><span class=line><span class=cl>systemd+   <span class=m>610</span>     <span class=m>1</span>   <span class=m>616</span>  <span class=m>0</span>    <span class=m>2</span> 01:52 ?        00:00:00 /lib/systemd/systemd-timesyncd
</span></span><span class=line><span class=cl><span class=c1>#进程610有两个线程，分别是610和616</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#将616加入c1/cgroup.procs</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# <span class=nb>echo</span> <span class=m>616</span> &gt; c1/cgroup.procs
</span></span><span class=line><span class=cl><span class=c1>#由于cgroup.procs存放的是进程ID，所以这里看到的是616所属的进程ID（610）</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# cat c1/cgroup.procs
</span></span><span class=line><span class=cl><span class=m>610</span>
</span></span><span class=line><span class=cl><span class=c1>#从tasks中的内容可以看出，虽然只往cgroup.procs中加了线程616，</span>
</span></span><span class=line><span class=cl><span class=c1>#但系统已经将这个线程所属的进程的所有线程都加入到了tasks中，</span>
</span></span><span class=line><span class=cl><span class=c1>#说明现在整个进程的所有线程已经处于c1中了</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# cat c1/tasks
</span></span><span class=line><span class=cl><span class=m>610</span>
</span></span><span class=line><span class=cl><span class=m>616</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#将616加入c2/tasks中</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# <span class=nb>echo</span> <span class=m>616</span> &gt; c2/tasks
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#这时我们看到虽然在c1/cgroup.procs和c2/cgroup.procs里面都有610，</span>
</span></span><span class=line><span class=cl><span class=c1>#但c1/tasks和c2/tasks中包含了不同的线程，说明这个进程的两个线程分别属于不同的cgroup</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# cat c1/cgroup.procs
</span></span><span class=line><span class=cl><span class=m>610</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# cat c1/tasks
</span></span><span class=line><span class=cl><span class=m>610</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# cat c2/cgroup.procs
</span></span><span class=line><span class=cl><span class=m>610</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# cat c2/tasks
</span></span><span class=line><span class=cl><span class=m>616</span>
</span></span><span class=line><span class=cl><span class=c1>#通过tasks，我们可以实现线程级别的管理，但通常情况下不会这么用，</span>
</span></span><span class=line><span class=cl><span class=c1>#并且在cgroup V2以后，将不再支持该功能，只能以进程为单位来配置cgroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#清理</span>
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# <span class=nb>echo</span> <span class=m>610</span> &gt; ./cgroup.procs
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# rmdir c1
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# rmdir c2
</span></span><span class=line><span class=cl>root@ubuntu:/home/dev/cgroup/demo# <span class=nb>exit</span>
</span></span><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></div><p>结论：将线程ID加到 cgroup1的 cgroup.procs 时，会把线程对应进程ID加入 cgroup.procs 且还会把当前进程下的全部线程ID加入到 tasks 中。</p><blockquote><p>这里看起来，进程和线程好像效果是一样的。</p></blockquote><p>区别来了，如果此时把某个线程ID移动到另外的 cgroup2 的 tasks 中，会自动把 线程ID对应的进程ID加入到 cgroup2 的 cgroup.procs 中，且只把对应线程加入 tasks 中。</p><p>此时 cgroup1和cgroup2 的 cgroup.procs 都包含了同一个进程ID，但是二者的 tasks 中却包含了不同的线程ID。</p><p>这样就实现了<strong>线程粒度的控制</strong>。但通常情况下不会这么用，并且在cgroup V2以后，将不再支持该功能，只能以进程为单位来配置cgroup。</p><h2 id=3-演示>3. 演示</h2><h3 id=docker-是如何使用-cgroup-的>Docker 是如何使用 cgroup 的</h3><p>我们知道 Docker 是通过 Cgroups 实现容器资源限制和监控的，那么具体是怎么用的呢？</p><p>先启动一个容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ memory<span class=o>]</span><span class=c1># docker run -itd -m 128m nginx</span>
</span></span><span class=line><span class=cl>da82f9ebd384730dda7f831b4331c9e55893c100c83c0c9b0ce112436aa93416
</span></span></code></pre></div><p>这里通过<code>docker run -m</code>参数设置了内存限制。</p><p>实际上 docker 会在 memory cgroup 上创建一个叫 docker 的子 cgroup</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ls -l /sys/fs/cgroup/memory/docker/
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> root root <span class=m>0</span> Jan  <span class=m>6</span> 19:53 cgroup.clone_children
</span></span><span class=line><span class=cl>--w--w--w- <span class=m>1</span> root root <span class=m>0</span> Jan  <span class=m>6</span> 19:53 cgroup.event_control
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> root root <span class=m>0</span> Jan  <span class=m>6</span> 19:53 cgroup.procs
</span></span><span class=line><span class=cl><span class=c1># 可以发现这一长串ID和创建容器时打印的是一致的</span>
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>2</span> root root <span class=m>0</span> Jan  <span class=m>6</span> 19:56 da82f9ebd384730dda7f831b4331c9e55893c100c83c0c9b0ce112436aa93416
</span></span><span class=line><span class=cl><span class=c1># 省略其他文件</span>
</span></span></code></pre></div><p>说明 docker 是为每个容器创建了一个子 cgroup 来单独限制。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ docker<span class=o>]</span><span class=c1># cd da82f9ebd384730dda7f831b4331c9e55893c100c83c0c9b0ce112436aa93416/</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ da82f9ebd384730dda7f831b4331c9e55893c100c83c0c9b0ce112436aa93416<span class=o>]</span><span class=c1># cat memory.limit_in_bytes </span>
</span></span><span class=line><span class=cl><span class=m>134217728</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@iZ2zefmrr626i66omb40ryZ da82f9ebd384730dda7f831b4331c9e55893c100c83c0c9b0ce112436aa93416<span class=o>]</span><span class=c1># </span>
</span></span></code></pre></div><p>可以发现，这里面限制的内存 134217728/1024/1024 刚好就是我们指定的 128M。</p><p>所以 docker 使用 cgroup 其实很简单，就是根据用户指定的参数创建对应的 cgroup 限制。</p><h3 id=go-demo>Go Demo</h3><p>其实挺简单的，就是用 Go 翻译了一遍上面的命令。</p><p>具体代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// cGroups cGroups初体验
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>cGroups</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// /proc/self/exe是一个符号链接，代表当前程序的绝对路径
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s>&#34;/proc/self/exe&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 第一个参数就是当前执行的文件名，所以只有fork出的容器进程才会进入该分支
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;容器进程内部 PID %d\n&#34;</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>Getpid</span><span class=p>())</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 需要先在宿主机上安装 stress 比如 apt-get install stress
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>cmd</span> <span class=o>:=</span> <span class=nx>exec</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=s>&#34;sh&#34;</span><span class=p>,</span> <span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=s>`stress --vm-bytes 200m --vm-keep -m 1`</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>SysProcAttr</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SysProcAttr</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdin</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdin</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdout</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stderr</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 主进程会走这个分支
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>cmd</span> <span class=o>:=</span> <span class=nx>exec</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=s>&#34;/proc/self/exe&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>SysProcAttr</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SysProcAttr</span><span class=p>{</span><span class=nx>Cloneflags</span><span class=p>:</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWUTS</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWNS</span> <span class=p>|</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>CLONE_NEWPID</span><span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdin</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdin</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdout</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stderr</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Start</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 得到 fork 出来的进程在外部namespace 的 pid
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;fork 进程 PID：&#34;</span><span class=p>,</span> <span class=nx>cmd</span><span class=p>.</span><span class=nx>Process</span><span class=p>.</span><span class=nx>Pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 在默认的 memory cgroup 下创建子目录，即创建一个子 cgroup
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Mkdir</span><span class=p>(</span><span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>cgroupMemoryHierarchyMount</span><span class=p>,</span> <span class=s>&#34;testmemorylimit&#34;</span><span class=p>),</span> <span class=mo>0755</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 	将容器加入到这个 cgroup 中，即将进程PID加入到cgroup下的 cgroup.procs 文件中
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>err</span> <span class=p>=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>WriteFile</span><span class=p>(</span><span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>cgroupMemoryHierarchyMount</span><span class=p>,</span> <span class=s>&#34;testmemorylimit&#34;</span><span class=p>,</span> <span class=s>&#34;cgroup.procs&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>strconv</span><span class=p>.</span><span class=nf>Itoa</span><span class=p>(</span><span class=nx>cmd</span><span class=p>.</span><span class=nx>Process</span><span class=p>.</span><span class=nx>Pid</span><span class=p>)),</span> <span class=mo>0644</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 	限制进程的内存使用，往 memory.limit_in_bytes 文件中写入数据
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>err</span> <span class=p>=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>WriteFile</span><span class=p>(</span><span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>cgroupMemoryHierarchyMount</span><span class=p>,</span> <span class=s>&#34;testmemorylimit&#34;</span><span class=p>,</span> <span class=s>&#34;memory.limit_in_bytes&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;100m&#34;</span><span class=p>),</span> <span class=mo>0644</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>cmd</span><span class=p>.</span><span class=nx>Process</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>首先是一个 if 判断，区分主进程和子进程，分别执行不同逻辑。</p><ul><li>主进程：fork 出子进程，并创建 cgroup，然后将子进程加入该 cgrouop</li><li>子进程：执行 stress 命令，以消耗内存，便于查看 memory cgroup 的效果</li></ul><p>运行并测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>lixd  ~/projects/docker/mydocker main $ go build main.go
</span></span><span class=line><span class=cl>lixd  ~/projects/docker/mydocker main $ sudo ./main
</span></span><span class=line><span class=cl>fork 进程 PID： <span class=m>21827</span>
</span></span><span class=line><span class=cl>当前进程 pid <span class=m>1</span>
</span></span><span class=line><span class=cl>stress: info: <span class=o>[</span>7<span class=o>]</span> dispatching hogs: <span class=m>0</span> cpu, <span class=m>0</span> io, <span class=m>1</span> vm, <span class=m>0</span> hdd
</span></span></code></pre></div><p>根据输出可以知道，我们 fork 出的进程，pid 为 21827。</p><p>通过<code>pstree -pl</code>查看进程关系：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>$pstree</span> -pl
</span></span><span class=line><span class=cl>init<span class=o>(</span>1<span class=o>)</span>─┬─init<span class=o>(</span>8<span class=o>)</span>───init<span class=o>(</span>9<span class=o>)</span>───fsnotifier-wsl<span class=o>(</span>10<span class=o>)</span>
</span></span><span class=line><span class=cl>        ├─init<span class=o>(</span>12<span class=o>)</span>───init<span class=o>(</span>13<span class=o>)</span>─┬─exe<span class=o>(</span>20618<span class=o>)</span>─┬─sh<span class=o>(</span>20623<span class=o>)</span>───stress<span class=o>(</span>20624<span class=o>)</span>───stress<span class=o>(</span>20625<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                     │            ├─<span class=o>{</span>exe<span class=o>}(</span>20619<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                     │            ├─<span class=o>{</span>exe<span class=o>}(</span>20620<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                     │            ├─<span class=o>{</span>exe<span class=o>}(</span>20621<span class=o>)</span>
</span></span><span class=line><span class=cl>        │                     │            └─<span class=o>{</span>exe<span class=o>}(</span>20622<span class=o>)</span>
</span></span><span class=line><span class=cl>└─zsh<span class=o>(</span>14<span class=o>)</span>───sudo<span class=o>(</span>21821<span class=o>)</span>───main<span class=o>(</span>21822<span class=o>)</span>─┬─exe<span class=o>(</span>21827<span class=o>)</span>─┬─sh<span class=o>(</span>21832<span class=o>)</span>───stress<span class=o>(</span>21833<span class=o>)</span>───stress<span class=o>(</span>21834<span class=o>)</span>
</span></span></code></pre></div><p>可以看到 21827 进程 最终启动了一个 21834 的 stress 进程。</p><p><code>top</code>查看以下内存占用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
</span></span><span class=line><span class=cl><span class=m>21834</span> root      <span class=m>20</span>   <span class=m>0</span>  <span class=m>208664</span> <span class=m>101564</span>    <span class=m>272</span> D  35.2   1.3   0:14.38 stress
</span></span></code></pre></div><p>可以看到 RES 101564，也就是刚好100M，说明我们的 cgroup 是有效果的。</p><h2 id=4-小结>4. 小结</h2><p>本文主要介绍了 hierarchy 和 cgroup 相关的操作，如创建删除。</p><p>接着介绍了 hierarchy 中各个文件含义，重点包括 release_agent 的作用以及 cgroup.procs 和 tasks 的区别。</p><p>最后简答介绍了 Docker 是如何使用 cgroup 的，并提供了一个简单的 Go 语言操作 cgroup demo。</p><h2 id=5-参考>5. 参考</h2><p><a href=https://man7.org/linux/man-pages/man7/cgroups.7.html target=_blank rel="noopener noreffer">cgroups(7) — Linux manual page</a></p><p><a href=https://segmentfault.com/a/1190000007241437 target=_blank rel="noopener noreffer">Linux Cgroup系列（02）：创建并管理cgroup</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-02-26</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/docker/08-cgroups-3/ data-title="Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo" data-hashtags=Docker><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/docker/08-cgroups-3/ data-hashtag=Docker><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/docker/08-cgroups-3/ data-title="Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/docker/08-cgroups-3/ data-title="Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/docker/08-cgroups-3/ data-title="Docker教程(八)---Cgroups-3-相关命令汇总及Go Demo"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/docker/>Docker</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/docker/07-cgroups-2/ class=prev rel=prev title=Docker教程(七)---Cgroups-2-subsystem演示><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Docker教程(七)---Cgroups-2-subsystem演示</a>
<a href=/posts/etcd/15-raft-leader-election/ class=next rel=next title=etcd教程(十五)---leader选取源码分析>etcd教程(十五)---leader选取源码分析<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/lixd target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>