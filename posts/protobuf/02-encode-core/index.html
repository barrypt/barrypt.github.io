<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>protobuf教程(二)---核心编码原理 -</title><meta name=Description content="protobuf 核心编码原理"><meta property="og:title" content="protobuf教程(二)---核心编码原理"><meta property="og:description" content="protobuf 核心编码原理"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/protobuf/02-encode-core/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-12T22:00:00+00:00"><meta property="article:modified_time" content="2021-03-12T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="protobuf教程(二)---核心编码原理"><meta name=twitter:description content="protobuf 核心编码原理"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/protobuf/02-encode-core/><link rel=prev href=https://blog.yudlk.com/posts/protobuf/01-import/><link rel=next href=https://blog.yudlk.com/posts/kubernetes/04-service-core/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"protobuf教程(二)---核心编码原理","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/protobuf\/02-encode-core\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"protobuf","wordcount":3994,"url":"https:\/\/blog.yudlk.com\/posts\/protobuf\/02-encode-core\/","datePublished":"2021-03-12T22:00:00+00:00","dateModified":"2021-03-12T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"protobuf 核心编码原理"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">protobuf教程(二)---核心编码原理</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/protobuf/><i class="far fa-folder fa-fw" aria-hidden=true></i>protobuf</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-03-12>2021-03-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;3994 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;8 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-varint-编码>1. Varint 编码</a><ul><li><a href=#原理>原理</a></li><li><a href=#缺点>缺点</a></li></ul></li><li><a href=#2-zigzag编码>2. ZigZag编码</a><ul><li><a href=#原理-1>原理</a></li><li><a href=#具体实现>具体实现</a></li></ul></li><li><a href=#3-message-structure-编码>3. Message Structure 编码</a><ul><li><a href=#1-wire_type>1. wire_type</a></li><li><a href=#2-tag>2. Tag</a></li><li><a href=#3-signed-integers-编码>3. Signed Integers 编码</a></li><li><a href=#4-non-varint-numbers>4. Non-varint Numbers</a></li><li><a href=#5-字符串>5. 字符串</a></li><li><a href=#6-嵌入式-message>6. 嵌入式 message</a></li><li><a href=#7-packed-repeated-fields>7. Packed Repeated Fields</a></li></ul></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本章主要记录了 protobuf 的核心编码原理，包括 Varint 编码、ZigZag编码及 protobuf 特有的 Message Structure 编码结构等。</p><p>Protocol buffers 核心就是对单个数据的编码（Varint 编码）以及对数据整体的编码（Message Structure 编码）。</p><h2 id=1-varint-编码>1. Varint 编码</h2><blockquote><p>protobuf 编码主要依赖于 Varint 编码。</p></blockquote><h3 id=原理>原理</h3><p>Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。</p><p>Varint 中的每个字节（最后一个字节除外）都设置了最高有效位（msb），这一位表示是否还会有更多字节出现。每个字节的低 7 位用于以 7 位组的形式存储数字的二进制补码表示，最低有效组首位。</p><blockquote><p>最高位为1代表后面7位仍然表示数字，否则为0，后面7位用原码补齐。</p></blockquote><p>如果用不到 1 个字节，那么最高有效位设为 0 ，如下面这个例子，1 用一个字节就可以表示，所以 msb 为 0.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=mo>0000</span> <span class=mo>0001</span>
</span></span></code></pre></div><p>如果需要多个字节表示，msb 就应该设置为 1 。例如 300，如果用 Varint 表示的话：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=mi>1010</span> <span class=mi>1100</span> <span class=mo>0000</span> <span class=mo>0010</span>
</span></span></code></pre></div><p>编码方式</p><ul><li><p>1）将被编码数转换为二进制表示</p></li><li><p>2）从低位到高位按照 7位 一组进行划分</p></li><li><p>3）将大端序转为小端序，即以分组为单位进行首尾顺序交换</p><ul><li>因为 protobuf 使用是小端序，所以需要转换一下</li></ul></li><li><p>4）给每组加上最高有效位(最后一个字节高位补0，其余各字节高位补1)组成编码后的数据。</p></li><li><p>5）最后转成 10 进制。</p></li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/protobuf/varints-encode.png data-srcset="https://github.com/barrypt/blog/raw/master/images/protobuf/varints-encode.png, https://github.com/barrypt/blog/raw/master/images/protobuf/varints-encode.png 1.5x, https://github.com/barrypt/blog/raw/master/images/protobuf/varints-encode.png 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/protobuf/varints-encode.png title=varints-encode></p><p>图中对数字123456进行 varint 编码：</p><ul><li>1）123456 用二进制表示为<code>1 11100010 01000000</code>，</li><li>2）每次从低向高取 7位 变成<code>111</code> <code>1000100</code> <code>1000000</code></li><li>3）大端序转为小端序，即交换字节顺序变成<code>1000000</code> <code>1000100</code> <code>111</code></li><li>4）然后加上最高有效位(即：最后一个字节高位补0，其余各字节高位补1)变成<code>11000000</code> <code>11000100</code> <code>00000111</code></li><li>5）最后再转成 10进制，所以经过 varint 编码后 123456 占用三个字节分别为<code>192 196 7</code>。</li></ul><p>解码的过程就是将字节依次取出，去掉最高有效位，因为是小端排序所以先解码的字节要放在低位，之后解码出来的二进制位继续放在之前已经解码出来的二进制的高位最后转换为10进制数完成varint编码的解码过程。</p><h3 id=缺点>缺点</h3><p>负数需要10个字节显示（因为计算机定义负数的符号位为数字的最高位）。</p><blockquote><p>具体是先将负数是转成了 long 类型，再进行 varint 编码，这就是占用 10个 字节的原因了。</p></blockquote><p><strong>protobuf 采取的解决方式：使用 sint32/sint64 类型表示负数，通过先采用 Zigzag 编码，将正数、负数和0都映射到无符号数，最后再采用 varint 编码</strong>。</p><p><strong>具体实现</strong></p><blockquote><p>github.com/golang/protobuf</p></blockquote><p>编码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>maxVarintBytes</span> <span class=p>=</span> <span class=mi>10</span> <span class=c1>// maximum length of a varint
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 返回Varint类型编码后的字节流
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>EncodeVarint</span><span class=p>(</span><span class=nx>x</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>buf</span> <span class=p>[</span><span class=nx>maxVarintBytes</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>n</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 下面的编码规则需要详细理解:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 1.每个字节的最高位是保留位, 如果是1说明后面的字节还是属于当前数据的,如果是0,那么这是当前数据的最后一个字节数据
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  看下面代码,因为一个字节最高位是保留位,那么这个字节中只有下面7bits可以保存数据
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  所以,如果x&gt;127,那么说明这个数据还需大于一个字节保存,所以当前字节最高位是1,看下面的buf[n] = 0x80 | ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  0x80说明将这个字节最高位置为1, 后面的x&amp;0x7F是取得x的低7位数据, 那么0x80 | uint8(x&amp;0x7F)整体的意思就是
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//  这个字节最高位是1表示这不是最后一个字节,后面7为是正式数据! 注意操作下一个字节之前需要将x&gt;&gt;=7
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 2.看如果x&lt;=127那么说明x现在使用7bits可以表示了,那么最高位没有必要是1,直接是0就ok!所以最后直接是buf[n] = uint8(x)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 如果数据大于一个字节(127是一个字节最大数据), 那么继续, 即: 需要在最高位加上1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>n</span> <span class=p>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>x</span> <span class=p>&gt;</span> <span class=mi>127</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=c1>// x&amp;0x7F表示取出下7bit数据, 0x80表示在最高位加上1
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>buf</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=p>=</span> <span class=mh>0x80</span> <span class=p>|</span> <span class=nb>uint8</span><span class=p>(</span><span class=nx>x</span><span class=o>&amp;</span><span class=mh>0x7F</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 右移7位, 继续后面的数据处理
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>x</span> <span class=o>&gt;&gt;=</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 最后一个字节数据
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>buf</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=p>=</span> <span class=nb>uint8</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>buf</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=nx>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>解码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>buf</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>x</span> <span class=kt>uint64</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>shift</span> <span class=o>:=</span> <span class=nb>uint</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>shift</span> <span class=p>&lt;</span> <span class=mi>64</span><span class=p>;</span> <span class=nx>shift</span> <span class=o>+=</span> <span class=mi>7</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>n</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>b</span> <span class=o>:=</span> <span class=nb>uint64</span><span class=p>(</span><span class=nx>buf</span><span class=p>[</span><span class=nx>n</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=nx>n</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 下面这个分成三步走:
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 1: b &amp; 0x7F 获取下7bits有效数据
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 2: (b &amp; 0x7F) &lt;&lt; shift 由于是小端序, 所以每次处理一个Byte数据, 都需要向高位移动7bits
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 3: 将数据x和当前的这个字节数据 | 在一起
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>x</span> <span class=o>|=</span> <span class=p>(</span><span class=nx>b</span> <span class=o>&amp;</span> <span class=mh>0x7F</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=nx>shift</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=nx>b</span> <span class=o>&amp;</span> <span class=mh>0x80</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// The number is too large to represent in a 64-bit value.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2-zigzag编码>2. ZigZag编码</h2><h3 id=原理-1>原理</h3><p>ZigZag 是将符号数统一映射到无符号号数的一种编码方案，具体映射函数为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>Zigzag<span class=o>(</span>n<span class=o>)</span> <span class=o>=</span> <span class=o>(</span>n <span class=s>&lt;&lt; 1) ^ (n &gt;&gt; 31</span><span class=o>)</span>, n 为 sint32 时
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Zigzag<span class=o>(</span>n<span class=o>)</span> <span class=o>=</span> <span class=o>(</span>n &lt;&lt; 1<span class=o>)</span> ^ <span class=o>(</span>n &gt;&gt; 63<span class=o>)</span>, n 为 sint64 时
</span></span></code></pre></div><p>比如：对于0 -1 1 -2 2映射到无符号数 0 1 2 3 4。</p><table><thead><tr><th>原始值</th><th style=text-align:left>映射值</th></tr></thead><tbody><tr><td>0</td><td style=text-align:left>0</td></tr><tr><td>-1</td><td style=text-align:left>1</td></tr><tr><td>1</td><td style=text-align:left>2</td></tr><tr><td>2</td><td style=text-align:left>3</td></tr><tr><td>-2</td><td style=text-align:left>4</td></tr></tbody></table><h3 id=具体实现>具体实现</h3><p>编码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Encode a ZigZag-encoded 32-bit value.  ZigZag encodes signed integers
</span></span></span><span class=line><span class=cl><span class=cm>   * into values that can be efficiently encoded with varint.  (Otherwise,
</span></span></span><span class=line><span class=cl><span class=cm>   * negative values must be sign-extended to 64 bits to be varint encoded,
</span></span></span><span class=line><span class=cl><span class=cm>   * thus always taking 10 bytes on the wire.)
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * @param n A signed 32-bit integer.
</span></span></span><span class=line><span class=cl><span class=cm>   * @return An unsigned 32-bit integer, stored in a signed int because
</span></span></span><span class=line><span class=cl><span class=cm>   *         Java has no explicit unsigned support.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=n>public</span> <span class=k>static</span> <span class=kt>int</span> <span class=nf>encodeZigZag32</span><span class=p>(</span><span class=n>final</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Note:  the right-shift must be arithmetic
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>^</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>31</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Encode a ZigZag-encoded 64-bit value.  ZigZag encodes signed integers
</span></span></span><span class=line><span class=cl><span class=cm>   * into values that can be efficiently encoded with varint.  (Otherwise,
</span></span></span><span class=line><span class=cl><span class=cm>   * negative values must be sign-extended to 64 bits to be varint encoded,
</span></span></span><span class=line><span class=cl><span class=cm>   * thus always taking 10 bytes on the wire.)
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * @param n A signed 64-bit integer.
</span></span></span><span class=line><span class=cl><span class=cm>   * @return An unsigned 64-bit integer, stored in a signed int because
</span></span></span><span class=line><span class=cl><span class=cm>   *         Java has no explicit unsigned support.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=n>public</span> <span class=k>static</span> <span class=kt>long</span> <span class=nf>encodeZigZag64</span><span class=p>(</span><span class=n>final</span> <span class=kt>long</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Note:  the right-shift must be arithmetic
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>^</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>63</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>解码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Decode a ZigZag-encoded 32-bit value. ZigZag encodes signed integers into values that can be
</span></span></span><span class=line><span class=cl><span class=cm>   * efficiently encoded with varint. (Otherwise, negative values must be sign-extended to 64 bits
</span></span></span><span class=line><span class=cl><span class=cm>   * to be varint encoded, thus always taking 10 bytes on the wire.)
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * @param n An unsigned 32-bit integer, stored in a signed int because Java has no explicit
</span></span></span><span class=line><span class=cl><span class=cm>   *     unsigned support.
</span></span></span><span class=line><span class=cl><span class=cm>   * @return A signed 32-bit integer.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=n>public</span> <span class=k>static</span> <span class=kt>int</span> <span class=nf>decodeZigZag32</span><span class=p>(</span><span class=n>final</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>^</span> <span class=o>-</span><span class=p>(</span><span class=n>n</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Decode a ZigZag-encoded 64-bit value. ZigZag encodes signed integers into values that can be
</span></span></span><span class=line><span class=cl><span class=cm>   * efficiently encoded with varint. (Otherwise, negative values must be sign-extended to 64 bits
</span></span></span><span class=line><span class=cl><span class=cm>   * to be varint encoded, thus always taking 10 bytes on the wire.)
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * @param n An unsigned 64-bit integer, stored in a signed int because Java has no explicit
</span></span></span><span class=line><span class=cl><span class=cm>   *     unsigned support.
</span></span></span><span class=line><span class=cl><span class=cm>   * @return A signed 64-bit integer.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=n>public</span> <span class=k>static</span> <span class=kt>long</span> <span class=nf>decodeZigZag64</span><span class=p>(</span><span class=n>final</span> <span class=kt>long</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>^</span> <span class=o>-</span><span class=p>(</span><span class=n>n</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><h2 id=3-message-structure-编码>3. Message Structure 编码</h2><p>protocol buffer 中 message 是一系列键值对。message 的二进制版本只是使用字段号(field&rsquo;s number 和 wire_type)作为 key。每个字段的名称和声明类型只能在解码端通过引用消息类型的定义（即 <code>.proto</code> 文件）来确定。这一点也是人们常常说的 protocol buffer 比 JSON，XML 安全一点的原因，如果没有数据结构描述 <code>.proto</code> 文件，拿到数据以后是无法解析成正常的数据的。</p><p>编码后结果如下</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/protobuf/pb_message_structure_encoding.png data-srcset="https://github.com/barrypt/blog/raw/master/images/protobuf/pb_message_structure_encoding.png, https://github.com/barrypt/blog/raw/master/images/protobuf/pb_message_structure_encoding.png 1.5x, https://github.com/barrypt/blog/raw/master/images/protobuf/pb_message_structure_encoding.png 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/protobuf/pb_message_structure_encoding.png title=pb_message_structure_encoding></p><p>当消息编码时，键和值被连接成一个字节流。当消息被解码时，解析器需要能够跳过它无法识别的字段。这样，可以将新字段添加到消息中，而不会破坏不知道它们的旧程序。这就是所谓的 “向后”兼容性。</p><h3 id=1-wire_type>1. wire_type</h3><p>在 protobuf 中的 wire_type 取值如下表：</p><table><thead><tr><th>Type</th><th style=text-align:left>Meaning</th><th style=text-align:left>Userd For</th></tr></thead><tbody><tr><td>0</td><td style=text-align:left>Varint</td><td style=text-align:left>int32,int64,uint32,uint64,sint32,sint64,bool,enum</td></tr><tr><td>1</td><td style=text-align:left>64-bit</td><td style=text-align:left>fixed64,sfix64,double</td></tr><tr><td>2</td><td style=text-align:left>Length-delimited</td><td style=text-align:left>string,bytes,embedded messages,oacked repeated field</td></tr><tr><td>3</td><td style=text-align:left>Strart Group</td><td style=text-align:left>groups(deprecated)</td></tr><tr><td>4</td><td style=text-align:left>End Group</td><td style=text-align:left>groups(deprecated)</td></tr><tr><td>5</td><td style=text-align:left>32-bit</td><td style=text-align:left>fixed 32,sfixed32,float</td></tr></tbody></table><p>其中 3、4已经废弃了，可选值为0、1、2、5。</p><h3 id=2-tag>2. Tag</h3><p>key 是使用该字段的 field_number 与wire_type 取|(或运算)后的值，field_number 是定义 proto 文件时使用的 tag 序号</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>(</span><span class=n>field_number</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span><span class=p>)</span><span class=o>|</span><span class=n>wire_type</span>
</span></span></code></pre></div><p>左移3位是因为wire_type最大取值为5，需要占3个bit，这样左移+或运算之后得到的结果就是，高位为field_number，低位为wire_type。</p><p>比如下面这个 message</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Test</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>required</span> <span class=kt>int32</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>field_number=1，wire_type=0，按照公式计算（1&#171;3|0）</p><p>结果就是 1000。</p><p>低三位 000 表示wire_type = 0；</p><p>高位 1 表示 field_number = 1。</p><p>再使用 Varints 编码后结果就是 08</p><h3 id=3-signed-integers-编码>3. Signed Integers 编码</h3><p>Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。<strong>将所有整数映射成无符号整数，然后再采用 varint 编码方式编码</strong>，这样，绝对值小的整数，编码后也会有一个较小的 varint 编码值。</p><h3 id=4-non-varint-numbers>4. Non-varint Numbers</h3><p>Non-varint 数字比较简单，double 、fixed64 的 wire_type 为 1，在解析时告诉解析器，该类型的数据需要一个 64 位大小的数据块即可。同理，float 和 fixed32 的 wire_type 为5，给其 32 位数据块即可。两种情况下，都是高位在后，低位在前。</p><p><strong>说 Protocol Buffer 压缩数据没有到极限，原因就在这里，因为并没有压缩 float、double 这些浮点类型</strong>。</p><h3 id=5-字符串>5. 字符串</h3><p>wire_type 类型为 2 的数据，是一种指定长度的编码方式：<strong><code>key + length + content</code></strong>，key 的编码方式是统一的，length 采用 varints 编码方式，content 就是由 length 指定长度的 Bytes。</p><p>举例，假设定义如下的 message 格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Test2</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>optional</span> <span class=kt>string</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>设置该值为"testing"，二进制格式查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=mi>12</span> <span class=mo>07</span> <span class=mi>74</span> <span class=mi>65</span> <span class=mi>73</span> <span class=mi>74</span> <span class=mi>69</span> <span class=mi>6</span><span class=n>e</span> <span class=mi>67</span>
</span></span></code></pre></div><p>74 65 73 74 69 6e 67 是“testing”的 UTF8 代码。</p><p>此处，key 是16进制表示的，所以展开是：</p><p>12 -> 0001 0010，后三位 010 为 wire type = 2，0001 0010 右移三位为 0000 0010，即 tag = 2。</p><p>length 此处为 7，后边跟着 7 个bytes，即我们的字符串"testing"。</p><p><strong>所以 wire_type 类型为 2 的数据，编码的时候会默认转换为 T-L-V (Tag - Length - Value)的形式</strong>。</p><h3 id=6-嵌入式-message>6. 嵌入式 message</h3><p>假设，定义如下嵌套消息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-proto data-lang=proto><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Test3</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>optional</span> <span class=n>Test1</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>设置字段为整数150，编码后的字节为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=mi>1</span><span class=n>a</span> <span class=mo>03</span> <span class=mi>08</span> <span class=mi>96</span> <span class=mo>01</span>
</span></span></code></pre></div><p>08 96 01 这三个代表的是 150，上面讲解过，这里就不再赘述了。</p><p>1a -> 0001 1010，后三位 010 为 wire type = 2，0001 1010 右移三位为 0000 0011，即 tag = 3。</p><p>length 为 3，代表后面有 3 个字节，即 08 96 01 。</p><p>需要转变为 T - L - V 形式的还有 string, bytes, embedded messages, packed repeated fields （即 wire_type 为 2 的形式都会转变成 T - L - V 形式）</p><h3 id=7-packed-repeated-fields>7. Packed Repeated Fields</h3><p>在 proto3 中 Repeated 字段默认就是以这种方式处理。对于 packed repeated 字段，如果 message 中没有赋值，则不会出现在编码后的数据中。否则的话，该字段所有的元素会被打包到单一一个 key-value 对中，且它的 wire_type=2，长度确定。每个元素正常编码，只不过其前没有标签 tag。例如有如下 message 类型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>Test4</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>repeated</span> <span class=kt>int32</span> <span class=n>d</span> <span class=o>=</span> <span class=mi>4</span> <span class=p>[</span><span class=k>packed</span><span class=o>=</span><span class=kc>true</span><span class=p>];</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>构造一个 Test4 字段，并且设置 repeated 字段 d 3个值：3，270和86942，编码后：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=mi>22</span> <span class=c1>// tag 0010 0010(field number 010 0 = 4, wire type 010 = 2)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=mo>06</span> <span class=c1>// payload size (设置的length = 6 bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl><span class=mo>03</span> <span class=c1>// first element (varint 3)
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl><span class=mi>8</span><span class=n>E</span> <span class=mo>02</span> <span class=c1>// second element (varint 270)
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl><span class=mi>9</span><span class=n>E</span> <span class=n>A7</span> <span class=mo>05</span> <span class=c1>// third element (varint 86942)
</span></span></span></code></pre></div><p><strong>形成了 Tag - Length - Value - Value - Value …… 对</strong>。</p><p>只有原始数字类型（使用varint，32位或64位）的重复字段才可以声明为“packed”。</p><p>有一点需要注意，对于 packed 的 repeated 字段，尽管通常没有理由将其编码为多个 key-value 对，编码器必须有接收多个 key-pair 对的准备。这种情况下，payload 必须是串联的，每个 pair 必须包含完整的元素。</p><p>Protocol Buffer 解析器必须能够解析被重新编译为 packed 的字段，就像它们未被 packed 一样，反之亦然。这允许以正向和反向兼容的方式将[packed = true]添加到现有字段。</p><h2 id=4-小结>4. 小结</h2><p>Protocol Buffer 利用 <code>Varint</code> 原理压缩数据，同时使用<code> Tag - Value (Tag - Length - Value)</code>的编码结构的实现，减少了分隔符的使用，数据存储更加紧凑。</p><p>protocol buffers 在序列化方面，与 XML 相比，有诸多优点：</p><ul><li>更加简单</li><li>数据体积小 3- 10 倍</li><li>更快的反序列化速度，提高 20 - 100 倍</li><li>可以自动化生成更易于编码方式使用的数据访问类</li></ul><h2 id=5-参考>5. 参考</h2><p><code>https://halfrost.com/protobuf_encode</code></p><p><code>https://developers.google.com/protocol-buffers/docs/encoding</code></p><p><code>https://juejin.cn/post/6844903953327456263</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-03-12</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/protobuf/02-encode-core/ data-title=protobuf教程(二)---核心编码原理 data-hashtags=protobuf><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/protobuf/02-encode-core/ data-hashtag=protobuf><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/protobuf/02-encode-core/ data-title=protobuf教程(二)---核心编码原理><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/protobuf/02-encode-core/ data-title=protobuf教程(二)---核心编码原理><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/protobuf/02-encode-core/ data-title=protobuf教程(二)---核心编码原理><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/protobuf/>protobuf</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/protobuf/01-import/ class=prev rel=prev title=protobuf教程(一)---引入其他proto文件><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>protobuf教程(一)---引入其他proto文件</a>
<a href=/posts/kubernetes/04-service-core/ class=next rel=next title=Kubernetes教程(四)---Service核心原理>Kubernetes教程(四)---Service核心原理<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>