<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>ReentrantLock源码分析 -</title><meta name=Description content="Java中的ReentrantLock源码简单分析"><meta property="og:title" content="ReentrantLock源码分析"><meta property="og:description" content="Java中的ReentrantLock源码简单分析"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/java/08-reentrantlock/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-03-15T16:00:00+00:00"><meta property="article:modified_time" content="2019-03-15T16:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="ReentrantLock源码分析"><meta name=twitter:description content="Java中的ReentrantLock源码简单分析"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/java/08-reentrantlock/><link rel=prev href=https://blog.yudlk.com/posts/mysql/01-install-by-docker/><link rel=next href=https://blog.yudlk.com/posts/docker/01-what-is-docker/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"ReentrantLock源码分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/java\/08-reentrantlock\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Java","wordcount":5562,"url":"https:\/\/blog.yudlk.com\/posts\/java\/08-reentrantlock\/","datePublished":"2019-03-15T16:00:00+00:00","dateModified":"2019-03-15T16:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Java中的ReentrantLock源码简单分析"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">ReentrantLock源码分析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/java/><i class="far fa-folder fa-fw" aria-hidden=true></i>Java</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2019-03-15>2019-03-15</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;5562 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;12 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-abstractqueuedsynchronizer>1. AbstractQueuedSynchronizer</a><ul><li><a href=#11-简介>1.1 简介</a></li><li><a href=#12-aqs的4个属性>1.2 AQS的4个属性</a></li><li><a href=#13-阻塞队列node节点的属性>1.3 阻塞队列Node节点的属性</a></li></ul></li><li><a href=#2-reentrantlock的使用>2. ReentrantLock的使用</a></li><li><a href=#3-reentrantlock源码分析>3. ReentrantLock源码分析</a><ul><li><a href=#1-初始化>1. 初始化</a></li><li><a href=#2-加锁过程>2. 加锁过程</a></li><li><a href=#3-解锁过程>3. 解锁过程</a></li></ul></li><li><a href=#4-参考>4. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要对<code>ReentrantLock</code>的源码进行了简单的分析，具体包括<code>ReentrantLock</code>的初始化(公平锁和非公平锁)，加锁过程和解锁过程等。</p><h2 id=1-abstractqueuedsynchronizer>1. AbstractQueuedSynchronizer</h2><p><code>ReentrantLock</code>的实现依赖于<code>AbstractQueuedSynchronizer</code>所以需要了解一下<code>AQS</code>。</p><h3 id=11-简介>1.1 简介</h3><p>类如其名，<code>抽象的队列式的同步器</code>，AQS定义了一套多线程访问共享资源的同步器框架，是<code>java.util.concurrent</code>的核心，<code>CountDownLatch</code>、<code>FutureTask</code>、<code>Semaphore</code>、<code>ReentrantLock</code>等都有一个内部类是这个抽象类的子类。</p><p>AQS定义两种资源共享方式：</p><ul><li>Exclusive: 独占，只有一个线程能执行,如ReentrantLock</li><li>Share: 共享，多个线程可同时执行，如Semaphore/CountDownLatch</li></ul><h3 id=12-aqs的4个属性>1.2 AQS的4个属性</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 头结点，大概可以看做是当前持有锁的线程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>transient</span> <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 阻塞的尾节点，每个新的节点进来，都插入到最后
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>transient</span> <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>//当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁 
</span></span></span><span class=line><span class=cl><span class=c1>//是可重入锁 每次获取都活加1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>volatile</span> <span class=kt>int</span> <span class=n>state</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 代表当前持有独占锁的线程 锁重入时用这个来判断当前线程是否已经拥有了锁
</span></span></span><span class=line><span class=cl><span class=c1>//继承自AbstractOwnableSynchronizer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>transient</span> <span class=n>Thread</span> <span class=n>exclusiveOwnerThread</span><span class=o>;</span> 
</span></span></code></pre></div><h3 id=13-阻塞队列node节点的属性>1.3 阻塞队列Node节点的属性</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/barrypt/blog/raw/master/images/java/javase/aqs-wait-queue.png data-srcset="https://github.com/barrypt/blog/raw/master/images/java/javase/aqs-wait-queue.png, https://github.com/barrypt/blog/raw/master/images/java/javase/aqs-wait-queue.png 1.5x, https://github.com/barrypt/blog/raw/master/images/java/javase/aqs-wait-queue.png 2x" data-sizes=auto alt=https://github.com/barrypt/blog/raw/master/images/java/javase/aqs-wait-queue.png title=CLH队列></p><p>Node 的数据结构其实也挺简单的，就是 <code>thread</code> + <code>waitStatus</code> + <code>pre</code> + <code>next</code> 四个属性而已。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>Node</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** Marker to indicate a node is waiting in shared mode */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 标识节点当前在共享模式下
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>static</span> <span class=kd>final</span> <span class=n>Node</span> <span class=n>SHARED</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** Marker to indicate a node is waiting in exclusive mode */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 标识节点当前在独占模式下
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>static</span> <span class=kd>final</span> <span class=n>Node</span> <span class=n>EXCLUSIVE</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ======== 下面的几个int常量是给waitStatus用的 ===========
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/** waitStatus value to indicate thread has cancelled */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 表示此线程取消了争抢这个锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>CANCELLED</span> <span class=o>=</span>  <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** waitStatus value to indicate successor&#39;s thread needs unparking */</span>
</span></span><span class=line><span class=cl>    <span class=c1>//被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//将会通知该后继结点的线程执行。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>SIGNAL</span>    <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** waitStatus value to indicate thread is waiting on condition */</span>
</span></span><span class=line><span class=cl>    <span class=c1>//该标识的结点处于等待队列中，结点的线程等待在Condition上,等待其他线程唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//从等待队列转移到同步队列中，等待获取同步锁。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>CONDITION</span> <span class=o>=</span> <span class=o>-</span><span class=n>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * waitStatus value to indicate the next acquireShared should
</span></span></span><span class=line><span class=cl><span class=cm>     * unconditionally propagate
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>PROPAGATE</span> <span class=o>=</span> <span class=o>-</span><span class=n>3</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// =====================================================
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 节点的等待状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 取值为上面的1、-1、-2、-3，或者0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 也许就是说半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//AQS在判断状态时，通过用waitStatus&gt;0表示取消状态，而waitStatus&lt;0表示有效状态。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>volatile</span> <span class=kt>int</span> <span class=n>waitStatus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 前驱节点的引用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 后继节点的引用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>volatile</span> <span class=n>Node</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这个就是线程对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>volatile</span> <span class=n>Thread</span> <span class=n>thread</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=2-reentrantlock的使用>2. ReentrantLock的使用</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Server层
</span></span></span><span class=line><span class=cl><span class=cm> * 模拟ReentrantLock使用
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @author illusoryCloud
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>UserServer</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 默认是非公平锁 传入参数true则创建的是公平锁
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>ReentrantLock</span> <span class=n>reentrantLock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ReentrantLock</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>updateUser</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//加锁 同一时刻只能有一个线程更新User
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>reentrantLock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>//do something
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//释放锁放在finally代码块中 保证出现异常等情况也能释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>reentrantLock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=3-reentrantlock源码分析>3. ReentrantLock源码分析</h2><h3 id=1-初始化>1. 初始化</h3><p><code>ReentrantLock reentrantLock = new ReentrantLock(true);</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> *默认是非公平锁
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=nf>ReentrantLock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sync</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NonfairSync</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=nf>ReentrantLock</span><span class=o>(</span><span class=kt>boolean</span> <span class=n>fair</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sync</span> <span class=o>=</span> <span class=n>fair</span> <span class=o>?</span> <span class=k>new</span> <span class=n>FairSync</span><span class=o>()</span> <span class=o>:</span> <span class=k>new</span> <span class=n>NonfairSync</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=2-加锁过程>2. 加锁过程</h3><p><code>reentrantLock.lock();</code></p><p>公平锁实现如下(JDK1.8)：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Sync object for fair locks
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>FairSync</span> <span class=kd>extends</span> <span class=n>Sync</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>serialVersionUID</span> <span class=o>=</span> <span class=o>-</span><span class=n>3000897897090466540L</span><span class=o>;</span>
</span></span><span class=line><span class=cl>		<span class=c1>//争锁
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>final</span> <span class=kt>void</span> <span class=nf>lock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//1
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>acquire</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>  
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>         * Fair version of tryAcquire.  Don&#39;t grant access unless
</span></span></span><span class=line><span class=cl><span class=cm>         * recursive call or no waiters or is first.
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=kd>protected</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>tryAcquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>acquires</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>final</span> <span class=n>Thread</span> <span class=n>current</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(!</span><span class=n>hasQueuedPredecessors</span><span class=o>()</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>compareAndSetState</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>acquires</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=n>current</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>current</span> <span class=o>==</span> <span class=n>getExclusiveOwnerThread</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>nextc</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=n>acquires</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>nextc</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>throw</span> <span class=k>new</span> <span class=n>Error</span><span class=o>(</span><span class=s>&#34;Maximum lock count exceeded&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>setState</span><span class=o>(</span><span class=n>nextc</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1. acquire(1);</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 尝试获取锁
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>acquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//tryAcquire(1) 首先尝试获取一下锁
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//若成功则不需要进入等待队列了
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//1.1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(!</span><span class=n>tryAcquire</span><span class=o>(</span><span class=n>arg</span><span class=o>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=c1>//1.2
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>acquireQueued</span><span class=o>(</span><span class=n>addWaiter</span><span class=o>(</span><span class=n>Node</span><span class=o>.</span><span class=na>EXCLUSIVE</span><span class=o>),</span> <span class=n>arg</span><span class=o>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>//1.3
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>selfInterrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.1 tryAcquire(1)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>        <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>         * Fair version of tryAcquire.  Don&#39;t grant access unless
</span></span></span><span class=line><span class=cl><span class=cm>         * recursive call or no waiters or is first.
</span></span></span><span class=line><span class=cl><span class=cm>         * 尝试直接获取锁，返回值是boolean，代表是否获取到锁
</span></span></span><span class=line><span class=cl><span class=cm>         * 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=kd>protected</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>tryAcquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>acquires</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//获取当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>final</span> <span class=n>Thread</span> <span class=n>current</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=c1>//查看锁的状态
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=c1>//state == 0 此时此刻没有线程持有锁 可以直接获取锁
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//由于是公平锁 则在获取锁之前先看一下队列中还有没有其他等待的线程
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>//讲究先来后到 所以是公平锁  这也是和非公平锁的差别
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>//非公平锁在这里会直接尝试获取锁
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>//1.1.1
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(!</span><span class=n>hasQueuedPredecessors</span><span class=o>()</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                   <span class=c1>// 如果没有线程在等待，那就用CAS尝试获取一下锁
</span></span></span><span class=line><span class=cl><span class=c1></span>                   <span class=c1>// 不成功的话，只能说明几乎同一时刻有个线程抢先获取到了锁
</span></span></span><span class=line><span class=cl><span class=c1></span>                   <span class=c1>//因为刚才hasQueuedPredecessors判断是前面没有线程在等待的
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>//1.1.2
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>compareAndSetState</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>acquires</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>//获取到锁后把当前线程设置为锁的拥有者
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>//1.1.3
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=n>current</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=c1>//获取锁成功直接返回true
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>//到这里说明当前锁已经被占了
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//然后判断如果当前线程就是持有锁的线程
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//那么这次就是锁的重入
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>current</span> <span class=o>==</span> <span class=n>getExclusiveOwnerThread</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//把state加1
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kt>int</span> <span class=n>nextc</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=n>acquires</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>nextc</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>throw</span> <span class=k>new</span> <span class=n>Error</span><span class=o>(</span><span class=s>&#34;Maximum lock count exceeded&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=c1>//1.1.4
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>setState</span><span class=o>(</span><span class=n>nextc</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>//上面两个条件都不满足就返回false
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//获取锁失败了 回到上一个方法继续看
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span></code></pre></div><p><code>1.1.1 hasQueuedPredecessors()</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>  * 通过判断&#34;当前线程&#34;是不是在CLH队列的队首
</span></span></span><span class=line><span class=cl><span class=cm>  * 来返回AQS中是不是有比“当前线程”等待更久的线程
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>hasQueuedPredecessors</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// The correctness of this depends on head being initialized
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// before tail and on head.next being accurate if the current
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// thread is first in queue.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span> <span class=c1>// Read fields in reverse initialization order
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span> <span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=n>s</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>h</span> <span class=o>!=</span> <span class=n>t</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=o>((</span><span class=n>s</span> <span class=o>=</span> <span class=n>h</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>s</span><span class=o>.</span><span class=na>thread</span> <span class=o>!=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.1.2 compareAndSetState(0, acquires))</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 通过CAS设置锁的状态
</span></span></span><span class=line><span class=cl><span class=cm> */</span>     
</span></span><span class=line><span class=cl><span class=kd>protected</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>compareAndSetState</span><span class=o>(</span><span class=kt>int</span> <span class=n>expect</span><span class=o>,</span> <span class=kt>int</span> <span class=n>update</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// See below for intrinsics setup to support this
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>unsafe</span><span class=o>.</span><span class=na>compareAndSwapInt</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>stateOffset</span><span class=o>,</span> <span class=n>expect</span><span class=o>,</span> <span class=n>update</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.1.3 setExclusiveOwnerThread(current)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 设置锁的拥有者
</span></span></span><span class=line><span class=cl><span class=cm> */</span>     
</span></span><span class=line><span class=cl><span class=kd>protected</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>setExclusiveOwnerThread</span><span class=o>(</span><span class=n>Thread</span> <span class=n>thread</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exclusiveOwnerThread</span> <span class=o>=</span> <span class=n>thread</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.1.4 setState(nextc)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 设置锁的状态
</span></span></span><span class=line><span class=cl><span class=cm> */</span>    
</span></span><span class=line><span class=cl><span class=kd>protected</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>setState</span><span class=o>(</span><span class=kt>int</span> <span class=n>newState</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span> <span class=o>=</span> <span class=n>newState</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>回到前面的方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 尝试获取锁
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>acquire</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//tryAcquire(1) 首先尝试获取一下锁
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//若成功则不需要进入等待队列了
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//1.1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(!</span><span class=n>tryAcquire</span><span class=o>(</span><span class=n>arg</span><span class=o>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=c1>//1.2
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//addWaiter(Node.EXCLUSIVE) 1.2.1
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>acquireQueued</span><span class=o>(</span><span class=n>addWaiter</span><span class=o>(</span><span class=n>Node</span><span class=o>.</span><span class=na>EXCLUSIVE</span><span class=o>),</span> <span class=n>arg</span><span class=o>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>//1.3
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>selfInterrupt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.1tryAcquire</code>返回false则继续执行后面的</p><p><code>1.2acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p><p><code>1.2.1 addWaiter(Node.EXCLUSIVE)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 此方法的作用是把线程包装成node，同时进入到队列中
</span></span></span><span class=line><span class=cl><span class=cm> * 参数mode此时是Node.EXCLUSIVE，代表独占模式
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Node</span> <span class=nf>addWaiter</span><span class=o>(</span><span class=n>Node</span> <span class=n>mode</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=n>node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>(),</span> <span class=n>mode</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Try the fast path of enq; backup to full enq on failure
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span> <span class=n>pred</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// tail!=null --&gt; 队列不为空
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>pred</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>            <span class=c1>// 设置自己的前驱 为当前的队尾节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>pred</span><span class=o>;</span> 
</span></span><span class=line><span class=cl>            <span class=c1>// 用CAS把自己设置为队尾, 如果成功后，tail == node了
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//1.2.1.1
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetTail</span><span class=o>(</span><span class=n>pred</span><span class=o>,</span> <span class=n>node</span><span class=o>))</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>                <span class=c1>// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 上面已经有 node.prev = pred
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 加上下面这句，也就实现了和之前的尾节点双向连接了
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>pred</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 线程入队了，可以返回了
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 仔细看看上面的代码，如果会到这里，
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)
</span></span></span><span class=line><span class=cl><span class=c1></span>      	<span class=c1>//1.2.1.2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>enq</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.2.1.1 compareAndSetTail(pred, node)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 使用CAS设置队列的Tail
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>compareAndSetTail</span><span class=o>(</span><span class=n>Node</span> <span class=n>expect</span><span class=o>,</span> <span class=n>Node</span> <span class=n>update</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>unsafe</span><span class=o>.</span><span class=na>compareAndSwapObject</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>tailOffset</span><span class=o>,</span> <span class=n>expect</span><span class=o>,</span> <span class=n>update</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.2.1.2enq(node)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 进入这个方法只有两种可能：1.等待队列为空 2.有线程竞争入队
</span></span></span><span class=line><span class=cl><span class=cm> * 采用自旋的方式入队
</span></span></span><span class=line><span class=cl><span class=cm> * CAS设置tail过程中，竞争一次竞争不到，多次竞争，总会排到的
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Node</span> <span class=nf>enq</span><span class=o>(</span><span class=kd>final</span> <span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//无限循环
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果队列是空的就去初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// Must initialize
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// CAS初始化head节点
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>//1.2.1.2.1
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetHead</span><span class=o>(</span><span class=k>new</span> <span class=n>Node</span><span class=o>()))</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 这个时候有了head，但是tail还是null，设置一下，
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 设置完了以后，继续for循环，下次就到下面的else分支了
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>tail</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 下面几行，和上一个方法 addWaiter 是一样的，
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 通过CAS将当前线程排到队尾，有线程竞争的话排不上重复排
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 直到成功了才return 
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 这里return后前面的addWaiter()方法也返回 
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 接下来进入acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetTail</span><span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>node</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>t</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.2 acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列
</span></span></span><span class=line><span class=cl><span class=cm>     * 如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话
</span></span></span><span class=line><span class=cl><span class=cm>     * 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>acquireQueued</span><span class=o>(</span><span class=kd>final</span> <span class=n>Node</span> <span class=n>node</span><span class=o>,</span> <span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>failed</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>boolean</span> <span class=n>interrupted</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>  <span class=c1>//这里无线循环 直到下面的条件满足
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>//获取当前节点的前一个节点 设置为p
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kd>final</span> <span class=n>Node</span> <span class=n>p</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>predecessor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=c1>//p=head说明当前节点是队列的第一个 
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 所以当前节点可以去试抢一下锁
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 也就是说，当前的head可能不属于任何一个线程，所以作为队头，可以去试一试，
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// tryAcquire已经分析过了,就是简单用CAS试操作一下state
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=o>==</span> <span class=n>head</span> <span class=o>&amp;&amp;</span> <span class=n>tryAcquire</span><span class=o>(</span><span class=n>arg</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>setHead</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>p</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// help GC
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>failed</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>interrupted</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 到这里，说明上面的if分支没有成功
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>//要么当前node本来就不是队头
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 要么就是tryAcquire(arg)没有抢赢别人
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>//1.2.2
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>shouldParkAfterFailedAcquire</span><span class=o>(</span><span class=n>p</span><span class=o>,</span> <span class=n>node</span><span class=o>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=c1>//1.2.3
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>parkAndCheckInterrupt</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                    <span class=n>interrupted</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>failed</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>cancelAcquire</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.2.2 shouldParkAfterFailedAcquire(p, node)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 进入这里说明抢到锁，这个方法说的是：&#34;当前线程没有抢到锁，是否需要挂起当前线程？&#34;
</span></span></span><span class=line><span class=cl><span class=cm>     * 第一个参数是前驱节点，第二个参数代表当前线程的节点 这里一共有三个规则
</span></span></span><span class=line><span class=cl><span class=cm>     * 1.如果前继的节点状态为SIGNAL，表明当前节点需要unpark，则返回true 将导致线程阻塞
</span></span></span><span class=line><span class=cl><span class=cm>     * 2.如果前继节点状态为CANCELLED(ws&gt;0)，说明前置节点已经被放弃，则找到一个非取消的前驱节点        *   返回false，acquireQueued方法的无限循环将递归调用该方法，直至规则1返回true
</span></span></span><span class=line><span class=cl><span class=cm>     * 3.如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL
</span></span></span><span class=line><span class=cl><span class=cm>     *  返回false后进入acquireQueued的无限循环，与规则2同
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kt>boolean</span> <span class=nf>shouldParkAfterFailedAcquire</span><span class=o>(</span><span class=n>Node</span> <span class=n>pred</span><span class=o>,</span> <span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ws</span> <span class=o>=</span> <span class=n>pred</span><span class=o>.</span><span class=na>waitStatus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>ws</span> <span class=o>==</span> <span class=n>Node</span><span class=o>.</span><span class=na>SIGNAL</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>             * This node has already set status asking a release
</span></span></span><span class=line><span class=cl><span class=cm>             * to signal it, so it can safely park.
</span></span></span><span class=line><span class=cl><span class=cm>             */</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 前驱节点 waitStatus大于0 ，说明前驱节点取消了排队。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 就是为当前节点找一个正常的前驱节点 毕竟当前节点需要等着前驱节点来唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>ws</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>             * Predecessor was cancelled. Skip over predecessors and
</span></span></span><span class=line><span class=cl><span class=cm>             * indicate retry.
</span></span></span><span class=line><span class=cl><span class=cm>             */</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 这里就在循环直到找到一个waitStatus 不大于 0的前驱节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>do</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>                <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>pred</span> <span class=o>=</span> <span class=n>pred</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>while</span> <span class=o>(</span><span class=n>pred</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>pred</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>             * waitStatus must be 0 or PROPAGATE.  Indicate that we
</span></span></span><span class=line><span class=cl><span class=cm>             * need a signal, but don&#39;t park yet.  Caller will need to
</span></span></span><span class=line><span class=cl><span class=cm>             * retry to make sure it cannot acquire before parking.
</span></span></span><span class=line><span class=cl><span class=cm>             */</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 仔细想想，如果进入到这个分支意味着什么
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 前驱节点的waitStatus不等于-1也不大于0，那也就是只可能是0，-2，-3
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 这里说明一下：每个新的node入队时，waitStatu都是0
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>compareAndSetWaitStatus</span><span class=o>(</span><span class=n>pred</span><span class=o>,</span> <span class=n>ws</span><span class=o>,</span> <span class=n>Node</span><span class=o>.</span><span class=na>SIGNAL</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><code>1.2.3 parkAndCheckInterrupt()</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>   <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     *这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的
</span></span></span><span class=line><span class=cl><span class=cm>     *这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>parkAndCheckInterrupt</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LockSupport</span><span class=o>.</span><span class=na>park</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Thread</span><span class=o>.</span><span class=na>interrupted</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><h3 id=3-解锁过程>3. 解锁过程</h3><p><code>reentrantLock.unlock()</code> 解锁的代码比较相比加锁的要简单不少</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 解锁
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>unlock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sync</span><span class=o>.</span><span class=na>release</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><code>1. sync.release(1)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 释放锁
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>release</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>   	<span class=c1>//1.1 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//这里尝试释放锁如果成功则进入if里面
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>tryRelease</span><span class=o>(</span><span class=n>arg</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// h赋值为当前的head节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span> <span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果head节点不是null
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//并且head节点的waitStatus不等于0 即head节点不是刚初始化的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//因为刚初始化是waitStatus是等于0的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>h</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>!=</span> <span class=n>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>//1.2 
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//唤醒后继节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>unparkSuccessor</span><span class=o>(</span><span class=n>h</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><code>1.1 tryRelease(1)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 尝试释放锁
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>protected</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>tryRelease</span><span class=o>(</span><span class=kt>int</span> <span class=n>releases</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//可重入锁 所以state可以大于1 每次释放时state减1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>()</span> <span class=o>-</span> <span class=n>releases</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//如果当前线程不是拥有锁的线程直接抛出异常 这肯定嘛 都没获取到锁你释放什么
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>()</span> <span class=o>!=</span> <span class=n>getExclusiveOwnerThread</span><span class=o>())</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalMonitorStateException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 是否完全释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>boolean</span> <span class=n>free</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// state==0了 说明可以完全释放锁了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//把锁的拥有者设置为null
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>setExclusiveOwnerThread</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//锁的状态设置为0 即没有被获取
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>setState</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//到这里 锁已经释放了 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//回到上边的release(1)方法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>free</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><code>1.2 unparkSuccessor(h)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Wakes up node&#39;s successor, if one exists.
</span></span></span><span class=line><span class=cl><span class=cm> * 唤醒后继节点 如果有的话
</span></span></span><span class=line><span class=cl><span class=cm> * @param node the node 参数node是head头结点
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>unparkSuccessor</span><span class=o>(</span><span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * If status is negative (i.e., possibly needing signal) try
</span></span></span><span class=line><span class=cl><span class=cm>     * to clear in anticipation of signalling.  It is OK if this
</span></span></span><span class=line><span class=cl><span class=cm>     * fails or if status is changed by waiting thread.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ws</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>waitStatus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果head节点当前waitStatus&lt;0, 将其修改为0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>ws</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=n>compareAndSetWaitStatus</span><span class=o>(</span><span class=n>node</span><span class=o>,</span> <span class=n>ws</span><span class=o>,</span> <span class=n>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Thread to unpark is held in successor, which is normally
</span></span></span><span class=line><span class=cl><span class=cm>     * just the next node.  But if cancelled or apparently null,
</span></span></span><span class=line><span class=cl><span class=cm>     * traverse backwards from tail to find the actual
</span></span></span><span class=line><span class=cl><span class=cm>     * non-cancelled successor.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=n>s</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//如果直接后继节点是null或者 waitStatus &gt; 0即取消了等待
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//那么就直接从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>s</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 从后往前找，不必担心中间有节点取消(waitStatus==1)的情况
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=o>(</span><span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span> <span class=n>t</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>t</span> <span class=o>!=</span> <span class=n>node</span><span class=o>;</span> <span class=n>t</span> <span class=o>=</span> <span class=n>t</span><span class=o>.</span><span class=na>prev</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>t</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&lt;=</span> <span class=n>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>s</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//如果直接后继节点不是空的就直接唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 唤醒线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LockSupport</span><span class=o>.</span><span class=na>unpark</span><span class=o>(</span><span class=n>s</span><span class=o>.</span><span class=na>thread</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>parkAndCheckInterrupt</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LockSupport</span><span class=o>.</span><span class=na>park</span><span class=o>(</span><span class=k>this</span><span class=o>);</span> <span class=c1>// 刚刚线程被挂起在这里了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>Thread</span><span class=o>.</span><span class=na>interrupted</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了
</span></span></span></code></pre></div><h2 id=4-参考>4. 参考</h2><p><code>https://javadoop.com/post/AbstractQueuedSynchronizer#toc0</code></p><p><code>https://blog.csdn.net/chen77716/article/details/6641477</code></p><p><code>https://www.cnblogs.com/waterystone/p/4920797.html</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2019-03-15</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/java/08-reentrantlock/ data-title=ReentrantLock源码分析 data-hashtags=Java><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/java/08-reentrantlock/ data-hashtag=Java><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/java/08-reentrantlock/ data-title=ReentrantLock源码分析><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/java/08-reentrantlock/ data-title=ReentrantLock源码分析><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/java/08-reentrantlock/ data-title=ReentrantLock源码分析><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/java/>Java</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/mysql/01-install-by-docker/ class=prev rel=prev title="MySQL教程(一)---通过docker 一键搭建 MySQL 开发环境"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>MySQL教程(一)---通过docker 一键搭建 MySQL 开发环境</a>
<a href=/posts/docker/01-what-is-docker/ class=next rel=next title=Docker教程(一)---什么是Docker>Docker教程(一)---什么是Docker<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>