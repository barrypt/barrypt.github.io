<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Kubernetes教程(三)---纯三层网络方案 -</title><meta name=Description content="Flannel host-gw 模式以及 Calico GBP 模式大致实现"><meta property="og:title" content="Kubernetes教程(三)---纯三层网络方案"><meta property="og:description" content="Flannel host-gw 模式以及 Calico GBP 模式大致实现"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/kubernetes/03-pure-layer-3-network/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-04T00:00:00+00:00"><meta property="article:modified_time" content="2022-09-04T00:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Kubernetes教程(三)---纯三层网络方案"><meta name=twitter:description content="Flannel host-gw 模式以及 Calico GBP 模式大致实现"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/kubernetes/03-pure-layer-3-network/><link rel=prev href=https://blog.yudlk.com/posts/kubernetes/02-cluster-network/><link rel=next href=https://blog.yudlk.com/posts/kubernetes/12-vpa/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Kubernetes教程(三)---纯三层网络方案","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/kubernetes\/03-pure-layer-3-network\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Kubernetes","wordcount":4079,"url":"https:\/\/blog.yudlk.com\/posts\/kubernetes\/03-pure-layer-3-network\/","datePublished":"2022-09-04T00:00:00+00:00","dateModified":"2022-09-04T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Flannel host-gw 模式以及 Calico GBP 模式大致实现"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Kubernetes教程(三)---纯三层网络方案</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/kubernetes/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kubernetes</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-09-04>2022-09-04</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4079 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;9 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-flannel--host-gw-模式>1. Flannel host-gw 模式</a></li><li><a href=#2-calico-bgp-模式>2. Calico BGP 模式</a></li><li><a href=#3-calico-ipip-模式>3. Calico IPIP 模式</a></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要介绍了 Kubernetes 中的 Pure Layer 3 网络方案。其中的典型例子，莫过于 Flannel 的 host-gw 模式和 Calico 项目了，本文将大致分析 Flannel 的 host-gw 模式和 Calico 项目来探索Kubernetes 中的纯三层（Pure Layer 3）网络方案。</p><blockquote><p>本文写于 2021-03-27</p><p>第二次更新于 2022-09-04，增加了一些自己的理解,并修复了一些错误</p></blockquote><h1 id=kubernetes>Kubernetes</h1><h2 id=1-flannel--host-gw-模式>1. Flannel host-gw 模式</h2><p>数据流向如下图所示：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../../../img/kubernetes/network/layer3/k8s-network-pure-layer3.png data-srcset="../../../img/kubernetes/network/layer3/k8s-network-pure-layer3.png, ../../../img/kubernetes/network/layer3/k8s-network-pure-layer3.png 1.5x, ../../../img/kubernetes/network/layer3/k8s-network-pure-layer3.png 2x" data-sizes=auto alt=../../../img/kubernetes/network/layer3/k8s-network-pure-layer3.png title=k8s-network-pure-layer3></p><p>当你设置 Flannel 使用 模式之后，flanneld 会在宿主机上创建这样一条规则，以 Node 1 为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ip route
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>10.244.1.0/24 via 10.168.0.3 dev eth0
</span></span></code></pre></div><p>这条路由规则的含义是：目的 IP 地址属于 10.244.1.0/24 网段的 IP 包，应该经过本机的 eth0 设备发出去（即：dev eth0）；并且，它下一跳地址（next-hop）是 10.168.0.3（即：via 10.168.0.3）。</p><p>所谓下一跳地址就是：如果 IP 包从主机 A 发到主机 B，需要经过路由设备 X 的中转。那么 X 的 IP 地址就应该配置为主机 A 的下一跳地址。</p><blockquote><p>而从 host-gw 示意图中我们可以看到，这个下一跳地址对应的，正是我们的目的宿主机 Node 2。</p></blockquote><p>一旦配置了下一跳地址，那么接下来，当 IP 包从网络层进入链路层封装成帧的时候，eth0 设备就会使用下一跳地址对应的 MAC 地址，作为该数据帧的目的 MAC 地址。显然，这个 MAC 地址，正是 Node 2 的 MAC 地址。</p><p><strong>这样，这个数据帧就会从 Node 1 通过宿主机的二层网络顺利到达 Node 2 上。</strong></p><p>而 Node 2 的内核网络栈从二层数据帧里拿到 IP 包后，会“看到”这个 IP 包的目的 IP 地址是 10.244.1.3，即 Infra-container-2 的 IP 地址。这时候，根据 Node 2 上的路由表，该目的地址会匹配到第二条路由规则（也就是 10.244.1.0 对应的路由规则），从而进入 cni0 网桥，进而进入到 Infra-container-2 当中。</p><p>可以看到，<strong>host-gw 模式的工作原理，其实就是将每个 Flannel 子网（Flannel Subnet，比如：10.244.1.0/24）的“下一跳”，设置成了该子网对应的宿主机的 IP 地址</strong>。</p><blockquote><p>也就是说，这台“主机”（Host）会充当这条容器通信路径里的“网关”（Gateway）。这也正是“host-gw”的含义。</p></blockquote><p>而且 Flannel 子网和主机的信息，都是保存在 Etcd 当中的。flanneld 只需要 WACTH 这些数据的变化，然后实时更新路由表即可。</p><p>而在这种模式下，容器通信的过程就免除了额外的封包和解包带来的性能损耗。根据实际的测试，host-gw 的性能损失大约在 10% 左右，而其他所有基于 VXLAN“隧道”机制的网络方案，性能损失都在 20%~30% 左右。</p><p><strong>host-gw 模式能够正常工作的核心，就在于 IP 包在封装成帧发送出去的时候，会使用路由表里的“下一跳”来设置目的 MAC 地址</strong>。这样，它就会经过二层网络到达目的宿主机。</p><p><strong>所以说，Flannel host-gw 模式必须要求集群宿主机之间是二层连通的</strong>。</p><blockquote><p>问题来了，为什么需要二层连通？</p><p>如果二层不连通，那么只能通过三层传输(即：IP 包)，到其他设备或者路由器的时候是不认识这个容器 IP 的，因此这个包肯定会丢。</p><p>注：Node1 和 Node2 认识是因为 Calico 在上面加了对应的路由规则。</p><p>因此必须要二层连通才行。</p></blockquote><h2 id=2-calico-bgp-模式>2. Calico BGP 模式</h2><blockquote><p>Calico 当前算是主流的 k8s CNI 实现。</p></blockquote><p><strong>实际上，Calico 项目提供的网络解决方案，与 Flannel 的 host-gw 模式，几乎是完全一样的。</strong></p><p>也就是说，Calico 也会在每台宿主机上，添加一个格式如下所示的路由规则：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>&lt;目的容器IP地址段&gt; via &lt;网关的IP地址&gt; dev eth0
</span></span></code></pre></div><p>其中，网关的 IP 地址，正是目的容器所在宿主机的 IP 地址。</p><p>而正如前所述，这个三层网络方案得以正常工作的核心，是为每个容器的 IP 地址，找到它所对应的、“下一跳”的<strong>网关</strong>。</p><p>不过，<strong>不同于 Flannel 通过 Etcd 和宿主机上的 flanneld 来维护路由信息的做法，Calico 项目使用了一个“重型武器” BGP 来自动地在整个集群中分发路由信息</strong>。</p><blockquote><p>BGP（Border Gateway Protocol）即边界网关协议，是运行于TCP上的自治系(互联网AS)统路由协议。</p><p>简单理解：<strong>所谓 BGP，就是在大规模网络中实现节点路由信息共享的一种协议</strong>。</p></blockquote><p>BGP 在每个边界网关（路由器）上运行，彼此之间通信更新路由表信息，而 BGP 的这个能力，正好可以取代 Flannel 维护主机上路由表的功能。</p><blockquote><p>而且，BGP 这种原生就是为大规模网络环境而实现的协议，其可靠性和可扩展性，远非 Flannel 自己的方案可比。</p></blockquote><p>Calico 由三个部分组成：</p><ul><li>1）Calico 的 CNI 插件。这就是 Calico 与 Kubernetes 对接的部分。</li><li>2）Felix。它是一个 DaemonSet，负责在宿主机上插入路由规则（即：写入 Linux 内核的 FIB 转发信息库），以及维护 Calico 所需的网络设备等工作。</li><li>3）BIRD。它就是 BGP 的客户端，专门负责在集群里分发路由规则信息。</li></ul><p><strong>除了对路由信息的维护方式之外，Calico 项目与 Flannel 的 host-gw 模式的另一个不同之处，就是它不会在宿主机上创建任何网桥设备</strong>。</p><blockquote><p>二者只是不同的实现，功能上并没有差别。Calico 通过设置路由规则，将数据包直接路由到对应 veth 设备，Flannel 则是先路由到网桥，在从网桥转发到对应 veth 设备。</p></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=../../../img/kubernetes/network/layer3/k8s-network-bgp.jpg data-srcset="../../../img/kubernetes/network/layer3/k8s-network-bgp.jpg, ../../../img/kubernetes/network/layer3/k8s-network-bgp.jpg 1.5x, ../../../img/kubernetes/network/layer3/k8s-network-bgp.jpg 2x" data-sizes=auto alt=../../../img/kubernetes/network/layer3/k8s-network-bgp.jpg title=k8s-network-bgp></p><p>Calico 的 CNI 插件会为每个容器设置一个 Veth Pair 设备，然后把其中的一端放置在宿主机上（它的名字以 cali 前缀开头）。</p><p>此外，由于 Calico 没有使用 CNI 的网桥模式，Calico 的 CNI 插件还需要在宿主机上为每个容器的 Veth Pair 设备配置一条路由规则，用于接收传入的 IP 包。比如，宿主机 Node 2 上的 Container 4 对应的路由规则，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>10.233.2.3 dev cali5863f3 scope link
</span></span></code></pre></div><p>即：发往 10.233.2.3 的 IP 包，应该进入 cali5863f3 设备。</p><blockquote><p>基于上述原因，Calico 项目在宿主机上设置的路由规则，肯定要比 Flannel 项目多得多。</p><p>不过，Flannel host-gw 模式使用 CNI 网桥的主要原因，其实是为了跟 VXLAN 模式保持一致。否则的话，Flannel 就需要维护两套 CNI 插件了。</p></blockquote><p>有了这样的 Veth Pair 设备之后，容器发出的 IP 包就会经过 Veth Pair 设备出现在宿主机上。然后，宿主机网络栈就会根据路由规则的下一跳 IP 地址，把它们转发给正确的网关。接下来的流程就跟 Flannel host-gw 模式完全一致了。</p><p>其中，<strong>这里最核心的“下一跳”路由规则，就是由 Calico 的 Felix 进程负责维护的</strong>。这些路由规则信息，则是通过 BGP Client 也就是 BIRD 组件，使用 BGP 协议传输而来的。</p><p><strong>Calico 项目实际上将集群里的所有节点，都当作是边界路由器来处理，它们一起组成了一个全连通的网络，互相之间通过 BGP 协议交换路由规则。这些节点，我们称为 BGP Peer</strong>。</p><p>需要注意的是，<strong>Calico 维护的网络在默认配置下，是一个被称为“Node-to-Node Mesh”的模式</strong>。这时候，每台宿主机上的 BGP Client 都需要跟其他所有节点的 BGP Client 进行通信以便交换路由信息。但是，随着节点数量 N 的增加，这些连接的数量就会以 N²的规模快速增长，从而给集群本身的网络带来巨大的压力。</p><p>所以，Node-to-Node Mesh 模式一般推荐用在少于 100 个节点的集群里。而在更大规模的集群中，你需要用到的是一个叫作 Route Reflector 的模式。</p><p>在这种模式下，Calico 会指定一个或者几个专门的节点，来负责跟所有节点建立 BGP 连接从而学习到全局的路由规则。而其他节点，只需要跟这几个专门的节点交换路由信息，就可以获得整个集群的路由规则信息了。</p><p>对于 Calico BGP 模式来说，同样要求集群宿主机之间是二层连通的。</p><p>举个例子，假如我们有两台处于不同子网的宿主机 Node 1 和 Node 2，对应的 IP 地址分别是 192.168.1.2 和 192.168.2.2。需要注意的是，这两台机器通过路由器实现了三层转发，所以这两个 IP 地址之间是可以相互通信的。</p><p>而我们现在的需求，还是 Container 1 要访问 Container 4。</p><p>按照我们前面的讲述，Calico 会尝试在 Node 1 上添加如下所示的一条路由规则：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>10.233.2.0/16 via 192.168.2.2 eth0
</span></span></code></pre></div><p>上面这条规则里的下一跳地址是 192.168.2.2，可是它对应的 Node 2 跟 Node 1 却根本不在一个子网里，没办法通过二层网络把 IP 包发送到下一跳地址。</p><p><strong>在这种情况下，你就需要为 Calico 打开 IPIP 模式</strong>。</p><h2 id=3-calico-ipip-模式>3. Calico IPIP 模式</h2><blockquote><p>Calico 的 IPIP 模式也是隧道中的一种。</p></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=../../../img/kubernetes/network/layer3/k8s-network-calico-ipip.jpg data-srcset="../../../img/kubernetes/network/layer3/k8s-network-calico-ipip.jpg, ../../../img/kubernetes/network/layer3/k8s-network-calico-ipip.jpg 1.5x, ../../../img/kubernetes/network/layer3/k8s-network-calico-ipip.jpg 2x" data-sizes=auto alt=../../../img/kubernetes/network/layer3/k8s-network-calico-ipip.jpg title=k8s-network-calico-ipip></p><p>在 Calico 的 IPIP 模式下，Felix 进程在 Node 1 上添加的路由规则，会稍微不同，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>10.233.2.0/24 via 192.168.2.2 tunl0
</span></span></code></pre></div><p>这一次，要负责将 IP 包发出去的设备，变成了 tunl0，Calico 使用的这个 tunl0 设备，是一个 IP 隧道（IP tunnel）设备。</p><p>P 包进入 IP 隧道设备之后，就会被 Linux 内核的 IPIP 驱动接管。IPIP 驱动会将这个 IP 包直接封装在一个宿主机网络的 IP 包中，如下所示：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../../../img/kubernetes/network/layer3/k8s-network-calico-ipip-wrap.webp data-srcset="../../../img/kubernetes/network/layer3/k8s-network-calico-ipip-wrap.webp, ../../../img/kubernetes/network/layer3/k8s-network-calico-ipip-wrap.webp 1.5x, ../../../img/kubernetes/network/layer3/k8s-network-calico-ipip-wrap.webp 2x" data-sizes=auto alt=../../../img/kubernetes/network/layer3/k8s-network-calico-ipip-wrap.webp title=k8s-network-calico-ipip-wrap></p><p>其中，经过封装后的新的 IP 包的目的地址（图中的 Outer IP Header 部分），正是原 IP 包的下一跳地址，即 Node 2 的 IP 地址：192.168.2.2，而原 IP 包本身，则会被直接封装成新 IP 包的 Payload。</p><p><strong>这样，原先从容器到 Node 2 的 IP 包，就被伪装成了一个从 Node 1 到 Node 2 的 IP 包</strong>。</p><p>由于宿主机之间已经使用路由器配置了三层转发，也就是设置了宿主机之间的“下一跳”。所以这个 IP 包在离开 Node 1 之后，就可以经过路由器，最终“跳”到 Node 2 上。</p><p>这时，Node 2 的网络内核栈会使用 IPIP 驱动进行解包，从而拿到原始的 IP 包。然后，原始 IP 包就会经过 Node 2 上由 Calico 设置的路由规则和 Veth Pair 设备到达目的容器内部。</p><p>以上，就是 Calico 项目主要的工作原理了。</p><blockquote><p>额外的封包和解包工作会导致集群网络性能下降，在实际测试中，Calico IPIP 模式与 Flannel VXLAN 模式的性能大致相当。</p></blockquote><h2 id=4-小结>4. 小结</h2><p><strong>三层网络主要通过维护路由规则，将数据包直接转发到对应的宿主机上</strong>。</p><ul><li>Flannel host-gw 主要通过 etcd 中的子网信息来维护路由规则；</li><li>Calico BGP 模式则通过 BGP 协议收集路由信息，由 Felix 进程来维护；</li><li>Calico IPIP 模式也是一直隧道模式，主要通过在 IP 包外再封装一层 IP 包来实现。</li></ul><p><strong>使用场景</strong></p><p>在大规模集群里，三层网络方案在宿主机上的路由规则可能会非常多，这会导致错误排查变得困难。此外，在系统故障的时候，路由规则出现重叠冲突的概率也会变大。</p><ul><li>1）如果是在<code>公有云</code>上，由于宿主机网络本身比较“直白”，一般推荐更加简单的 Flannel host-gw 模式。</li><li>2）但不难看到，在<code>私有部署环境</code>里，Calico 项目才能够覆盖更多的场景，并为你提供更加可靠的组网方案和架构思路。</li></ul><p>​</p><p><strong>三层和隧道的异同</strong>：</p><p>相同之处是都实现了跨主机容器的三层互通，不同之处是三层通过配置下一条主机的路由规则来实现互通，因此需要二层连通，而隧道则是通过封包和解包来实现，因此不需要二层连通。</p><ul><li>三层的优点：少了封包和解包的过程，性能肯定是更高的。</li><li>三层的缺点：需要自己想办法维护路由规则。</li><li>隧道的优点：简单，原因是大部分工作都是由 Linux 内核的模块实现了，应用层面工作量较少。</li><li>隧道的缺点：主要的问题就是性能低。</li></ul><p>是否应用隧道的本质其实是在网络传输的中间过程中，只靠原本的数据包的路由信息(mac,ip)等，中间网络设备是否能够顺利识别并转发。</p><blockquote><p>像二层不通的情况下，用 BGP 模式直接在宿主机设置路由是无法到达的，因此就需要该用 IPIP 模式走隧道了。</p></blockquote><h2 id=5-参考>5. 参考</h2><p><a href=https://kubernetes.io/docs/concepts/cluster-administration/networking/ target=_blank rel="noopener noreffer">https://kubernetes.io/docs/concepts/cluster-administration/networking/</a></p><p><a href=https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c target=_blank rel="noopener noreffer">https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c</a></p><p><a href=https://feisky.gitbooks.io/kubernetes/content/network/flannel/flannel.html target=_blank rel="noopener noreffer">https://feisky.gitbooks.io/kubernetes/content/network/flannel/flannel.html</a></p><p><code>深入剖析Kubernetes 专栏</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-09-04</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/kubernetes/03-pure-layer-3-network/ data-title=Kubernetes教程(三)---纯三层网络方案 data-hashtags=Kubernetes><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/kubernetes/03-pure-layer-3-network/ data-hashtag=Kubernetes><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/kubernetes/03-pure-layer-3-network/ data-title=Kubernetes教程(三)---纯三层网络方案><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/kubernetes/03-pure-layer-3-network/ data-title=Kubernetes教程(三)---纯三层网络方案><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/kubernetes/03-pure-layer-3-network/ data-title=Kubernetes教程(三)---纯三层网络方案><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/kubernetes/>Kubernetes</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/kubernetes/02-cluster-network/ class=prev rel=prev title="Kubernetes教程(二)---集群网络之 Flannel 核心原理"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Kubernetes教程(二)---集群网络之 Flannel 核心原理</a>
<a href=/posts/kubernetes/12-vpa/ class=next rel=next title="Kubernetes教程(十二)---VPA:垂直 Pod 自动扩缩容">Kubernetes教程(十二)---VPA:垂直 Pod 自动扩缩容<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>