<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Kubernetes教程(十四)---PV 从创建到挂载全流程详解 -</title><meta name=Description content="pv dynamic provision,存储卷全流程详解"><meta property="og:title" content="Kubernetes教程(十四)---PV 从创建到挂载全流程详解"><meta property="og:description" content="pv dynamic provision,存储卷全流程详解"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/kubernetes/14-pv-dynamic-provision-process/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-11T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-11T00:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Kubernetes教程(十四)---PV 从创建到挂载全流程详解"><meta name=twitter:description content="pv dynamic provision,存储卷全流程详解"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/kubernetes/14-pv-dynamic-provision-process/><link rel=prev href=https://blog.yudlk.com/posts/kubernetes/12-vpa/><link rel=next href=https://blog.yudlk.com/posts/kubernetes/15-kind-kubernetes-in-docker/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Kubernetes教程(十四)---PV 从创建到挂载全流程详解","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/kubernetes\/14-pv-dynamic-provision-process\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Kubernetes","wordcount":3472,"url":"https:\/\/blog.yudlk.com\/posts\/kubernetes\/14-pv-dynamic-provision-process\/","datePublished":"2022-11-11T00:00:00+00:00","dateModified":"2022-11-11T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"pv dynamic provision,存储卷全流程详解"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Kubernetes教程(十四)---PV 从创建到挂载全流程详解</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/kubernetes/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kubernetes</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-11-11>2022-11-11</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;3472 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;7 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-概述>1. 概述</a></li><li><a href=#2-pv-的创建>2. PV 的创建</a><ul><li><a href=#1-创建-pvc>1. 创建 PVC</a></li><li><a href=#2-pvcontroller-绑定-pv--pvc>2. PVController 绑定 PV & PVC</a></li><li><a href=#3-dynamically-provision--external-provisioner>3. Dynamically Provision & external-provisioner</a></li></ul></li><li><a href=#3-创建-pod-使用该-pvc>3. 创建 Pod 使用该 PVC</a><ul><li><a href=#1-attach>1. Attach</a></li><li><a href=#2-mount>2. Mount</a></li></ul></li><li><a href=#4-小结>4. 小结</a></li></ul></nav></div></div><div class=content id=content><p>本文主要对 PV 从创建到挂载全流程进行了简单分析，包括存储卷的动态供应(Dynamically Provision)以及最终被挂载到 Pod 中被我们的app 所使用。</p><h2 id=1-概述>1. 概述</h2><p>本文主要分析以下两个步骤：</p><ul><li>1）PV 的创建：即在 k8s 中创建一个 pv 对象</li><li>2）PV 的挂载：即创建 Pod 指定使用该 PVC，Pod 启动后 PV 被挂载到 Pod 中</li></ul><p>其中创建部分又可以分为两种：</p><ul><li>静态供应：即管理员手动创建 PV</li><li>动态供应：由 k8s 根据 PVC 自动创建对应 PV</li></ul><p>主流的方式为 <strong>动态供应</strong>，毕竟管理员无法预估集群使用者需要什么样的 PV，也就不可能提前创建好一模一样的 PV，开发人员又可能不了解存储，无法自己创建，最终只能等 Pod 启动时在通知管理员创建 PV ，这样就太麻烦了。</p><p><strong>环境准备</strong></p><p>这里需要一个部署好了存储插件的 k8s 集群。</p><ul><li>推荐使用 kubeclipper 安装集群，具体可以参考 <a href=https://www.lixueduan.com/posts/kubernetes/11-install-by-kubeclipper/ target=_blank rel="noopener noreffer">Kubernetes教程(十一)&mdash;使用 KubeClipper 通过一条命令快速创建 k8s 集群</a></li><li>同时这里有一个 <a href=https://github.com/barrypt/i-go/blob/77d058c885b9086cdc6a35a35b564f5e8f34d2b2/shell/install-nfs.sh target=_blank rel="noopener noreffer">安装 NFS 的脚本</a>，等会可以作为存储后端使用</li></ul><h2 id=2-pv-的创建>2. PV 的创建</h2><p><img class=lazyload src=/svg/loading.min.svg data-src=../../../img/kubernetes/csi/kube_csi_create_pv.png data-srcset="../../../img/kubernetes/csi/kube_csi_create_pv.png, ../../../img/kubernetes/csi/kube_csi_create_pv.png 1.5x, ../../../img/kubernetes/csi/kube_csi_create_pv.png 2x" data-sizes=auto alt=../../../img/kubernetes/csi/kube_csi_create_pv.png title=../../../img/kubernetes/csi/kube_csi_create_pv.png></p><h3 id=1-创建-pvc>1. 创建 PVC</h3><p>首先创建一个 pvc。</p><blockquote><p>这里需要注意 storageClassName，如果是用 kubeclipper 安装的，那么默认的名字就是 nfs-sc。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cat &gt; pvc.yaml <span class=s>&lt;&lt; EOF
</span></span></span><span class=line><span class=cl><span class=s>apiVersion: v1
</span></span></span><span class=line><span class=cl><span class=s>kind: PersistentVolumeClaim
</span></span></span><span class=line><span class=cl><span class=s>metadata:
</span></span></span><span class=line><span class=cl><span class=s>  name: csi-test-pvc
</span></span></span><span class=line><span class=cl><span class=s>spec:
</span></span></span><span class=line><span class=cl><span class=s>  accessModes:
</span></span></span><span class=line><span class=cl><span class=s>    - ReadWriteOnce
</span></span></span><span class=line><span class=cl><span class=s>  resources:
</span></span></span><span class=line><span class=cl><span class=s>    requests:
</span></span></span><span class=line><span class=cl><span class=s>      storage: 1Gi
</span></span></span><span class=line><span class=cl><span class=s>  storageClassName: nfs-sc
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f pvc.yaml
</span></span></code></pre></div><h3 id=2-pvcontroller-绑定-pv--pvc>2. PVController 绑定 PV & PVC</h3><p>PVC 创建之后就轮到 <strong>PersistentVolumeController</strong> 登场了。</p><blockquote><p>PVController 即 PersistentVolumeController，是 kube-controller-manager 的一部分</p></blockquote><p>PersistentVolumeController 会不断地查看当前每一个 PVC，是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与这个“单身”的 PVC 进行绑定。</p><blockquote><p>相关源码 <a href=https://github.com/kubernetes/kubernetes/blob/e62cfabf9326cdec65e926b697fa1911b4e85da6/pkg/controller/volume/persistentvolume/pv_controller_base.go#L306-L334 target=_blank rel="noopener noreffer">pkg/controller/volume/persistentvolume/pv_controller_base.go</a></p></blockquote><p>由于这时候还没有对应的 pv，因此会一直绑定不了，直到有 pv 创建出来。</p><h3 id=3-dynamically-provision--external-provisioner>3. Dynamically Provision & external-provisioner</h3><p>创建 pvc 之后同时也会进入 dynamically provision 流程。</p><blockquote><p>如果有部署 CSI 的话。</p></blockquote><p>部署的 CSI Plugin 里有一个叫做 external-provisioner 的pod，这时候 <strong><a href=https://github.com/kubernetes-csi/external-provisioner target=_blank rel="noopener noreffer">external-provisioner</a></strong> 就起作用了，他会 watch pvc 对象，因为这里我们创建了 PVC，那么 provisioner 就会收到相应事件，然后根据 PVC 中的 storageClassName 拿到对应 StorageClass，然后根据 StorageClass 中的 provisioner 字段拿到对应 provisioner，如果发现是自己处理的，就调用 <strong>CSI</strong> <strong>Plugin</strong> 的 CreateVolume 方法创建出 volume。</p><blockquote><p>CSI Plugin CreateVolume 接口则由具体厂商实现，比如 阿里云实现的 CreateVolume 可能就是在阿里云上创建了一块云盘。</p></blockquote><p>创建成功后就在 k8s 里创建对应的 PV 来指代这个 volume。最后 PV 创建之后，PVController 就 可以将二者进行绑定。</p><blockquote><p>这里的 bind 只是修改了 pvc 和 pv 对象的字段</p></blockquote><p>查看创建的 pvc 和 pv</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=o>[</span>root@ee ~<span class=o>]</span><span class=c1># kubectl get pvc</span>
</span></span><span class=line><span class=cl>NAME           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
</span></span><span class=line><span class=cl>csi-test-pvc   Bound    pvc-047acd58-808e-4f26-83c6-df59e8e00e65   1Gi        RWO            nfs-sc         3m49s
</span></span><span class=line><span class=cl><span class=o>[</span>root@ee ~<span class=o>]</span><span class=c1># kubectl get pv</span>
</span></span><span class=line><span class=cl>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                  STORAGECLASS   REASON   AGE
</span></span><span class=line><span class=cl>pvc-047acd58-808e-4f26-83c6-df59e8e00e65   1Gi        RWO            Delete           Bound    default/csi-test-pvc   nfs-sc                  3m59s
</span></span></code></pre></div><blockquote><p>可以看到 pvc 中的 VolumeName 就是 pv 的名字，同时已经进入 Bound 状态，说明在 PV 被创建出来之后 PVController 立马就将二者进行绑定了。</p></blockquote><h2 id=3-创建-pod-使用该-pvc>3. 创建 Pod 使用该 PVC</h2><p>然后创建一个 pod 使用该 pvc</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>cat &gt; pod.yaml <span class=s>&lt;&lt; EOF
</span></span></span><span class=line><span class=cl><span class=s>apiVersion: v1
</span></span></span><span class=line><span class=cl><span class=s>kind: Pod
</span></span></span><span class=line><span class=cl><span class=s>metadata:
</span></span></span><span class=line><span class=cl><span class=s>  name: test-pod1
</span></span></span><span class=line><span class=cl><span class=s>spec:
</span></span></span><span class=line><span class=cl><span class=s>  volumes:
</span></span></span><span class=line><span class=cl><span class=s>    - name: task-pv-storage
</span></span></span><span class=line><span class=cl><span class=s>      persistentVolumeClaim:
</span></span></span><span class=line><span class=cl><span class=s>        claimName: csi-test-pvc
</span></span></span><span class=line><span class=cl><span class=s>  containers:
</span></span></span><span class=line><span class=cl><span class=s>    - name: task-pv-container
</span></span></span><span class=line><span class=cl><span class=s>      image: nginx
</span></span></span><span class=line><span class=cl><span class=s>      ports:
</span></span></span><span class=line><span class=cl><span class=s>        - containerPort: 80
</span></span></span><span class=line><span class=cl><span class=s>          name: &#34;http-server&#34;
</span></span></span><span class=line><span class=cl><span class=s>      volumeMounts:
</span></span></span><span class=line><span class=cl><span class=s>        - mountPath: &#34;/usr/share/nginx/html&#34;
</span></span></span><span class=line><span class=cl><span class=s>          name: task-pv-storage
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f pod.yaml
</span></span></code></pre></div><blockquote><p>这里随便创建了一个 Pod，用于测试。</p></blockquote><p>根据 pod.yaml 可知，是通过 claimName 来指定要使用的 PVC 的，然后前面 PVC 和 PV 绑定的时候会把 PV 的名字填到 PVC 的 spec.volumeName 字段上，因此这里又可以找到对应的 PV，然后就进入 <strong>Volume 挂载流程</strong>了。</p><p>Pod 创建后 k8s-scheduler 会把 pod 调度到某个 node 上。</p><blockquote><p>从 etcd 角度看就是更新了 pod 的 spec.nodeName 字段。</p></blockquote><p>Pod 被调度到某节点后，并不会立刻被创建出来，因为对应的 PV 还需要经过 attach、mount 两个阶段才能被 pod 使用，因此在创建 Pod 前还需要对 PV 进行处理。</p><blockquote><p>像 nfs 这种文件系统则不需要 attach 阶段，不过这里为了流程完整性，还是分析一下。</p></blockquote><h3 id=1-attach>1. Attach</h3><p>attach 由 ad controller 以及 external-attacher 两个组件共同完成，如下图所示：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../../../img/kubernetes/csi/kube_csi_attach_pv.png data-srcset="../../../img/kubernetes/csi/kube_csi_attach_pv.png, ../../../img/kubernetes/csi/kube_csi_attach_pv.png 1.5x, ../../../img/kubernetes/csi/kube_csi_attach_pv.png 2x" data-sizes=auto alt=../../../img/kubernetes/csi/kube_csi_attach_pv.png title=../../../img/kubernetes/csi/kube_csi_attach_pv.png></p><h4 id=ad-controller>AD Controller</h4><blockquote><p>ADController 即 AttachDetach Controller，负责 PV 的 attach/detach 处理。</p></blockquote><p><strong>大致逻辑</strong>：AD Controller 会获取当前 Node 上的 Pod，然后 Pod 的 Volume 列表计算出 该 Node 上的 PV 列表，然后和 node.Status.VolumesAttached 值进行对比，没有 attach 的话就执行 attach 操作。</p><blockquote><p>Attach 之前还会做一个 MultiAttach check，如果是 RWO 类型的 Volume，然后还已经在别的节点 attach 了，那么这里直接报错。具体流程见后续的源码分析部分。</p></blockquote><p><strong>为了进行解耦</strong>，AD Controller 并不会直接调用 CSI Plugin 去执行 attach，而是创建一个叫做 VolumeAttachment 的对象，大概是长这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-YAML data-lang=YAML><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>storage.k8s.io/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>VolumeAttachment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>creationTimestamp</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;2022-11-10T02:55:16Z&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>csi-ac6258582f9363a9af542dbde1161db00bddf492ea1522e6a92c2f35c3d815c5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resourceVersion</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;142813&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>uid</span><span class=p>:</span><span class=w> </span><span class=l>713ee91b-d256-45c9-a9ba-5d11ad3b7e5c</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>attacher</span><span class=p>:</span><span class=w> </span><span class=l>nfs.csi.k8s.io</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>nodeName</span><span class=p>:</span><span class=w> </span><span class=l>ee</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>source</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>persistentVolumeName</span><span class=p>:</span><span class=w> </span><span class=l>pvc-047acd58-808e-4f26-83c6-df59e8e00e65</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>status</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>attached</span><span class=p>:</span><span class=w>  </span><span class=kc>false</span><span class=w>
</span></span></span></code></pre></div><p>里面记录了 3 个重要信息，attacher、nodeName 和 persistentVolumeName，后续会用到,然后 status.attached 则是用于记录是否真的 attach 了。</p><p>等 external-attacher 处理完成后，ADController 就会更新 node.Status.VolumesAttached，把这个 Volume 记录上去。</p><p>更新后的 node 信息如下：</p><blockquote><p>已省略其他信息</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=o>[</span>root@ee ~<span class=o>]</span><span class=c1># kubectl get node  ee -oyaml</span>
</span></span><span class=line><span class=cl>apiVersion: v1
</span></span><span class=line><span class=cl>kind: Node
</span></span><span class=line><span class=cl>metadata:
</span></span><span class=line><span class=cl>  name: ee
</span></span><span class=line><span class=cl>spec:
</span></span><span class=line><span class=cl>  podCIDR: 10.96.0.0/24
</span></span><span class=line><span class=cl>  podCIDRs:
</span></span><span class=line><span class=cl>  - 10.96.0.0/24
</span></span><span class=line><span class=cl>status:
</span></span><span class=line><span class=cl>  volumesAttached:
</span></span><span class=line><span class=cl>  - devicePath: <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    name: kubernetes.io/csi/nfs.csi.k8s.io^172.20.151.105#tmp/nfs/data/lxd-host#pvc-047acd58-808e-4f26-83c6-df59e8e00e65#
</span></span><span class=line><span class=cl>  volumesInUse:
</span></span><span class=line><span class=cl>  - kubernetes.io/csi/nfs.csi.k8s.io^172.20.151.105#tmp/nfs/data/lxd-host#pvc-047acd58-808e-4f26-83c6-df59e8e00e65#
</span></span></code></pre></div><p><strong>kubelet 启动参数&ndash;enable-controller-attach-detach</strong></p><p>AD Cotroller 与 kubelet 中的 volume manager 逻辑相似，都可以做 Attach/Detach 操作，但是 kube-controller-manager 与 kubelet 中只会有一个组件做 Attach/Detach 操作，具体则是通过 kubelet 启动参数 <strong>&ndash;enable-controller-attach-detach</strong> 来设置。</p><p>设置为 true 表示启用 kube-controller-manager 的 AD controller 来做 Attach/Detach 操作，同时禁用 kubelet 执行 Attach/Detach 操作。</p><blockquote><p>默认值为 true，即让 kube-controller-manager 的 AD controller来做 Attach/Detach 操作。</p></blockquote><p>注意：这个是 kubelet 的配置，而每个节点都会运行一个 kubelet，也就是说不同的节点可以有不同的配置，比如 node1 用AD controller来做 Attach/Detach ，node2 则让 kubelet 来做。</p><blockquote><p>Q：不知道这个配置有什么作用，难道是历史遗留问题？？</p><p>A：从这个 Issue <a href=https://github.com/AliyunContainerService/flexvolume/issues/10#issuecomment-484853588flexvolume target=_blank rel="noopener noreffer">#10</a> 来看，好像是和 flexvolume 有关， flexvolume 的 Attach/Detach 只能在对应节点做，因此需要配置该参数为 false ，让 kubelet 来完成 Attach/Detach 操作。不过现在都是 CSI 了应该不用管了。</p></blockquote><h4 id=external-attacher>external-attacher</h4><p>VolumeAttachment 创建后就交给 <a href=https://github.com/kubernetes-csi/external-attacher target=_blank rel="noopener noreffer">external-attacher</a> 了，external-attacher 会 watch VolumeAttachment 对象。根据 .spec.attacher 判断是不是需要自己处理，如果是则</p><p>调用 CSI Plugin 的 ControllerPublishVolume 方法，将 .spec.persistentVolumeName 这个 Volume attach 到 .spec.nodeName 这个节点上。</p><blockquote><p>具体实现就看 CSI Plugin 了，可能是简单的调用了一个 云厂商的 API。</p></blockquote><p>Attach 成功后(即调用 ControllerPublishVolume 方法没有报错) external-attacher 就会把 .status.attached 改为 true。</p><p>至此 attach 阶段就完成了，进入后续的 mount 阶段。</p><h3 id=2-mount>2. Mount</h3><p>mount 阶段则由 kubelet 中的 volume manager 来完成。</p><h4 id=kubelet--volume-manager>kubelet & volume manager</h4><p>Mount 阶段则由对应节点的 kubelet 中的 volume manager 处理。</p><p>volume manager 获取 node.Status.VolumesAttached 属性值，发现 volume 已被标记为 attached；</p><p>就会进行 mount 操作，调用 CSI 的 NodeStageVolume 和 NodePublishVolume 接口。</p><p>kubelet 会调用 VolumeManager，为 pods 准备存储设备，存储设备就绪会挂载存储设备到 pod 所在的节点上，并在容器启动的时候挂载在容器指定的目录中；同时，删除卸载不在使用的存储。</p><p>相关代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rc</span> <span class=o>*</span><span class=nx>reconciler</span><span class=p>)</span> <span class=nf>reconcile</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=c1>// Unmounts are triggered before mounts so that a volume that was
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// referenced by a pod that was deleted and is now referenced by another
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// pod is unmounted from the first pod before being mounted to the new
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// pod.
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>rc</span><span class=p>.</span><span class=nf>unmountVolumes</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// Next we mount required volumes. This function could also trigger
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// attach if kubelet is responsible for attaching volumes.
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// If underlying PVC was resized while in-use then this function also handles volume
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// resizing.
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>rc</span><span class=p>.</span><span class=nf>mountOrAttachVolumes</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// Ensure devices that should be detached/unmounted are detached/unmounted.
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>rc</span><span class=p>.</span><span class=nf>unmountDetachDevices</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>整个 reconcile 包括 3 个方法</p><ul><li><p>unmountVolumes：遍历 node 上的 mountedVolume，检查 pod 还在不在，如果 pod 不在了就把对应 volume unmount 了。</p></li><li><p>mountOrAttachVolumes：遍历需要 mount 或者 attach 的 volume，看下是不是真的 mount 或者 attach了，没有就执行 mount 或者 attach。</p></li><li><p>unmountDetachDevices：如果某个设备的多个 volume 都是 unmount 状态那就把该设备 detach 掉。</p></li></ul><p>在 mountOrAttachVolumes 方法中，由于设备需要先 attach，因此 kubelet 这里会一直阻塞，产生一个叫做 VolumeNotAttached 的错误，这个就要靠前面的 ADController 了，ADController 把 Volume Attach 之后，kubelet 这边就开始 mount。</p><blockquote><p>如果这里 CSI Driver 中的 requiredAttach 配置为 false 则这里会默认 Volume 已经 attach 了，然后开始 mount。</p><p>具体源码 <a href=https://github.com/kubernetes/kubernetes/blob/b3d53a512ffe86ff80243a5debedd44563a040c8/pkg/volume/util/operationexecutor/operation_generator.go#L1508-L1522 target=_blank rel="noopener noreffer">pkg/volume/util/operationexecutor/operation_generator.go#L1508-L1522</a></p></blockquote><p>Kubelet 会根据具体的 PV 名字找到对应的 CSI Driver，然后 调用 CSI 的 NodeStageVolume 和 NodePublishVolume 接口完成 mount。</p><blockquote><p>具体源码 <a href=https://github.com/kubernetes/kubernetes/blob/b3d53a512ffe86ff80243a5debedd44563a040c8/pkg/volume/util/operationexecutor/operation_generator.go#L530-L748 target=_blank rel="noopener noreffer">pkg/volume/util/operationexecutor/operation_generator.go#L530-L748</a></p><p>NodeStageVolume 被封装到了 MountDevice 方法里，而 NodePublishVolume 则是封装到了 MapPodDevice 里。</p></blockquote><p>至此，存储相关的基本流程就结束了，至于删除则是按照相反的流程执行。</p><p>还有下面这两个 Sidecar 没有讲解，不过看名字应该也能知道大概是做什么的：</p><ul><li><p><a href=https://github.com/kubernetes-csi/external-snapshotter target=_blank rel="noopener noreffer">external-snapshotter</a> ：存储卷快照</p></li><li><p><a href=https://github.com/kubernetes-csi/external-resizer target=_blank rel="noopener noreffer">external-resizer</a>：存储卷扩容</p></li></ul><h2 id=4-小结>4. 小结</h2><p>k8s中涉及存储的组件主要有：attach/detach controller、pv controller、volume manager、volume plugins、scheduler。每个组件分工明确：</p><ul><li><p><strong>attach/detach controller</strong>：负责对 volume 进行 attach/detach</p></li><li><p><strong>persistent volume controller</strong>：负责处理 pv/pvc 对象，包括 pv 的 provision/delete</p></li><li><p><strong>kubelet volume manage</strong>r：主要负责对 volume 进行 mount/unmount</p></li><li><p><strong>volume plugins</strong>：包含 k8s 原生的和各厂商的的存储插件</p></li></ul><p>具体流程：</p><p>一共可以分为 3 个步骤：</p><p>1）<strong>Create</strong></p><ul><li>用户创建 PV 后 external-provisioner pod watch 到 pvc 创建事件 ，并根据具体信息调用 CSI Plugin 的 CreateVolume 方法创建对应 PV，以实现动态供应。</li><li>PV 创建后由 PVController 将 PV 和 PVC 进行绑定</li></ul><p>2）<strong>Attach</strong></p><ul><li>创建 Pod，Pod 的 spec.Volume 中指定要使用的 PVC 的名字，pod 创建后由 Scheduler 调度到指定节点。</li><li>然后 ADController 则会根据当前 Node 上已经 Attach 的 Volume 以及当前 Node 上的 Pod 列表中提取出的 Volume 列表进行调谐，把Pod 用到的但是当前没有 Attach 的 Volume 进行 Attach。实际为创建一个 VolumeAttachment 对象。</li><li>由 external-attacher 来 watch 这个 VolumeAttachment 对象，并根据里面的信息来调用 CSI Plugin 的 ControllerPublishVolume 方法进行 Attch。</li></ul><p>3）<strong>Mount</strong></p><ul><li>Volume Attach 完成后则由 Kubelet 中的 Volume Manager 来执行 Mount 操作，最终则是调用 CSI Plugin 的 NodeStageVolume 和 NodePublishVolume 方法</li></ul><p>以上就是 Pod 使用 PV 的基本流程。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-11-11</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/kubernetes/14-pv-dynamic-provision-process/ data-title="Kubernetes教程(十四)---PV 从创建到挂载全流程详解" data-hashtags=Kubernetes><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/kubernetes/14-pv-dynamic-provision-process/ data-hashtag=Kubernetes><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/kubernetes/14-pv-dynamic-provision-process/ data-title="Kubernetes教程(十四)---PV 从创建到挂载全流程详解"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/kubernetes/14-pv-dynamic-provision-process/ data-title="Kubernetes教程(十四)---PV 从创建到挂载全流程详解"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/kubernetes/14-pv-dynamic-provision-process/ data-title="Kubernetes教程(十四)---PV 从创建到挂载全流程详解"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/kubernetes/>Kubernetes</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/kubernetes/12-vpa/ class=prev rel=prev title="Kubernetes教程(十二)---VPA:垂直 Pod 自动扩缩容"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Kubernetes教程(十二)---VPA:垂直 Pod 自动扩缩容</a>
<a href=/posts/kubernetes/15-kind-kubernetes-in-docker/ class=next rel=next title="Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群">Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>