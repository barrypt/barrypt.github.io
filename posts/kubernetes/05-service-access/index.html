<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Kubernetes教程(五)---Service 的几种访问方式 -</title><meta name=Description content="Kubernetes Service 的几种访问方式"><meta property="og:title" content="Kubernetes教程(五)---Service 的几种访问方式"><meta property="og:description" content="Kubernetes Service 的几种访问方式"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/kubernetes/05-service-access/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-09T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-09T00:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Kubernetes教程(五)---Service 的几种访问方式"><meta name=twitter:description content="Kubernetes Service 的几种访问方式"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/kubernetes/05-service-access/><link rel=prev href=https://blog.yudlk.com/posts/kubernetes/04-service-core/><link rel=next href=https://blog.yudlk.com/posts/grpc/10-benchmark/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Kubernetes教程(五)---Service 的几种访问方式","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/kubernetes\/05-service-access\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Kubernetes","wordcount":3455,"url":"https:\/\/blog.yudlk.com\/posts\/kubernetes\/05-service-access\/","datePublished":"2021-04-09T00:00:00+00:00","dateModified":"2021-04-09T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"Kubernetes Service 的几种访问方式"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Kubernetes教程(五)---Service 的几种访问方式</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/kubernetes/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kubernetes</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-04-09>2021-04-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;3455 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;7 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-概述>1. 概述</a></li><li><a href=#2-详解>2. 详解</a><ul><li><a href=#21-clusterip>2.1 ClusterIP</a></li><li><a href=#22-nodeport>2.2 NodePort</a></li><li><a href=#23-loadbalancer>2.3 LoadBalancer</a></li><li><a href=#24-externalname>2.4 ExternalName</a></li></ul></li><li><a href=#3-故障诊断>3. 故障诊断</a><ul><li><a href=#1-service-无法通过-dns-访问>1. Service 无法通过 DNS 访问</a></li><li><a href=#2-service-无法通过-clusterip-访问>2. Service 无法通过 ClusterIP 访问</a></li></ul></li><li><a href=#4-小结>4. 小结</a></li><li><a href=#5-参考>5. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要介绍了 Service 的几种访问方式，包括ClusterIP、NodePort、LoadBalancer、ExternalName等。</p><h2 id=1-概述>1. 概述</h2><p>所谓 Service，其实就是 Kubernetes 为 Pod 分配的、固定的、基于 iptables（或者 IPVS）的<strong>访问入口</strong>。而这些访问入口代理的 Pod 信息，则来自于 Etcd，由 kube-proxy 通过控制循环来维护。</p><p>Service 的四种访问方式如下：</p><ul><li>1）ClusterIP：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。</li><li>2）NodePort：通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。 <code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。 通过请求 <code>&lt;节点 IP>:&lt;节点端口></code>，你可以从集群的外部访问一个 <code>NodePort</code> 服务。</li><li>3）LoadBalancer：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li><li>4）ExternalName：通过返回 <code>CNAME</code> 和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，<code>foo.bar.example.com</code>）。 无需创建任何类型代理。</li></ul><p>其中 ClusterIP 为默认方式，只能集群内部访问。NodePort、LoadBalancer 则是向外暴露服务的同时将流量路由到 ClusterIP服务。ExternalName 则是CNAME方式进行服务映射。</p><h2 id=2-详解>2. 详解</h2><h3 id=21-clusterip>2.1 ClusterIP</h3><p><code>ClusterIP</code>也是 Service 的默认访问方式。</p><p>根据是否生成 ClusterIP 又可分为普通 Service 和 Headless Service 两类：</p><ul><li>普通 Service：通过为 Kubernetes 的 Service 分配一个集群内部可访问的<code>固定虚拟IP</code>（Cluster IP），实现集群内的访问，为最常见的方式。</li><li>Headless Service：该服务不会分配 Cluster IP，也不通过 kube-proxy 做反向代理和负载均衡。而是通过 DNS 提供稳定的网络络 ID 来访问，DNS 会将Headless Service 的后端（endpoints）直接解析为 PodIP 列表，主要供 StatefulSet 使用。</li></ul><h3 id=22-nodeport>2.2 NodePort</h3><p>NodePort 也是比较常见的一种访问方式。</p><p>YAML 定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>my-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>NodePort</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c>#nodePort: 31703</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>443</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>https</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c>#nodePort: 31704</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span></code></pre></div><p>在这个 Service 的定义里，我们声明它的类型是，type=NodePort。然后，我在 ports 字段里声明了 Service 的 8080 端口代理 Pod 的 80 端口，Service 的 443 端口代理 Pod 的 443 端口。</p><blockquote><p>如果你不显式地声明 nodePort 字段，Kubernetes 就会为你分配随机的可用端口来设置代理。这个端口的范围默认是 30000-32767，你可以通过 kube-apiserver 的–service-node-port-range 参数来修改它。</p></blockquote><p>查看一下自动分配的 NodePort</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@ks ~<span class=o>]</span><span class=c1># kubectl get svc my-nginx</span>
</span></span><span class=line><span class=cl>NAME       TYPE       CLUSTER-IP      EXTERNAL-IP   PORT<span class=o>(</span>S<span class=o>)</span>                        AGE
</span></span><span class=line><span class=cl>my-nginx   NodePort   10.96.107.207   &lt;none&gt;        8080:31589/TCP,443:30134/TCP   19m
</span></span></code></pre></div><p>可以看到，虽然是 NodePort 类型，但还是默认创建了 ClusterIP。</p><ul><li>可以通过 <code>&lt;ClusterIP>:&lt;service.Port></code> 来访问<ul><li>这里就是 10.96.107.207:8080</li></ul></li><li>或者通过<code>&lt;NodeIP>:&lt;NodePort></code>方式来访问<ul><li>这里就是内网IP 192.168.2.141:31589，或者公网IP 123.57.236.125:31589 都可以</li></ul></li></ul><p><strong>NodePort 模式也就非常容易理解,kube-proxy 要做的，就是在每台宿主机上生成这样一条 iptables 规则</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>-A KUBE-NODEPORTS -p tcp -m comment --comment <span class=s2>&#34;default/my-nginx: nodePort&#34;</span> -m tcp --dport <span class=m>8080</span> -j KUBE-SVC-67RL4FN6JRUPOJYM
</span></span></code></pre></div><p>KUBE-SVC-67RL4FN6JRUPOJYM其实就是一组随机模式的 iptables 规则。所以接下来的流程，就跟 ClusterIP 模式完全一样了</p><p>要注意的是，在 NodePort 方式下，Kubernetes 会在 IP 包离开宿主机发往目的 Pod 时，对这个 IP 包做一次 SNAT 操作，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>-A KUBE-POSTROUTING -m comment --comment <span class=s2>&#34;kubernetes service traffic requiring SNAT&#34;</span> -m mark --mark 0x4000/0x4000 -j MASQUERADE
</span></span></code></pre></div><p>这里的原理其实很简单，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>           client
</span></span><span class=line><span class=cl>             <span class=se>\ </span>^
</span></span><span class=line><span class=cl>              <span class=se>\ \
</span></span></span><span class=line><span class=cl><span class=se></span>               v <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>   node <span class=m>1</span> &lt;--- node <span class=m>2</span>
</span></span><span class=line><span class=cl>    <span class=p>|</span> ^   SNAT
</span></span><span class=line><span class=cl>    <span class=p>|</span> <span class=p>|</span>   ---&gt;
</span></span><span class=line><span class=cl>    v <span class=p>|</span>
</span></span><span class=line><span class=cl> endpoint
</span></span></code></pre></div><p>当一个外部的 client 通过 node 2 的地址访问一个 Service 的时候，node 2 上的负载均衡规则，就可能把这个 IP 包转发给一个在 node 1 上的 Pod。这里没有任何问题。</p><p>而当 node 1 上的这个 Pod 处理完请求之后，它就会按照这个 IP 包的源地址发出回复。</p><p>可是，如果没有做 SNAT 操作的话，这时候，被转发来的 IP 包的源地址就是 client 的 IP 地址。所以此时，Pod 就会直接将回复发给client。对于 client 来说，它的请求明明发给了 node 2，收到的回复却来自 node 1，这个 client 很可能会报错。</p><p>所以，在上图中，当 IP 包离开 node 2 之后，它的源 IP 地址就会被 SNAT 改成 node 2 的 CNI 网桥地址或者 node 2 自己的地址。这样，Pod 在处理完成之后就会先回复给 node 2（而不是 client），然后再由 node 2 发送给 client。</p><blockquote><p>当然，这也就意味着这个 Pod 只知道该 IP 包来自于 node 2，而不是外部的 client。对于 Pod 需要明确知道所有请求来源的场景来说，这是不可以的。</p></blockquote><p>所以这时候，你就可以将 Service 的 spec.externalTrafficPolicy 字段设置为 local，这就保证了所有 Pod 通过 Service 收到请求之后，一定可以看到真正的、外部 client 的源地址。</p><p>而这个机制的实现原理也非常简单：这时候，一台宿主机上的 iptables 规则，会设置为只将 IP 包转发给运行在这台宿主机上的 Pod。所以这时候，Pod 就可以直接使用源地址将回复包发出，不需要事先进行 SNAT 了。这个流程，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>       client
</span></span><span class=line><span class=cl>       ^ /   <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      / /     <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>     / v       X
</span></span><span class=line><span class=cl>   node <span class=m>1</span>     node <span class=m>2</span>
</span></span><span class=line><span class=cl>    ^ <span class=p>|</span>
</span></span><span class=line><span class=cl>    <span class=p>|</span> <span class=p>|</span>
</span></span><span class=line><span class=cl>    <span class=p>|</span> v
</span></span><span class=line><span class=cl> endpoint
</span></span></code></pre></div><p>当然，这也就意味着如果在一台宿主机上，没有任何一个被代理的 Pod 存在，比如上图中的 node 2，那么你使用 node 2 的 IP 地址访问这个 Service，就是无效的。此时，你的请求会直接被 DROP 掉。</p><h3 id=23-loadbalancer>2.3 LoadBalancer</h3><p>从外部访问 Service 的第二种方式，适用于公有云上的 Kubernetes 服务。这时候，你可以指定一个 LoadBalancer 类型的 Service。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>example-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8765</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>9376</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>example</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>LoadBalancer</span><span class=w>
</span></span></span></code></pre></div><p>在公有云提供的 Kubernetes 服务里，都使用了一个叫作 CloudProvider 的转接层，来跟公有云本身的 API 进行对接。</p><p>所以，<strong>在上述 LoadBalancer 类型的 Service 被提交后，Kubernetes 就会调用 CloudProvider 在公有云上为你创建一个负载均衡服务，并且把被代理的 Pod 的 IP 地址配置给负载均衡服务做后端</strong>。</p><h3 id=24-externalname>2.4 ExternalName</h3><p>而第三种方式，是 Kubernetes 在 1.7 之后支持的一个新特性，叫作 ExternalName。举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ExternalName</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>externalName</span><span class=p>:</span><span class=w> </span><span class=l>my.database.example.com</span><span class=w>
</span></span></span></code></pre></div><p>在上述 Service 的 YAML 文件中，我指定了一个 externalName=my.database.example.com 的字段。而且你应该会注意到，这个 YAML 文件里不需要指定 selector。</p><p>这时候，当你通过 Service 的 DNS 名字访问它的时候，比如访问：my-service.default.svc.cluster.local。那么，Kubernetes 为你返回的就是my.database.example.com。</p><p>所以说，<strong>ExternalName 类型的 Service，其实是在 kube-dns 里为你添加了一条 CNAME 记录</strong>。</p><p>这时，访问 my-service.default.svc.cluster.local 就和访问 my.database.example.com 这个域名是一个效果了。</p><p>此外，Kubernetes 的 Service 还允许你为 Service 分配公有 IP 地址，比如下面这个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>MyApp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>9376</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>externalIPs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=m>80.11.12.10</span><span class=w>
</span></span></span></code></pre></div><p>在上述 Service 中，我为它指定的 externalIPs=80.11.12.10，那么此时，你就可以通过访问 80.11.12.10:80 访问到被代理的 Pod 了。</p><h2 id=3-故障诊断>3. 故障诊断</h2><p>在理解了 Kubernetes Service 机制的工作原理之后，很多与 Service 相关的问题，其实都可以通过分析 Service 在宿主机上对应的 iptables 规则（或者 IPVS 配置）得到解决。</p><h3 id=1-service-无法通过-dns-访问>1. Service 无法通过 DNS 访问</h3><p>你需要区分到底是 Service 本身的配置问题，还是集群的 DNS 出了问题</p><p>一个行之有效的方法，就是检查 Kubernetes 自己的 Master 节点的 Service DNS 是否正常：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 在一个Pod里执行</span>
</span></span><span class=line><span class=cl>$ nslookup kubernetes.default
</span></span><span class=line><span class=cl>Server:    10.0.0.10
</span></span><span class=line><span class=cl>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Name:      kubernetes.default
</span></span><span class=line><span class=cl>Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local
</span></span></code></pre></div><p>如果上面访问 kubernetes.default 返回的值都有问题，那你就需要检查 kube-dns 的运行状态和日志了。否则的话，你应该去检查自己的 Service 定义是不是有问题。</p><h3 id=2-service-无法通过-clusterip-访问>2. Service 无法通过 ClusterIP 访问</h3><p>此时首先应该检查的是这个 Service 是否有 Endpoints：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ kubectl get endpoints hostnames
</span></span><span class=line><span class=cl>NAME        ENDPOINTS
</span></span><span class=line><span class=cl>hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376
</span></span></code></pre></div><p>而如果 Endpoints 正常，<strong>那么你就需要确认 kube-proxy 是否在正确运行</strong>。在我们通过 kubeadm 部署的集群里，你应该看到 kube-proxy 输出的日志如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ kubectl logs &lt;kube-proxy-pod-name&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>I1027 22:14:53.995134    <span class=m>5063</span> server.go:200<span class=o>]</span> Running in resource-only container <span class=s2>&#34;/kube-proxy&#34;</span>
</span></span><span class=line><span class=cl>I1027 22:14:53.998163    <span class=m>5063</span> server.go:247<span class=o>]</span> Using iptables Proxier.
</span></span><span class=line><span class=cl>I1027 22:14:53.999055    <span class=m>5063</span> server.go:255<span class=o>]</span> Tearing down userspace rules. Errors here are acceptable.
</span></span><span class=line><span class=cl>I1027 22:14:54.038140    <span class=m>5063</span> proxier.go:352<span class=o>]</span> Setting endpoints <span class=k>for</span> <span class=s2>&#34;kube-system/kube-dns:dns-tcp&#34;</span> to <span class=o>[</span>10.244.1.3:53<span class=o>]</span>
</span></span><span class=line><span class=cl>I1027 22:14:54.038164    <span class=m>5063</span> proxier.go:352<span class=o>]</span> Setting endpoints <span class=k>for</span> <span class=s2>&#34;kube-system/kube-dns:dns&#34;</span> to <span class=o>[</span>10.244.1.3:53<span class=o>]</span>
</span></span><span class=line><span class=cl>I1027 22:14:54.038209    <span class=m>5063</span> proxier.go:352<span class=o>]</span> Setting endpoints <span class=k>for</span> <span class=s2>&#34;default/kubernetes:https&#34;</span> to <span class=o>[</span>10.240.0.2:443<span class=o>]</span>
</span></span><span class=line><span class=cl>I1027 22:14:54.038238    <span class=m>5063</span> proxier.go:429<span class=o>]</span> Not syncing iptables <span class=k>until</span> Services and Endpoints have been received from master
</span></span><span class=line><span class=cl>I1027 22:14:54.040048    <span class=m>5063</span> proxier.go:294<span class=o>]</span> Adding new service <span class=s2>&#34;default/kubernetes:https&#34;</span> at 10.0.0.1:443/TCP
</span></span><span class=line><span class=cl>I1027 22:14:54.040154    <span class=m>5063</span> proxier.go:294<span class=o>]</span> Adding new service <span class=s2>&#34;kube-system/kube-dns:dns&#34;</span> at 10.0.0.10:53/UDP
</span></span><span class=line><span class=cl>I1027 22:14:54.040223    <span class=m>5063</span> proxier.go:294<span class=o>]</span> Adding new service <span class=s2>&#34;kube-system/kube-dns:dns-tcp&#34;</span> at 10.0.0.10:53/TCP
</span></span></code></pre></div><p>如果 kube-proxy 一切正常，<strong>你就应该仔细查看宿主机上的 iptables 了</strong></p><p>一个 iptables 模式的 Service 对应的规则，它们包括：</p><ul><li>1）KUBE-SERVICES 或者 KUBE-NODEPORTS 规则对应的 Service 的入口链，这个规则应该与 VIP 和 Service 端口一一对应；</li><li>2）KUBE-SEP-(hash) 规则对应的 DNAT 链，这些规则应该与 Endpoints 一一对应；</li><li>3）KUBE-SVC-(hash) 规则对应的负载均衡链，这些规则的数目应该与 Endpoints 数目一致；</li><li>4）如果是 NodePort 模式的话，还有 POSTROUTING 处的 SNAT 链。</li></ul><h2 id=4-小结>4. 小结</h2><p><strong>所谓 Service，其实就是 Kubernetes 为 Pod 分配的、固定的、基于 iptables（或者 IPVS）的访问入口</strong>。而这些访问入口代理的 Pod 信息，则来自于 Etcd，由 kube-proxy 通过控制循环来维护。</p><ul><li>ClusterIP：集群内部IP，也是默认方法方式。</li><li>NodePort：通过节点IP+静态端口访问，NodePort 服务会将流量路由到 ClusterIP 服务。</li><li>LoadBalancer：使用云厂商提供的负载均衡向外暴露服务，可以将流量路由到 NodePort 服务或者ClusterIP 服务。</li><li>ExternalName：通过返回 CNAME 值的方式将服务映射到指定的域名。</li></ul><h2 id=5-参考>5. 参考</h2><p><code>https://kubernetes.io/docs/concepts/services-networking/service/</code></p><p><code>https://draveness.me/kubernetes-service/</code></p><p><code>深入剖析Kubernetes</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2021-04-09</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/kubernetes/05-service-access/ data-title="Kubernetes教程(五)---Service 的几种访问方式" data-hashtags=Kubernetes><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/kubernetes/05-service-access/ data-hashtag=Kubernetes><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/kubernetes/05-service-access/ data-title="Kubernetes教程(五)---Service 的几种访问方式"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/kubernetes/05-service-access/ data-title="Kubernetes教程(五)---Service 的几种访问方式"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/kubernetes/05-service-access/ data-title="Kubernetes教程(五)---Service 的几种访问方式"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/kubernetes/>Kubernetes</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/kubernetes/04-service-core/ class=prev rel=prev title=Kubernetes教程(四)---Service核心原理><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Kubernetes教程(四)---Service核心原理</a>
<a href=/posts/grpc/10-benchmark/ class=next rel=next title=gRPC(Go)教程(十)---gRPC压测工具ghz>gRPC(Go)教程(十)---gRPC压测工具ghz<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>