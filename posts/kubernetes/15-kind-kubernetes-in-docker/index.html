<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群 -</title><meta name=Description content="通过Kubeadm部署K8s集群"><meta property="og:title" content="Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群"><meta property="og:description" content="通过Kubeadm部署K8s集群"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/kubernetes/15-kind-kubernetes-in-docker/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-10T00:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群"><meta name=twitter:description content="通过Kubeadm部署K8s集群"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/kubernetes/15-kind-kubernetes-in-docker/><link rel=prev href=https://blog.yudlk.com/posts/kubernetes/14-pv-dynamic-provision-process/><link rel=next href=https://blog.yudlk.com/posts/tekton/01-deploy-tekton/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/kubernetes\/15-kind-kubernetes-in-docker\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"Kubernetes","wordcount":2876,"url":"https:\/\/blog.yudlk.com\/posts\/kubernetes\/15-kind-kubernetes-in-docker\/","datePublished":"2022-12-10T00:00:00+00:00","dateModified":"2022-12-10T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"通过Kubeadm部署K8s集群"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/kubernetes/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kubernetes</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-12-10>2022-12-10</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;2876 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;6 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-quickstart>1. QuickStart</a><ul><li><a href=#install-docker>Install docker</a></li><li><a href=#install-kind-from-binary>Install kind from binary</a></li><li><a href=#install-kubectl>Install kubectl</a></li><li><a href=#create-aio-cluster>Create aio cluster</a></li><li><a href=#list-cluster>List cluster</a></li><li><a href=#delete-cluster>Delete cluster</a></li><li><a href=#create-ha-cluster>Create ha cluster</a></li></ul></li><li><a href=#2-实现原理>2. 实现原理</a></li><li><a href=#3-注意事项>3. 注意事项</a><ul><li><a href=#镜像导入>镜像导入</a></li><li><a href=#heading></a></li><li><a href=#如何访问集群中的服务>如何访问集群中的服务</a></li><li><a href=#目录映射>目录映射</a></li></ul></li><li><a href=#4小结>4.小结</a></li></ul></nav></div></div><div class=content id=content><p>本文主要记录了如何使用 kind 在本地快速部署一个 k8s集群，包括 kind 的基本使用、大致原理以及注事事项等。</p><blockquote><p>repo：<a href=https://github.com/kubernetes-sigs/kind target=_blank rel="noopener noreffer">https://github.com/kubernetes-sigs/kind</a></p><p>website：<a href=https://kind.sigs.k8s.io/ target=_blank rel="noopener noreffer">https://kind.sigs.k8s.io/</a></p></blockquote><p><strong>一句话描述，什么是 kind</strong>：</p><p><strong><a href=https://sigs.k8s.io/kind target=_blank rel="noopener noreffer">kind</a></strong> <strong>is a tool for running local Kubernetes clusters using Docker container “nodes”.</strong></p><p>Kind 是一个通过使用 docker 容器模拟节点来创建本地 k8s 集群的工具。</p><h2 id=1-quickstart>1. QuickStart</h2><h3 id=install-docker>Install docker</h3><p>Kind 使用 docker 来启动容器，因此需要先安装 docker，可自行安装，也可以用下面这个脚本安装。</p><p>通过以下命令创建 install-docker.sh 脚本文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>cat <span class=s>&lt;&lt; EOF &gt; install-docker.sh 
</span></span></span><span class=line><span class=cl><span class=s>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=s>set -e
</span></span></span><span class=line><span class=cl><span class=s># centos 一键安装 docker 脚本.
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>#卸载旧版本
</span></span></span><span class=line><span class=cl><span class=s>yum remove -y docker  docker-common docker-selinux docker-engine
</span></span></span><span class=line><span class=cl><span class=s>#安装需要的软件包
</span></span></span><span class=line><span class=cl><span class=s>yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span></span><span class=line><span class=cl><span class=s>#添加yum源
</span></span></span><span class=line><span class=cl><span class=s>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</span></span></span><span class=line><span class=cl><span class=s>#安装最新版docker
</span></span></span><span class=line><span class=cl><span class=s>yum install -y docker-ce
</span></span></span><span class=line><span class=cl><span class=s>#配置镜像加速器
</span></span></span><span class=line><span class=cl><span class=s>mkdir -p /etc/docker
</span></span></span><span class=line><span class=cl><span class=s>echo &#39;{
</span></span></span><span class=line><span class=cl><span class=s>  &#34;registry-mirrors&#34;: [
</span></span></span><span class=line><span class=cl><span class=s>    &#34;https://reg-mirror.qiniu.com&#34;,
</span></span></span><span class=line><span class=cl><span class=s>    &#34;https://hub-mirror.c.163.com&#34;,
</span></span></span><span class=line><span class=cl><span class=s>    &#34;https://mirror.baidubce.com&#34;,
</span></span></span><span class=line><span class=cl><span class=s>    &#34;https://docker.mirrors.ustc.edu.cn&#34;
</span></span></span><span class=line><span class=cl><span class=s>  ]
</span></span></span><span class=line><span class=cl><span class=s>}&#39; &gt; /etc/docker/daemon.json
</span></span></span><span class=line><span class=cl><span class=s>#启动并加入开机启动
</span></span></span><span class=line><span class=cl><span class=s>systemctl enable docker --now
</span></span></span><span class=line><span class=cl><span class=s>docker version
</span></span></span><span class=line><span class=cl><span class=s>echo &#34;docker install finish.&#34;
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span></code></pre></div><p>运行脚本，安装 docker：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>sh install-docker.sh
</span></span></code></pre></div><h3 id=install-kind-from-binary>Install kind from binary</h3><p>kind 只是一个二进制文件，因此下载下来放到 bin 目录即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64
</span></span><span class=line><span class=cl>chmod +x ./kind
</span></span><span class=line><span class=cl>sudo mv ./kind /usr/local/bin/kind
</span></span></code></pre></div><h3 id=install-kubectl>Install kubectl</h3><p>Kind 只负责创建集群（会配置好 kubeconfig），后续操作集群的话需要手动安装 <a href=https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/ target=_blank rel="noopener noreffer">kubectl</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>curl -LO <span class=s2>&#34;https://dl.k8s.io/release/</span><span class=k>$(</span>curl -L -s https://dl.k8s.io/release/stable.txt<span class=k>)</span><span class=s2>/bin/linux/amd64/kubectl&#34;</span>
</span></span><span class=line><span class=cl>chmod +x kubectl
</span></span><span class=line><span class=cl>sudo mv kubectl /usr/local/bin
</span></span></code></pre></div><h3 id=create-aio-cluster>Create aio cluster</h3><p>一切就绪之后，使用 kind 创建集群即可。</p><blockquote><p>kind 0.17.0 默认用的是 v.1.25.3 版本 k8s，可以先手动拉镜像,因为默认的镜像地址不一定能拉下来。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>docker pull kindest/node:v1.25.3
</span></span></code></pre></div><p>然后创建集群时指定刚才拉下来的镜像</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>kind create cluster --image kindest/node:v1.25.3 --name aio -v <span class=m>5</span>
</span></span></code></pre></div><p>不出意外的话，一两分钟就可以创建好。</p><p>创建好之后就可以使用 kubectl 进行操作了，kind 会把 kubeconfig 也配置好，使用起来和真正的集群基本一致。</p><h3 id=list-cluster>List cluster</h3><p>Kind 自身也保存了集群数据的，使用以下命令进行查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>kind get clusters
</span></span></code></pre></div><h3 id=delete-cluster>Delete cluster</h3><p>删除一个集群也很简单，通过集群名即可</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># syntax：kind delete  cluster --name ${clustername}</span>
</span></span><span class=line><span class=cl>kind delete  cluster --name aio
</span></span></code></pre></div><h3 id=create-ha-cluster>Create ha cluster</h3><p>默认创建的集群只有一个 master 节点，不过可以通过配置文件创建 HA 集群。</p><p>使用以下命令生成一个 kind-ha.yaml 配置文件：</p><blockquote><p>配置文件内容很简单，nodes 字段里多指定几个节点就行了。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-YAML data-lang=YAML><span class=line><span class=cl><span class=l>cat &lt;&lt;EOF &gt; kind-ha.yaml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># a cluster with 3 control-plane nodes and 3 workers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>kind.x-k8s.io/v1alpha4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>nodes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>role</span><span class=p>:</span><span class=w> </span><span class=l>control-plane</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>role</span><span class=p>:</span><span class=w> </span><span class=l>control-plane</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>role</span><span class=p>:</span><span class=w> </span><span class=l>control-plane</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>role</span><span class=p>:</span><span class=w> </span><span class=l>worker</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>role</span><span class=p>:</span><span class=w> </span><span class=l>worker</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>role</span><span class=p>:</span><span class=w> </span><span class=l>worker</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>EOF</span><span class=w>
</span></span></span></code></pre></div><p>以上配置文件指定了创建一个 3 master 3 worker 的 k8s 集群。同时，在 HA master 下， 它还额外部署了一个 Nginx，用来提供负载均衡 vip。</p><blockquote><p><strong>注意：这里的 HA 并不是真正意义上的 HA，毕竟所有 node 都跑在一个节点上的，如果底层的硬件或者 Docker 出问题那么整个集群都会挂掉。</strong></p><p>因此仅供本地测试使用。</p></blockquote><p>创建时通过 <code>--config</code> 指定该配置文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>kind create cluster --image kindest/node:v1.25.3 --name ha --config kind-ha.yaml
</span></span></code></pre></div><h2 id=2-实现原理>2. 实现原理</h2><p><strong>Kind 使用一个docker 容器来模拟一个 node，在 docker 容器里面跑 systemd ，并用 systemd 托管 kubelet 以及 containerd，然后通过容器内部的 kubelet 把其他 K8s 组件，比如 kube-apiserver、etcd 等跑起来，最后在部署上 CNI 整个集群就完成了</strong></p><blockquote><p>Kind 内部也是使用的 kubeadm 进行部署。</p></blockquote><p>我们可以进入到 docker 容器进行查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=o>[</span>root@kind ~<span class=o>]</span><span class=c1># docker ps</span>
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE                  COMMAND                  CREATED              STATUS              PORTS                       NAMES
</span></span><span class=line><span class=cl>c9a55b2ea333   kindest/node:v1.25.3   <span class=s2>&#34;/usr/local/bin/entr…&#34;</span>   About a minute ago   Up About a minute   127.0.0.1:33275-&gt;6443/tcp   aio-control-plane
</span></span><span class=line><span class=cl><span class=o>[</span>root@kind ~<span class=o>]</span><span class=c1># docker exec -it c9a55b2ea333 /bin/bash</span>
</span></span></code></pre></div><p>先看下 containerd</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@aio-control-plane:/# systemctl status containerd
</span></span><span class=line><span class=cl>● containerd.service - containerd container runtime
</span></span><span class=line><span class=cl>     Loaded: loaded <span class=o>(</span>/etc/systemd/system/containerd.service<span class=p>;</span> enabled<span class=p>;</span> vendor preset: enabled<span class=o>)</span>
</span></span><span class=line><span class=cl>     Active: active <span class=o>(</span>running<span class=o>)</span> since Sat 2022-12-10 04:42:01 UTC<span class=p>;</span> 4min 8s ago
</span></span><span class=line><span class=cl>       Docs: https://containerd.io
</span></span><span class=line><span class=cl>   Main PID: <span class=m>243</span> <span class=o>(</span>containerd<span class=o>)</span>
</span></span><span class=line><span class=cl>      Tasks: <span class=m>122</span>
</span></span><span class=line><span class=cl>     Memory: 799.4M
</span></span><span class=line><span class=cl>     CGroup: /docker/c9a55b2ea333c9fd7ffcce78a6a96c0b1c9d618f4ecdf1bf3568334684b7186c/system.slice/containerd.service
</span></span><span class=line><span class=cl>             ├─ <span class=m>243</span> /usr/local/bin/containerd
</span></span><span class=line><span class=cl>             ├─ <span class=m>371</span> /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id 648e35fa086d1e73a07688fa742be18ee3cbd72f12412153329fd0cf43693b7e -address /run/containerd/containerd.sock
</span></span><span class=line><span class=cl>             ├─ <span class=m>398</span> /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id c9b803db61f0194f84e451615dea5cd463b921590b83d044ef7ecdce7c62608e -address /run/containerd/containerd.sock
</span></span><span class=line><span class=cl>             ├─ <span class=m>401</span> /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id 831789d91a8142289e4263eb0dbba4b9ff4b9d36f930c41248c4fc77e3aeeb6d -address /run/containerd/containerd.sock
</span></span><span class=line><span class=cl>             ├─ <span class=m>429</span> /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id 25d98fdf10c4198c8ddcf7065eed292bcc6a0b1dfd069b640a50b5f307a551de -address /run/containerd/containerd.sock
</span></span><span class=line><span class=cl>             ├─ <span class=m>862</span> /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id b880b9a217fb747602beadc45890efbee81fadc8d6d6d5487c0428c3c5e2a1fc -address /run/containerd/containerd.sock
</span></span><span class=line><span class=cl>             ├─ <span class=m>888</span> /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id 79a95b6fa3be26c317fe8e4144420caa0db537ed5fb748be28acf497fdc15a8e -address /run/containerd/containerd.sock
</span></span><span class=line><span class=cl>             ├─1208 /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id 0eb055283fcef14662c9e4e4497f33ea9b506f2455df2c8a7839a0fce6b83f1d -address /run/containerd/containerd.sock
</span></span><span class=line><span class=cl>             ├─1231 /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id 0e58541ef79169ce4f17f27493e671e90c940c52e12b786faaf108aaa742c8a9 -address /run/containerd/containerd.sock
</span></span><span class=line><span class=cl>             └─1311 /usr/local/bin/containerd-shim-runc-v2 -namespace k8s.io -id 6689352dad1bfa8e57522f231deefd8fd2169a765f428b6ad1c1c58b82c8dbf1 -address /run/containerd/containerd.sock
</span></span></code></pre></div><p>再看下 kubelt</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@aio-control-plane:/# systemctl status kubelet
</span></span><span class=line><span class=cl>● kubelet.service - kubelet: The Kubernetes Node Agent
</span></span><span class=line><span class=cl>     Loaded: loaded <span class=o>(</span>/etc/systemd/system/kubelet.service<span class=p>;</span> enabled<span class=p>;</span> vendor preset: enabled<span class=o>)</span>
</span></span><span class=line><span class=cl>    Drop-In: /etc/systemd/system/kubelet.service.d
</span></span><span class=line><span class=cl>             └─10-kubeadm.conf
</span></span><span class=line><span class=cl>     Active: active <span class=o>(</span>running<span class=o>)</span> since Sat 2022-12-10 04:42:32 UTC<span class=p>;</span> 55s ago
</span></span><span class=line><span class=cl>       Docs: http://kubernetes.io/docs/
</span></span><span class=line><span class=cl>    Process: <span class=m>748</span> <span class=nv>ExecStartPre</span><span class=o>=</span>/bin/sh -euc <span class=k>if</span> <span class=o>[</span> -f /sys/fs/cgroup/cgroup.controllers <span class=o>]</span><span class=p>;</span> <span class=k>then</span> create-kubelet-cgroup-v2<span class=p>;</span> <span class=k>fi</span> <span class=o>(</span><span class=nv>code</span><span class=o>=</span>exited, <span class=nv>status</span><span class=o>=</span>0/SUCCESS<span class=o>)</span>
</span></span><span class=line><span class=cl>    Process: <span class=m>749</span> <span class=nv>ExecStartPre</span><span class=o>=</span>/bin/sh -euc <span class=k>if</span> <span class=o>[</span> ! -f /sys/fs/cgroup/cgroup.controllers <span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=o>[</span> ! -d /sys/fs/cgroup/systemd/kubelet <span class=o>]</span><span class=p>;</span> <span class=k>then</span> mkdir -p /sys/fs/cgroup/systemd/kubelet<span class=p>;</span> <span class=k>fi</span> <span class=o>(</span><span class=nv>code</span><span class=o>=</span>exited, <span class=nv>status</span><span class=o>=</span>0/SUCCESS<span class=o>)</span>
</span></span><span class=line><span class=cl>   Main PID: <span class=m>750</span> <span class=o>(</span>kubelet<span class=o>)</span>
</span></span><span class=line><span class=cl>      Tasks: <span class=m>14</span> <span class=o>(</span>limit: 4662<span class=o>)</span>
</span></span><span class=line><span class=cl>     Memory: 40.1M
</span></span><span class=line><span class=cl>        CPU: 2.485s
</span></span><span class=line><span class=cl>     CGroup: /docker/c9a55b2ea333c9fd7ffcce78a6a96c0b1c9d618f4ecdf1bf3568334684b7186c/kubelet.slice/kubelet.service
</span></span><span class=line><span class=cl>             └─750 /usr/bin/kubelet --bootstrap-kubeconfig<span class=o>=</span>/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig<span class=o>=</span>/etc/kubernetes/kubelet.conf --config<span class=o>=</span>/var/lib/kubelet/config.yaml --container-runtime<span class=o>=</span>remote --container-runtime-endpoint<span class=o>=</span>unix:///run/containerd/containerd.sock --node-ip<span class=o>=</span>172.18.0.2 --node-labels<span class=o>=</span> --pod-infra-container-image<span class=o>=</span>registry.k8s.io/pause:3.8 --provider-id<span class=o>=</span>kind://docker/aio/aio-control-plane --fail-swap-on<span class=o>=</span><span class=nb>false</span> --cgroup-root<span class=o>=</span>/kubelet
</span></span></code></pre></div><p>可以看到，在容器里确实以 systemd 方式启动了一个containerd 和 kubelet，然后其他组件以静态 pod 的方式被 kubelet 拉起。</p><p>然后 cni 的话 kind 使用的是自己实现的一个简单的 cni，叫做 <a href=https://github.com/kubernetes-sigs/kind/tree/main/images/kindnetd target=_blank rel="noopener noreffer">kindnet</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>root@aio-control-plane:/# kubectl -n kube-system get ds
</span></span><span class=line><span class=cl>NAME         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE
</span></span><span class=line><span class=cl>kindnet      <span class=m>1</span>         <span class=m>1</span>         <span class=m>1</span>       <span class=m>1</span>            <span class=m>1</span>           &lt;none&gt;                   7m32s
</span></span><span class=line><span class=cl>kube-proxy   <span class=m>1</span>         <span class=m>1</span>         <span class=m>1</span>       <span class=m>1</span>            <span class=m>1</span>           kubernetes.io/os<span class=o>=</span>linux   7m34s
</span></span></code></pre></div><h2 id=3-注意事项>3. 注意事项</h2><p>由于 kind 是通过 docker 容器模拟 node 来部署集群的，因此和普通集群有一些差异。主要包括以下几个方面：</p><ul><li><p>文件系统</p><ul><li>kind cluster 中无法直接访问宿主机上的文件</li><li>kind cluster 中无法直接使用宿主机上的镜像</li></ul></li><li><p>网络</p><ul><li>比如无法在宿主机直接访问 kind cluster 中的服务</li></ul></li></ul><p>以上问题 kind 都提供了相应的解决方案，比如镜像导入、端口映射、目录映射等等，具体见下文。</p><h3 id=镜像导入>镜像导入</h3><p>Q：宿主机上使用 docker images 查看明明有镜像，但是 kubectl apply 却要去拉镜像？</p><p>A：这是由于 kind 中的节点实际都是 docker 容器导致的，和宿主机是隔离的。<strong>在宿主机拉取镜像后还需要通过 kind load 方式加载到 node 里面（容器里）去</strong>,否则部署的应用会再次拉取镜像。</p><p>相关命令如下：</p><blockquote><p>以下命令都是在宿主机上执行</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># 查看 node 里的镜像列表</span>
</span></span><span class=line><span class=cl>docker <span class=nb>exec</span> -it dev-control-plane crictl images
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 导入镜像到指定集群</span>
</span></span><span class=line><span class=cl>kind load docker-image caas4/etcd:3.5.5 --name aio
</span></span></code></pre></div><h3 id=heading></h3><h3 id=如何访问集群中的服务>如何访问集群中的服务</h3><p>由于 kind 是把 node 运行在 docker 里的， 因此即使在 k8s 集群中使用 nodePort 方式将服务暴露出来，在宿主机上依旧无法访问。</p><blockquote><p>因为这里暴露的 nodePort 其实是 docker 容器的端口，如果 docker 容器启动时没有将端口映射出来依旧无法访问</p></blockquote><p>有两种解决方案：</p><ul><li><p>进入到对应 network namespace</p></li><li><p>端口映射</p></li></ul><h4 id=进入到对应-network-namespace>进入到对应 network namespace</h4><p>由于kind 集群的 node 是以 docker 容器运行的，那么只需要进入到该容器的 network namespace 就可以访问到 集群中暴露出来的 nodePort。</p><blockquote><p>当然，clusterIP 应该还是无法访问的。</p></blockquote><p>相关命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=nv>containerID</span><span class=o>=</span>xxx
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span><span class=k>$(</span>docker inspect -f <span class=o>{{</span>.State.Pid<span class=o>}}</span> <span class=nv>$containerID</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl>nsenter -n -t <span class=nv>$pid</span>
</span></span></code></pre></div><h4 id=端口映射>端口映射</h4><p>Kind 在<strong>启动集群时</strong>可以指定将某些端口映射出来，因为是通过 docker 跑的，所以后续应该只是把参数传给 docker 了。</p><blockquote><p>类似于指定了 docker run -p 参数。</p><p>注意：由于 docker 容器启动后不能修改端口映射，因此 kind 集群创建后也不能修改端口映射了。</p></blockquote><p>配置文件如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-YAML data-lang=YAML><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>kind.x-k8s.io/v1alpha4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>nodes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>role</span><span class=p>:</span><span class=w> </span><span class=l>control-plane</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>extraPortMappings</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>hostPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>443</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>hostPort</span><span class=p>:</span><span class=w> </span><span class=m>443</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>30000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>hostPort</span><span class=p>:</span><span class=w> </span><span class=m>30000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span></code></pre></div><p>在参数 extraPortMappings 中定义要映射的端口即可，多个节点则需要挨个定义。</p><p>定义了端口映射后再启动集群，对应的 docker 容器就会直接把端口暴露出来了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=o>[</span>root@kind ~<span class=o>]</span><span class=c1># docker ps</span>
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE                                COMMAND                  CREATED          STATUS          PORTS                                                                                           NAMES
</span></span><span class=line><span class=cl>54c8bb471113   kindest/node:v1.25.3                 <span class=s2>&#34;/usr/local/bin/entr…&#34;</span>   <span class=m>10</span> minutes ago   Up <span class=m>10</span> minutes   0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:30000-&gt;30000/tcp, 127.0.0.1:42259-&gt;6443/tcp   portmapping-control-plane
</span></span></code></pre></div><p>这样就可以在宿主机上访问到集群中的服务了。</p><h4 id=小结>小结</h4><p>由于端口映射只能在创建集群时指定，创建后无法修改，因此在测试时建议直接使用方式一，进入到对应 network namespace 进行访问。</p><p>等后续端口固定好之后再通过端口映射一次性搞定。</p><h3 id=目录映射>目录映射</h3><p>和端口映射类似，kind cluster 里的 hostpath 指的是 docker 里的文件系统，而想要用宿主机上的文件还需要再映射一次。</p><blockquote><p>最终还是会把参数传递给 docker，类似于 docker run -v 参数。</p></blockquote><p>同样只能在创建集群时指定，配置文件如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-YAML data-lang=YAML><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>kind.x-k8s.io/v1alpha4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>nodes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>role</span><span class=p>:</span><span class=w> </span><span class=l>control-plane</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>extraMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>hostPath</span><span class=p>:</span><span class=w> </span><span class=l>/home/bill/work/foo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>containerPath</span><span class=p>:</span><span class=w> </span><span class=l>/foo</span><span class=w>
</span></span></span></code></pre></div><p>通过 extraMounts 参数指定需要映射的目录。</p><p>通过该配置文件启动的 docker 容器就会挂载相应目录到容器里。</p><p>集群启动后进入 docker 容器查看，目录映射已经生效：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=o>[</span>root@kind ~<span class=o>]</span><span class=c1># docker ps</span>
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE                                COMMAND                  CREATED          STATUS          PORTS                       NAMES
</span></span><span class=line><span class=cl>5e10f9cbc1bd   kindest/node:v1.25.3                 <span class=s2>&#34;/usr/local/bin/entr…&#34;</span>   <span class=m>7</span> minutes ago    Up <span class=m>7</span> minutes    127.0.0.1:42521-&gt;6443/tcp   volumemapping-control-plane
</span></span><span class=line><span class=cl><span class=o>[</span>root@kind ~<span class=o>]</span><span class=c1># docker exec -it 5e10f9cbc1bd ls /foo</span>
</span></span><span class=line><span class=cl><span class=c1># 这个目录是宿主机上的，能在容器里看到，说明成功了</span>
</span></span><span class=line><span class=cl>systemd-private-668bfa87d90144a1a43345805f73cd6a-chronyd.service-Tuqj3U
</span></span></code></pre></div><h2 id=4小结>4.小结</h2><p>本文主要介绍了 如果快速使用 kind 在本地创建一个 k8s 集群，及其原理和注意事项等。</p><ul><li>如果需要在本地测试的话推荐使用 <a href=https://github.com/kubernetes-sigs/kind target=_blank rel="noopener noreffer">kind</a></li><li>如果需要真正的创建集群的话现在主流工具则是 <a href=https://github.com/kubernetes/kubeadm target=_blank rel="noopener noreffer">kubeadm</a></li></ul><blockquote><p>如果觉得 kubeadm 也比较麻烦的话可以试一下 <a href=https://github.com/kubeclipper/kubeclipper target=_blank rel="noopener noreffer">kubeclipper</a>，基于 kubeadm 工具进行二次封装, <a href="https://landscape.cncf.io/card-mode?category=certified-kubernetes-installer&grouping=category&selected=kube-clipper" target=_blank rel="noopener noreffer">完全兼容原生 Kubernetes</a>, 以<strong>图形化</strong>方式提供在企业自有基础设施中<strong>快速部署 K8S 集群和持续化全生命周期管理</strong>（安装、卸载、升级、扩缩容、远程访问等）能力。</p></blockquote></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-12-10</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/kubernetes/15-kind-kubernetes-in-docker/ data-title="Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群" data-hashtags=Kubernetes><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/kubernetes/15-kind-kubernetes-in-docker/ data-hashtag=Kubernetes><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/kubernetes/15-kind-kubernetes-in-docker/ data-title="Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/kubernetes/15-kind-kubernetes-in-docker/ data-title="Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/kubernetes/15-kind-kubernetes-in-docker/ data-title="Kubernetes教程(十五)---使用 kind 在本地快速部署一个 k8s集群"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/kubernetes/>Kubernetes</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/kubernetes/14-pv-dynamic-provision-process/ class=prev rel=prev title="Kubernetes教程(十四)---PV 从创建到挂载全流程详解"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Kubernetes教程(十四)---PV 从创建到挂载全流程详解</a>
<a href=/posts/tekton/01-deploy-tekton/ class=next rel=next title="Tekton教程(一)---云原生 CICD: Tekton 初体验">Tekton教程(一)---云原生 CICD: Tekton 初体验<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>