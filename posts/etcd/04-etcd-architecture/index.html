<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>etcd教程(四)---etcd架构及其实现简单分析 -</title><meta name=Description content="etcd简单分析及其与zookeeper的区别"><meta property="og:title" content="etcd教程(四)---etcd架构及其实现简单分析"><meta property="og:description" content="etcd简单分析及其与zookeeper的区别"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/etcd/04-etcd-architecture/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-10T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-10T00:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="etcd教程(四)---etcd架构及其实现简单分析"><meta name=twitter:description content="etcd简单分析及其与zookeeper的区别"><meta name=application-name content="指月小筑"><meta name=apple-mobile-web-app-title content="指月小筑"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/etcd/04-etcd-architecture/><link rel=prev href=https://blog.yudlk.com/posts/redis/03-advanced-datastructure/><link rel=next href=https://blog.yudlk.com/posts/etcd/05-watch/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"etcd教程(四)---etcd架构及其实现简单分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/etcd\/04-etcd-architecture\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"etcd","wordcount":4863,"url":"https:\/\/blog.yudlk.com\/posts\/etcd\/04-etcd-architecture\/","datePublished":"2020-02-10T00:00:00+00:00","dateModified":"2020-02-10T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"etcd简单分析及其与zookeeper的区别"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=指月小筑>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>指月小筑</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=指月小筑>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">etcd教程(四)---etcd架构及其实现简单分析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/lixd title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/etcd/><i class="far fa-folder fa-fw" aria-hidden=true></i>etcd</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2020-02-10>2020-02-10</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4863 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;10 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-etcd架构>1. etcd架构</a><ul><li><a href=#1-概述>1. 概述</a></li><li><a href=#2-四要素>2. 四要素</a></li><li><a href=#3-架构模块>3. 架构模块</a></li><li><a href=#4-执行流程>4. 执行流程</a></li></ul></li><li><a href=#2-etcd数据通道>2. etcd数据通道</a></li><li><a href=#3-模块间交互>3. 模块间交互</a></li><li><a href=#4-etcd实现>4. etcd实现</a><ul><li><a href=#1-名字由来>1. 名字由来</a></li><li><a href=#2-raft协议>2. raft协议</a></li><li><a href=#3-mvcc多版本>3. mvcc多版本</a></li><li><a href=#4-索引存储>4. 索引+存储</a></li><li><a href=#5-watch>5. watch</a></li></ul></li><li><a href=#5-etcd与zookeeper比较>5. etcd与zookeeper比较</a><ul><li><a href=#1-cap原则>1. CAP原则</a></li><li><a href=#2-逻辑结构>2. 逻辑结构</a></li><li><a href=#3-临时节点>3. 临时节点</a></li><li><a href=#4-事件模型>4. 事件模型</a></li></ul></li><li><a href=#6-参考>6. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文主要对<code>etcd</code>进行了简单的分析，同时和<code>zookeeper</code>进行了简单的对比。</p><h2 id=1-etcd架构>1. etcd架构</h2><h3 id=1-概述>1. 概述</h3><p>etcd 基于 <strong>Raft 协议</strong>，通过复制日志文件的方式来保证数据的<strong>强一致性</strong>。</p><p><strong>客户端应用写一个 key 时，首先会存储到 etcd Leader 上，然后再通过 Raft 协议复制到 etcd 集群的所有成员中，以此维护各成员（节点）状态的一致性与实现可靠性。</strong></p><p>虽然 etcd 是一个强一致性的系统，但也支持从非 Leader 节点读取数据以提高性能，而且写操作仍然需要 Leader 支持，所以当发生网络分时，写操作仍可能失败。</p><p><strong>etcd 具有一定的容错能力</strong>，假设集群中共有N个节点，即便集群中( n-1) /2个节点发生了故障，只要剩下的( n+1) /2 个节点达成一致， 也能操作成功,因此，它能够有效地应对网络分区和机器故障带来的数据丢失风险。</p><p><strong>etcd 默认数据一更新就落盘持久化，数据持久化存储使用 WAL (write ahead log） ，预写式日志。</strong></p><p>格式 WAL 记录了数据变化的全过程，在 etcd 中所有数据在提交之前都要先写入 WAL 中； etcd Snapshot （快照）文件则存储了某一时刻 etcd 的所有数据，默认设置为每 10 000 条记录做一次快照，经过快照后WAL 文件即可删除。</p><h3 id=2-四要素>2. 四要素</h3><p>etc 在设计的时候重点考虑了如下的四个要素：</p><p><strong>1. 简单</strong></p><ul><li>支持RESTful风格的HTTP+JSON的API</li><li>v3版本增加了对gRPC的支持 同时也提供rest gateway进行转化</li><li>Go语言编写，跨平台，部署和维护简单</li><li>使用Raft算法保证强一致性，Raft算法可理解性好</li></ul><p><strong>2. 安全</strong></p><p>支持TLS客户端安全认证</p><p><strong>3. 性能</strong></p><p>单实例(V3)支持每秒10KQps</p><p><strong>4. 可靠</strong></p><p>使用 Raft 算法充分保证了分布式系统数据的强一致性 etcd 集群是一个分布式系统，由多个节点相互通信构成整体的对外服务，每个节点都存储了完整的数据，并且通过 Raft 协议保证了每个节点维护的数据都是一致的。</p><p>etcd可以扮演两大角色：</p><ul><li>持久化的键值存储系统</li><li>分布式系统数据一致性服务提供者</li></ul><h3 id=3-架构模块>3. 架构模块</h3><p>etcd(Server)大体上可以分为<code>网络层(http(s) server)</code>、<code>Raft模块</code>、<code>复制状态机(RSM)</code>和<code>存储模块</code>,具体如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://github.com/lixd/blog/raw/master/images/etcd/etcd-server-architecture.png data-srcset="https://github.com/lixd/blog/raw/master/images/etcd/etcd-server-architecture.png, https://github.com/lixd/blog/raw/master/images/etcd/etcd-server-architecture.png 1.5x, https://github.com/lixd/blog/raw/master/images/etcd/etcd-server-architecture.png 2x" data-sizes=auto alt=https://github.com/lixd/blog/raw/master/images/etcd/etcd-server-architecture.png title=etcd模块></p><ul><li><p><strong>网络层</strong>:提供网络数据读写功能，监听服务端口，完成集群节点之间数据通信，收发客户端数据。</p></li><li><p><strong>Raft模块</strong>：Raft强一致性算法的具体实现。</p></li><li><p><strong>存储模块</strong>：涉及KV存储、WAL文件、Snapshot管理等，用户处理etcd支持的各类功能的事务，包括数据索引 节点状态变更、监控与反馈、事件处理与执行 ，是 etcd 对用户提供的大多数 API 功能的具体实现。</p></li><li><p><strong>复制状态机</strong>：这是一个抽象的模块，状态机的数据维护在内存中，定期持久化到磁盘，每次写请求都会持久化到 WAL 文件，并根据写请求的内容修改状态机数据。</p></li></ul><h3 id=4-执行流程>4. 执行流程</h3><p>通常，一个用户的请求发送过来，会经由 HTTP ( S) Server 转发给存储模块进行具体的事务处理,如果涉及节点状态的更新，则交给 Raft 模块进行仲裁和日志的记录，然后再同步给别的 etcd 节点，只有当半数以上的节点确认了该节点状态的修改之后，才会进行数据的持久化。</p><p>etcd 集群的各个节点之间需要通过网络来传递数据，具体表现为如下几个方面：</p><ul><li><ol><li>Leader Follower 发送心跳包， Follower Leader 回复消息</li></ol></li><li><ol start=2><li>Leader Follower 发送日志追加信息</li></ol></li><li><ol start=3><li>Leader Follower 发送 Snapshot 数据</li></ol></li><li><ol start=4><li>Candidate 节点发起选举，向其他节点发起投票请求</li></ol></li><li><ol start=5><li>Follower 将收到的写操作转发给 Leader</li></ol></li></ul><h2 id=2-etcd数据通道>2. etcd数据通道</h2><p>在etcd 的实现中， 根据不同的用途，定义了各种不同的消息类型些不同的消息，最终都将通过 <code>protocol buffer</code> 格式进行编码。</p><p>大消息如传输 Snapshot 的数据 就比较大，甚至会超过1GB ，而小消息则如 Leader Follower 节点之间的心跳消息可能只有几十 KB。</p><p>etcd 在实现中，对这些消息采取了分类处理的方式，它抽象出了两种类型的消息传输通道，即 <code>Stream</code>类型通道和 <code>Pipeline</code> 类型通道。</p><ul><li>Stream: 用于处理<code>数据量较少</code>的消息,例如心跳、日志追加消息等。点到点之间维护一个HTTP长连接。</li><li>Pipeline:用于处理<code>数据量大</code>的消息，如Snapshot。不维护长连接。</li></ul><blockquote><p>Snapshot这种数据量大的消息必须和心跳分开传，否则会阻塞心跳消息。</p><p>Pipeline也能用于传小消息前提是Stream不能用了。</p></blockquote><h2 id=3-模块间交互>3. 模块间交互</h2><p><strong>1. 网络层与Raft模块交互</strong></p><p>etcd 通过 Raft 模块中抽象的 RaftNode 拥有一个消息盒子，RaftNode 将各种类型的消息都放入消息盒子中，由专门的 go routine 将消息盒子里的消息写入管道（Go 语言的 Channel ），而管道的另外一端就链接在网络层的不同类型的传输通道上，同样也有专门的 go routine 在等待(select)消息的到达。</p><blockquote><p>网络层与Raft模块之间通过Go语言的Channel来完成数据通信。</p></blockquote><p><strong>2.Server与Client交互</strong></p><p>etcd server 在启动之初 ，会监听服务端口，待服务端口收到客户端的请求之后，就会解析出消息体，然后通过管道传给 Raft 模块，当 Raft 模块按照Raft 协议完成操作时，会回复该请求(或者请求超时关闭了)。</p><p><strong>3.Server之间的交互</strong></p><p>etcd server 之间通过 peer 端口(初始化时可以手动指定)使用 HTTP 进行通信。 etcd server peer端口主要用来协调 Raft 的相关消息，包括各种提议的协商。</p><h2 id=4-etcd实现>4. etcd实现</h2><h3 id=1-名字由来>1. 名字由来</h3><p><code>etcd</code>它是<code>etc</code>和<code>distributed</code>的结合体。</p><blockquote><p>在类<code>unix</code>系统中<code>/etc</code>目录是用于存放配置文件的，二<code>distributed</code>则是分布式的意思。</p></blockquote><p>那么<code>etcd</code>的意思就很明显了：<code>大型分布式系统的配置中心</code>。</p><h3 id=2-raft协议>2. raft协议</h3><ul><li>每次写入都是在一个事务（tx）中完成的。</li><li>一个事务（tx）可以包含若干个写操作。</li><li>etcd集群有一个leader，写请求都会提交给它。</li><li>leader先将数据保存成日志形式，并定时的将日志发往其他节点保存。</li><li>当超过1/2节点成功保存了日志，则leader会将tx最终提交（也是一条日志）。</li><li>一旦leader提交tx，则会在下一次心跳时将提交记录发送给其他节点，其他节点也会提交。</li><li>leader宕机后，剩余节点协商找到拥有最大已提交tx ID（必须是被超过半数的节点已提交的）的节点作为新leader。</li></ul><blockquote><p>具体Raft协议可参考<a href=http://thesecretlivesofdata.com/raft/ target=_blank rel="noopener noreffer">大神制作的Raft协议动画</a></p></blockquote><h3 id=3-mvcc多版本>3. mvcc多版本</h3><ul><li>每个tx事务有唯一事务ID，在etcd中叫做mainID，全局递增不重复。</li><li>一个tx可以包含多个修改操作（put和delete），每一个操作叫做一个revision(修订)，共享同一个mainID。</li><li>一个tx内连续的多个修改操作会被从0递增编号，这个编号叫做subID。</li><li>每个revision由（mainID，subID）唯一标识。</li></ul><h3 id=4-索引存储>4. 索引+存储</h3><p>内存索引+磁盘存储value</p><p>在多版本中，每一次操作行为都被单独记录下来，保存到bbolt中。</p><p>在bbolt中，每个revision将作为key，即将序列化后的(revision.main+revision.sub)作为key;</p><p>在bbolt中存储的value是这样一个json序列化后的结构，包括key创建时的revision（对应某一代generation的created），本次更新版本，sub ID（Version ver），Lease ID（租约ID）如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>kv</span> <span class=o>:=</span> <span class=nx>mvccpb</span><span class=p>.</span><span class=nx>KeyValue</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Key</span><span class=p>:</span>            <span class=nx>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Value</span><span class=p>:</span>          <span class=nx>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>CreateRevision</span><span class=p>:</span> <span class=nx>c</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>ModRevision</span><span class=p>:</span>    <span class=nx>rev</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Version</span><span class=p>:</span>        <span class=nx>ver</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Lease</span><span class=p>:</span>          <span class=nb>int64</span><span class=p>(</span><span class=nx>leaseID</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>因此，我们先通过内存btree在keyIndex.generations[0].revs中找到最后一条revision，即可去bbolt中读取对应的数据。</p><p>相应的，etcd支持按key前缀查询，其实也就是遍历btree的同时根据revision去bbolt中获取用户的value。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>keyIndex</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>key</span>         <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>modified</span>    <span class=nx>revision</span> <span class=c1>// 最后一次修改对应的revision信息。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>generations</span> <span class=p>[]</span><span class=nx>generation</span> <span class=c1>//记录多版本信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// mvcc多版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>generation</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ver</span>     <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=nx>created</span> <span class=nx>revision</span> <span class=c1>// 引起本次key创建的revision信息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>revs</span>    <span class=p>[]</span><span class=nx>revision</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>revision</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>main</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>sub</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>内存索引(btree)中存放keyIndex，磁盘中存放对应的多版本数据(序列化后的(revision.main+revision.sub)作为key)</p><p>用户查询时去内存中(btree)中根据key找到对应的keyIndex,在keyIndex中找到最后一次revision信息 然后根据（revision.main+revision.sub）作为key去磁盘查询具体数据。</p><p>由于会存储下每个版本的数据，所以多次修改后会产生大量数据，可以使用compact 压缩清理掉太久的数据。compact(n)表示压缩掉revision.main &lt;= n的所有历史版本</p><p>多版本总结来说：<strong>内存btree维护的是用户key => keyIndex的映射，keyIndex内维护多版本的revision信息，而revision可以映射到磁盘bbolt中的用户value</strong>。</p><h3 id=5-watch>5. watch</h3><p>etcd的事件通知机制是基于mvcc多版本实现的。</p><p>客户端可以提供一个要监听的revision.main作为watch的起始ID，只要etcd当前的全局自增事务ID > watch起始ID，etcd就会将MVCC在bbolt中存储的所有历史revision数据，逐一顺序的推送给客户端。</p><p><code>zookeeper</code>只会提示数据有更新，由用户主动拉取最新数据，中间多版本数据无法知道。</p><p>etcd会推送每一次修改的数据给用户。</p><p>实际是etcd根据mainID去磁盘查数据，磁盘中数据以revision.main+revision.sub为key(bbolt 数据库中的key)，所以就会依次遍历出所有的版本数据。同时判断遍历到的value中的key(etcd中的key)是不是用户watch的，是则推送给用户。</p><p>这里每次都会遍历数据库性能可能会很差，实际使用时一般用户只会关注最新的revision，不会去关注旧数据。</p><p>同时也不是每个watch都会去遍历一次数据库，将多个watch作为一个watchGroup，一次遍历可以处理多个watch，判断到value中的key属于watchGroup中的某个watch关注的则返回，从而有效减少遍历次数。</p><h2 id=5-etcd与zookeeper比较>5. etcd与zookeeper比较</h2><h3 id=1-cap原则>1. CAP原则</h3><p><strong>zookeeper和etcd都是顺序一致性的（满足CAP的CP）</strong>，意味着无论你访问任意节点，都将获得最终一致的数据视图。这里最终一致比较重要，因为zookeeper使用的<code>paxos</code>和etcd使用的<code>raft</code>都是<code>quorum机制(大多数同意原则)</code>，所以部分节点可能因为任何原因延迟收到更新，但数据将最终一致，高度可靠。</p><h3 id=2-逻辑结构>2. 逻辑结构</h3><p><strong>zookeeper从逻辑上来看是一种目录结构，而etcd从逻辑上来看就是一个k-v结构</strong>。</p><blockquote><p>但etcd的key可以是<code>任意字符串</code>同时在存储上实现了<code>key有序排列</code>。</p></blockquote><p>所以仍旧可以模拟出父子目录关系，例如：key=/a/b/c、/a/b、/a</p><p><strong>结论：etcd本质上是一个有序的k-v存储。</strong></p><h3 id=3-临时节点>3. 临时节点</h3><p>在实现服务发现时，我们一般都会用到zookeeper的临时节点。当客户端掉线一段时间，对应的zookeeper session会过期，那么对应的临时节点就会被自动删除。</p><p>在etcd中对应的是<code>lease租约机制</code>，通过该机制实现了key的自动删除。</p><p>可以在set key的同时携带lease ID，当lease过期后所有关联的key都将被自动删除。</p><h3 id=4-事件模型>4. 事件模型</h3><p>在我们用zookeeper实现服务发现时，我们一般会<code>getChildrenAndWatch</code>来获取一个目录下的所有在线节点，这个API会先获取当前的孩子列表并同时原子注册了一个观察器。</p><p>每当zookeeper发现孩子有变动的时候，就会发送一个通知事件给客户端（同时关闭观察器），此时我们会再次调用getChildrenAndWatch再次获取最新的孩子列表并重新注册观察器。</p><p>简单的来说，zookeeper提供了一个原子API，它先获取当前状态，同时注册一个观察器，当后续变化发生时会发送一次通知到客户端：获取并观察->收到变化事件->获取并观察->收到变化事件->….，如此往复。</p><p>zookeeper的事件模型非常可靠，不会出现发生了更新而客户端不知道的情况，但是特点也很明显：</p><ul><li>事件不包含数据，仅仅是通知变化。</li><li>多次连续的更新，通知会合并成一个；即，客户端收到通知再次拉取数据，会跳过中间的多个版本，只拿到最新数据。</li></ul><p>这些特点并不是缺点，因为一般应用只关注最新状态，并不关注中间的连续变化。</p><p>相反etcd的事件是包含数据的，并且通常情况下连续的更新不会被合并通知，而是逐条通知到客户端。</p><h2 id=6-参考>6. 参考</h2><p><code>《云原生分布式存储基石:etcd深入解析》</code></p><p><code>https://yuerblog.cc/2017/12/10/principle-about-etcd-v3/</code></p><p><code>http://www.wangjialong.cc/2017/09/27/etcd&zookeeper/#more</code></p><p><code>https://www.cnblogs.com/jasontec/p/9651789.html</code></p><p><code>http://jolestar.com/etcd-architecture/</code></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2020-02-10</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/etcd/04-etcd-architecture/ data-title=etcd教程(四)---etcd架构及其实现简单分析 data-hashtags=etcd><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/etcd/04-etcd-architecture/ data-hashtag=etcd><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/etcd/04-etcd-architecture/ data-title=etcd教程(四)---etcd架构及其实现简单分析><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/etcd/04-etcd-architecture/ data-title=etcd教程(四)---etcd架构及其实现简单分析><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/etcd/04-etcd-architecture/ data-title=etcd教程(四)---etcd架构及其实现简单分析><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/etcd/>etcd</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/redis/03-advanced-datastructure/ class=prev rel=prev title=Redis教程(三)---redis高级数据结构><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Redis教程(三)---redis高级数据结构</a>
<a href=/posts/etcd/05-watch/ class=next rel=next title=etcd教程(五)---watch机制原理分析>etcd教程(五)---watch机制原理分析<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/lixd target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>