<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock） -</title><meta name=Description content="MySQL 幻读与InnoDB 间隙锁（Gap Lock）"><meta property="og:title" content="MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock）"><meta property="og:description" content="MySQL 幻读与InnoDB 间隙锁（Gap Lock）"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.yudlk.com/posts/mysql/04-cap-lock/"><meta property="og:image" content="https://blog.yudlk.com/img/jinx.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-25T22:00:00+00:00"><meta property="article:modified_time" content="2020-03-25T22:00:00+00:00"><meta property="og:site_name" content="qpt的个人博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.yudlk.com/img/jinx.png"><meta name=twitter:title content="MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock）"><meta name=twitter:description content="MySQL 幻读与InnoDB 间隙锁（Gap Lock）"><meta name=application-name content="面对疾风"><meta name=apple-mobile-web-app-title content="面对疾风"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.yudlk.com/posts/mysql/04-cap-lock/><link rel=prev href=https://blog.yudlk.com/posts/elasticsearch/01-install-by-docker/><link rel=next href=https://blog.yudlk.com/posts/mysql/06-join-process/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock）","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yudlk.com\/posts\/mysql\/04-cap-lock\/"},"image":["https:\/\/blog.yudlk.com\/img\/jinx.png"],"genre":"posts","keywords":"MySQL","wordcount":3496,"url":"https:\/\/blog.yudlk.com\/posts\/mysql\/04-cap-lock\/","datePublished":"2020-03-25T22:00:00+00:00","dateModified":"2020-03-25T22:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"qpt"},"description":"MySQL 幻读与InnoDB 间隙锁（Gap Lock）"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/ title=面对疾风>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/ title=关于>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title>面对疾风</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title=面对疾风>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title=关于>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock）</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/barrypt title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>qpt</a></span>&nbsp;<span class=post-category>included in <a href=/categories/mysql/><i class="far fa-folder fa-fw" aria-hidden=true></i>MySQL</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2020-03-25>2020-03-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;3496 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;7 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-常见问题>1. 常见问题</a></li><li><a href=#2-如何解决>2. 如何解决</a><ul><li><a href=#1-脏读>1. 脏读</a></li><li><a href=#2-不可重复读>2. 不可重复读</a></li><li><a href=#3-幻读>3. 幻读</a></li></ul></li><li><a href=#3-间隙锁gap-lock>3. 间隙锁（Gap Lock）</a></li><li><a href=#4-加锁规则>4. 加锁规则</a><ul><li><a href=#1-概述>1. 概述</a></li><li><a href=#2-等值查询间隙锁>2. 等值查询间隙锁</a></li><li><a href=#3-非唯一索引等值锁>3. 非唯一索引等值锁</a></li></ul></li><li><a href=#5-间隙锁带来的问题>5. 间隙锁带来的问题</a><ul><li><a href=#1-死锁-1>1. 死锁 1</a></li><li><a href=#2-死锁-2>2. 死锁 2</a></li></ul></li><li><a href=#6-小结>6. 小结</a></li><li><a href=#7-参考>7. 参考</a></li></ul></nav></div></div><div class=content id=content><p>本文对 MySQL 事务隔离级别及其常见问题进行了分析，同时记录了 InnoDB 是如何通过间隙锁来解决幻读的，最后还分析了为什么大部分业务事务隔离级别会使用读已提交级别。</p><h2 id=1-常见问题>1. 常见问题</h2><p>在不考虑事务隔离级别的情况下，DB 操作可能出现以下几个问题：</p><ul><li>1）<strong>脏读</strong>：事务 A 读取了事务 B 更新的数据，然后 事务B 进行回滚操作，那么 事务 A 读取到的数据就是脏数据。<ul><li>指一个事务读取到了另外事务中未提交的数据。</li></ul></li><li>2）<strong>不可重复读</strong>：事务 A 多次读取同一数据，事务 B 在事务 A 读取的过程中，对数据作了<strong>更新</strong>并提交，导致事务 A 多次读取同一数据时，结果不一致。<ul><li>指一个事务读取到了事务中提交的 update 的数据。</li></ul></li><li>3）<strong>幻读</strong>：系统管理员 A 将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候<strong>新增</strong>了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。<ul><li>指一个事务读取到了事务中提交的 insert 的数据。</li></ul></li></ul><blockquote><p>不可重复读和幻读最大的区别，一者是对已存在的行进行操作导致，一者是对不存在的行进行操作导致。</p></blockquote><h2 id=2-如何解决>2. 如何解决</h2><p>ISO 和 ANIS SQL 提供了4 种事务隔离级别的标准。</p><ul><li>read-uncommitted</li><li>read-committed</li><li>repeatable-read</li><li>serializable</li></ul><p>为了解决这些问题，InnoDB 存储引擎同样提供了 4 种事务隔离级别。</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>对InnoDB否</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h3 id=1-脏读>1. 脏读</h3><p>将事务隔离级别提升到读已提交（read-committed）即可限制，禁止其他事务访问当前事务未提交的数据，这样就不会出现脏读的情况。</p><h3 id=2-不可重复读>2. 不可重复读</h3><p>将事务隔离级别提升到可重复读（repeatable-read）即可。</p><p>该事务隔离级别下，每次开启事务都会新建一个快照，在当前事务中的多次查询都是基于此快照进行的，不会查询到其他事务提交的数据，所以也不会出现 不可重复读的问题。</p><h3 id=3-幻读>3. 幻读</h3><p>这个就比较复杂了，只有 InnoDB 存储引擎下把事务隔离级别调到可重复读（repeatable-read）才能限制该问题。</p><p><strong>幻读与不可重复读的区别</strong>：不可重复读是对当前已存在的数据进行更新，导致后续的查询与之前的查询结果不一致，而幻读是新增了满足当前查询条件的行，导致前后查询结果不一致。</p><p>解决不可重复读只需要每次将满足条件的行，加锁即可。</p><p>当是幻读则不能通过该方式解决，因为当前行都不存在怎么加锁。</p><p>于是 MySQL 中为了解决这个问题，新增了一种锁：间隙锁（Gap Lock）。</p><h2 id=3-间隙锁gap-lock>3. 间隙锁（Gap Lock）</h2><blockquote><p>间隙锁是 InnoDB 行锁中的一种。</p></blockquote><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的<strong>间隙</strong>。因此，为了解决幻读问题，mysql InnoDB 只好引入新的锁，也就是间隙锁 (GapLock)。<strong>间隙锁，锁的就是两个值之间的空隙，因此间隙锁只与往间隙里写入记录这个操作冲突</strong> 。值得注意的是，间隙锁只在隔离级别是 <strong>可重复读</strong>隔离级别下才会生效。</p><ul><li>1）行锁(Record Lock)：锁直接加在索引记录上面。</li><li>2）间隙锁(Gap Lock)：锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或者最后一个索引之后的空间，<strong>两边都是开区间</strong>。</li><li>3）Next-Key Lock：行锁与间隙锁组合起来用就叫做 Next-Key Lock，是一个<strong>前开后闭区间</strong>。</li></ul><p>默认情况下，InnoDB工作在 重复读（repeatable-read）的隔离情况下，并且以 Next-Key Lock 的方式对数据进行加锁，这样就可以有效地防止<code>幻读</code>的发生。</p><p>Next-key Lock 是行锁与间隙锁的组合，这样，当 InnoDB 扫描索引记录的时候，会首先对选中的索引记录加上行锁(Record Lock)，再对索引记录两边的间隙加上间隙锁(Gap Lock)。如果一个间隙被事务 A 加了锁，其他事务是不能在这个间隙插入记录的。</p><h2 id=4-加锁规则>4. 加锁规则</h2><h3 id=1-概述>1. 概述</h3><ul><li>1）原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</li><li>2）原则 2：查找过程中访问到的对象才会加锁。</li><li>3）优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li><li>4）优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li><li>5）一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ul><blockquote><p>MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8.0.13。</p></blockquote><p>建表语句和初始化如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>t</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>c</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>d</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>c</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>c</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=kp>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=k>values</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>),(</span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>10</span><span class=p>,</span><span class=mi>10</span><span class=p>),(</span><span class=mi>15</span><span class=p>,</span><span class=mi>15</span><span class=p>,</span><span class=mi>15</span><span class=p>),(</span><span class=mi>20</span><span class=p>,</span><span class=mi>20</span><span class=p>,</span><span class=mi>20</span><span class=p>),(</span><span class=mi>25</span><span class=p>,</span><span class=mi>25</span><span class=p>,</span><span class=mi>25</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h3 id=2-等值查询间隙锁>2. 等值查询间隙锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td></tr><tr><td>update t set d = d+1 where id = 7;</td><td></td><td></td></tr><tr><td></td><td>insert into t values(8,8,8);(blocked)</td><td></td></tr><tr><td></td><td></td><td>update t set d = d+1 where id =10;(Query OK)</td></tr></tbody></table><p>由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ul><li>1）根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li><li>2）同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li></ul><p>所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的</p><h3 id=3-非唯一索引等值锁>3. 非唯一索引等值锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td></tr><tr><td>select id from t where c =5 lock in share mode;</td><td></td><td></td></tr><tr><td></td><td>update t set d = d+1 where id =5;</td><td></td></tr><tr><td></td><td></td><td>insert into t values(7,7,7);(blocked)</td></tr></tbody></table><p>这里 session A 要给索引 c 上 c=5 的这一行加上读锁。</p><ul><li>1）根据原则 1，加锁单位是 next-key lock，因此会给 (0,5]加上 next-key lock。要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。</li><li>2）根据原则 2，访问到的都要加锁，因此要给 (5,10]加 next-key lock。</li><li>3）但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</li><li>4）根据原则 2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ul><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p><h2 id=5-间隙锁带来的问题>5. 间隙锁带来的问题</h2><h3 id=1-死锁-1>1. 死锁 1</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>t</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>c</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>d</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>c</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>c</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=kp>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=k>values</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>),(</span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>10</span><span class=p>,</span><span class=mi>10</span><span class=p>),(</span><span class=mi>15</span><span class=p>,</span><span class=mi>15</span><span class=p>,</span><span class=mi>15</span><span class=p>),(</span><span class=mi>20</span><span class=p>,</span><span class=mi>20</span><span class=p>,</span><span class=mi>20</span><span class=p>),(</span><span class=mi>25</span><span class=p>,</span><span class=mi>25</span><span class=p>,</span><span class=mi>25</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>间隙锁的引入可能会导致死锁。前面提到了<strong>间隙锁只与往间隙里写入记录这个操作冲突</strong>。同一个间隙多次加锁是不会冲突的，于是问题来了。</p><table><thead><tr><th>SessionA</th><th>SessionB</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t where id = 9 for update;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from t where id = 9 for update;</td></tr><tr><td></td><td>insert into values(9,9,9);(blocked)</td></tr><tr><td>insert into values(9,9,9);(ERROR Deadlock found)</td><td></td></tr></tbody></table><p>分析如下：</p><ul><li>1）session A 执行 select … for update 语句，由于 id=9 这一行并不存在，因此会加上间隙锁 (5,10);</li><li>2）session B 执行 select … for update 语句，同样会加上间隙锁 (5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>3）session B 试图插入一行 (9,9,9)，被 session A 的间隙锁挡住了，只好进入等待；</li><li>4）session A 试图插入一行 (9,9,9)，被 session B 的间隙锁挡住了。</li></ul><p>至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。</p><h3 id=2-死锁-2>2. 死锁 2</h3><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin；</td><td></td></tr><tr><td>select id from t where c= 10 lock in share mode;</td><td></td></tr><tr><td></td><td>update t set d= d+1 where c = 10;(blocked)</td></tr><tr><td>insert into t values(8,8,8);</td><td></td></tr><tr><td></td><td>ERROR Deadlock found when trying to get lock;try restaring transaction.</td></tr></tbody></table><p>现在，我们按时间顺序来分析一下为什么是这样的结果。</p><ul><li>1）session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</li><li>2）session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</li></ul><p>你可能会问，session B 的 next-key lock 不是还没申请成功吗？其实是这样的，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步：</p><ul><li>1）先是加 (5,10) 的间隙锁，加锁成功；</li><li>2）然后加 c=10 的行锁，这时候才被锁住的。</li></ul><p>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p><h2 id=6-小结>6. 小结</h2><p>本文对 MySQL 事务隔离级别及其常见问题进行了分析，同时记录了 InnoDB 是如何解决幻读的。</p><p>最后一个问题，既然间隙锁能解决其他锁都解决不了的问题（幻读），那么为什么大部分业务还是使用 读提交事务隔离级别呢（只有在可重复读级别下间隙锁才生效）?</p><ul><li>1）间隙锁的引入可能会出现死锁。</li><li>2）间隙锁的引入，可能会导致同样的语句锁住更大的范围，对并发度有一定影响。</li><li>3）在读提交隔离级别下，锁的范围更小，锁的时间更短。<ul><li>因为读提交隔离级别下有一个优化：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交</li></ul></li></ul><p>所以大部分业务都使用的<code>读提交（Read Commit）级别</code>，同时为了解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 <code>row</code>。</p><h2 id=7-参考>7. 参考</h2><ul><li>《Mysql技术内幕InnoDB存储引擎》</li><li>极客专栏-&lt;MySQL 实战45讲></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2020-03-25</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.yudlk.com/posts/mysql/04-cap-lock/ data-title="MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock）" data-hashtags=MySQL><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.yudlk.com/posts/mysql/04-cap-lock/ data-hashtag=MySQL><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.yudlk.com/posts/mysql/04-cap-lock/ data-title="MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock）"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.yudlk.com/posts/mysql/04-cap-lock/ data-title="MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock）"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.yudlk.com/posts/mysql/04-cap-lock/ data-title="MySQL教程(四)---MySQL 幻读与 InnoDB 间隙锁（Gap Lock）"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/mysql/>MySQL</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/elasticsearch/01-install-by-docker/ class=prev rel=prev title="Elasticsearch教程(一)--使用docker-compose快速搭建 elasticsearch"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Elasticsearch教程(一)--使用docker-compose快速搭建 elasticsearch</a>
<a href=/posts/mysql/06-join-process/ class=next rel=next title="MySQL教程(六)---JOIN 语句执行流程">MySQL教程(六)---JOIN 语句执行流程<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/barrypt target=_blank>qpt</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a rel="license external nofollow noopener noreffer" href=https://beian.miit.gov.cn/ target=_blank>渝ICP备20005680号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.480e58b2c2a8605d406f34667e92ff8f1ae50cfee5b653bead570f004839a983.js integrity="sha256-SA5YssKoYF1AbzRmfpL/jxrlDP7ltlO+rVcPAEg5qYM="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FL23FNP7CM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-FL23FNP7CM" async></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b7c98449a6edf8492a8f3404e6d06a0",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7693630257897132" crossorigin=anonymous></script></body></html>